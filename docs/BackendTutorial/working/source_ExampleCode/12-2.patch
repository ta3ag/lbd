diff -Naur Chapter12_1/Cpu0ISelDAGToDAG.cpp Chapter12_2/Cpu0ISelDAGToDAG.cpp
--- Chapter12_1/Cpu0ISelDAGToDAG.cpp	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/Cpu0ISelDAGToDAG.cpp	2014-03-01 20:58:36.000000000 +0800
@@ -248,10 +248,17 @@
     SDValue RHS = Node->getOperand(1);
 
     EVT VT = LHS.getValueType();
-    SDNode *StatusWord = CurDAG->getMachineNode(Cpu0::CMP, DL, VT, Ops);
-    SDValue Constant1 = CurDAG->getTargetConstant(1, VT);
-    SDNode *Carry = CurDAG->getMachineNode(Cpu0::ANDi, DL, VT, 
-                                           SDValue(StatusWord,0), Constant1);
+    const Cpu0TargetMachine &TM = getTargetMachine();
+    const Cpu0Subtarget &Subtarget = TM.getSubtarget<Cpu0Subtarget>();
+    SDNode *Carry;
+    if (Subtarget.hasCpu032II())
+      Carry = CurDAG->getMachineNode(Cpu0::SLTu, DL, VT, Ops);
+    else {
+      SDNode *StatusWord = CurDAG->getMachineNode(Cpu0::CMP, DL, VT, Ops);
+      SDValue Constant1 = CurDAG->getTargetConstant(1, VT);
+      Carry = CurDAG->getMachineNode(Cpu0::ANDi, DL, VT, 
+                                             SDValue(StatusWord,0), Constant1);
+    }
     SDNode *AddCarry = CurDAG->getMachineNode(Cpu0::ADDu, DL, VT,
                                               SDValue(Carry,0), RHS);
 
diff -Naur Chapter12_1/Cpu0InstrInfo.cpp Chapter12_2/Cpu0InstrInfo.cpp
--- Chapter12_1/Cpu0InstrInfo.cpp	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/Cpu0InstrInfo.cpp	2014-03-01 20:58:36.000000000 +0800
@@ -37,6 +37,7 @@
             bool KillSrc) const {
   unsigned Opc = 0, ZeroReg = 0;
 
+  const Cpu0Subtarget &Subtarget = TM.getSubtarget<Cpu0Subtarget>();
   if (Cpu0::CPURegsRegClass.contains(DestReg)) { // Copy to CPU Reg.
     if (Cpu0::CPURegsRegClass.contains(SrcReg))
       Opc = Cpu0::ADD, ZeroReg = Cpu0::ZERO;
diff -Naur Chapter12_1/Disassembler/Cpu0Disassembler.cpp Chapter12_2/Disassembler/Cpu0Disassembler.cpp
--- Chapter12_1/Disassembler/Cpu0Disassembler.cpp	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/Disassembler/Cpu0Disassembler.cpp	2014-03-01 20:58:36.000000000 +0800
@@ -71,6 +71,11 @@
                                        uint64_t Address,
                                        const void *Decoder);
 // lbd document - mark - declare DecodeCMPInstruction
+static DecodeStatus DecodeBranch16Target(MCInst &Inst,
+                                       unsigned Insn,
+                                       uint64_t Address,
+                                       const void *Decoder);
+// lbd document - mark - declare DecodeBranch16Target
 static DecodeStatus DecodeBranch24Target(MCInst &Inst,
                                        unsigned Insn,
                                        uint64_t Address,
@@ -249,6 +254,17 @@
   return MCDisassembler::Success;
 } // lbd document - mark - DecodeCMPInstruction
 
+static DecodeStatus DecodeBranch16Target(MCInst &Inst,
+                                       unsigned Insn,
+                                       uint64_t Address,
+                                       const void *Decoder) {
+  int BranchOffset = fieldFromInstruction(Insn, 0, 16);
+  if (BranchOffset > 0x8fff)
+  	BranchOffset = -1*(0x10000 - BranchOffset);
+  Inst.addOperand(MCOperand::CreateImm(BranchOffset));
+  return MCDisassembler::Success;
+} // lbd document - mark - DecodeBranch16Target
+
 /* CBranch instruction define $ra and then imm24; The printOperand() print 
 operand 1 (operand 0 is $ra and operand 1 is imm24), so we Create register 
 operand first and create imm24 next, as follows,
diff -Naur Chapter12_1/MCTargetDesc/Cpu0AsmBackend.cpp Chapter12_2/MCTargetDesc/Cpu0AsmBackend.cpp
--- Chapter12_1/MCTargetDesc/Cpu0AsmBackend.cpp	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/MCTargetDesc/Cpu0AsmBackend.cpp	2014-03-01 20:58:36.000000000 +0800
@@ -39,6 +39,7 @@
   case Cpu0::fixup_Cpu0_LO16:
   case Cpu0::fixup_Cpu0_GOT_LO16:
     break;
+  case Cpu0::fixup_Cpu0_PC16:
   case Cpu0::fixup_Cpu0_PC24:
     // So far we are only using this type for branches and jump.
     // For branches we start 1 instruction after the branch
@@ -138,6 +139,7 @@
       { "fixup_Cpu0_GPREL16",        0,     16,   0 },
       { "fixup_Cpu0_GOT_Global",     0,     16,   0 },
       { "fixup_Cpu0_GOT_Local",      0,     16,   0 },
+      { "fixup_Cpu0_PC16",           0,     16,  MCFixupKindInfo::FKF_IsPCRel },
       { "fixup_Cpu0_PC24",           0,     24,  MCFixupKindInfo::FKF_IsPCRel },
       { "fixup_Cpu0_CALL16",         0,     16,   0 },
       { "fixup_Cpu0_GOT_HI16",       0,     16,   0 },
diff -Naur Chapter12_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp Chapter12_2/MCTargetDesc/Cpu0ELFObjectWriter.cpp
--- Chapter12_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/MCTargetDesc/Cpu0ELFObjectWriter.cpp	2014-03-01 20:58:36.000000000 +0800
@@ -120,6 +120,9 @@
   case Cpu0::fixup_Cpu0_GOT_Local:
     Type = ELF::R_CPU0_GOT16;
     break;
+  case Cpu0::fixup_Cpu0_PC16:
+    Type = ELF::R_CPU0_PC16;
+    break;
   case Cpu0::fixup_Cpu0_PC24:
     Type = ELF::R_CPU0_PC24;
     break;
diff -Naur Chapter12_1/MCTargetDesc/Cpu0FixupKinds.h Chapter12_2/MCTargetDesc/Cpu0FixupKinds.h
--- Chapter12_1/MCTargetDesc/Cpu0FixupKinds.h	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/MCTargetDesc/Cpu0FixupKinds.h	2014-03-01 20:58:36.000000000 +0800
@@ -44,6 +44,10 @@
     // Local symbol fixup resulting in - R_CPU0_GOT16.
     fixup_Cpu0_GOT_Local,
     
+    // PC relative branch fixup resulting in - R_CPU0_PC16.
+    // cpu0 PC16, e.g. beq
+    fixup_Cpu0_PC16,
+    
     // PC relative branch fixup resulting in - R_CPU0_PC24.
     // cpu0 PC24, e.g. jeq, jmp
     fixup_Cpu0_PC24,
diff -Naur Chapter12_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp Chapter12_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp
--- Chapter12_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2014-03-01 20:58:36.000000000 +0800
+++ Chapter12_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2014-03-01 20:58:36.000000000 +0800
@@ -72,6 +72,13 @@
   uint64_t getBinaryCodeForInstr(const MCInst &MI,
                                  SmallVectorImpl<MCFixup> &Fixups) const;
 
+  // getBranch16TargetOpValue - Return binary encoding of the branch
+  // target operand, such as BEQ, BNE. If the machine operand
+  // requires relocation, record the relocation and return zero.
+  unsigned getBranch16TargetOpValue(const MCInst &MI, unsigned OpNo,
+                                  SmallVectorImpl<MCFixup> &Fixups) const;
+  // lbd document - mark - declare getBranch16TargetOpValue
+
   // getBranch24TargetOpValue - Return binary encoding of the branch
   // target operand, such as JMP #BB01, JEQ, JSUB. If the machine operand
   // requires relocation, record the relocation and return zero.
@@ -141,6 +148,25 @@
   EmitInstruction(Binary, Size, OS);
 }
 
+/// getBranch16TargetOpValue - Return binary encoding of the branch
+/// target operand. If the machine operand requires relocation,
+/// record the relocation and return zero.
+unsigned Cpu0MCCodeEmitter::
+getBranch16TargetOpValue(const MCInst &MI, unsigned OpNo,
+                       SmallVectorImpl<MCFixup> &Fixups) const {
+
+  const MCOperand &MO = MI.getOperand(OpNo);
+
+  // If the destination is an immediate, we have nothing to do.
+  if (MO.isImm()) return MO.getImm();
+  assert(MO.isExpr() && "getBranch16TargetOpValue expects only expressions");
+
+  const MCExpr *Expr = MO.getExpr();
+  Fixups.push_back(MCFixup::Create(0, Expr,
+                                   MCFixupKind(Cpu0::fixup_Cpu0_PC16)));
+  return 0;
+} // lbd document - mark - getBranch16TargetOpValue
+
 /// getBranch24TargetOpValue - Return binary encoding of the branch
 /// target operand. If the machine operand requires relocation,
 /// record the relocation and return zero.
