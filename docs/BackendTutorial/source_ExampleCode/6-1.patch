diff -Naur Chapter5_1/CMakeLists.txt Chapter6_1/CMakeLists.txt
--- Chapter5_1/CMakeLists.txt	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/CMakeLists.txt	2013-07-01 10:40:46.377544480 +0800
@@ -30,9 +30,11 @@
   Cpu0ISelLowering.cpp
   Cpu0FrameLowering.cpp
   Cpu0MCInstLower.cpp
+  Cpu0MachineFunction.cpp
   Cpu0RegisterInfo.cpp
   Cpu0Subtarget.cpp
   Cpu0TargetMachine.cpp
+  Cpu0TargetObjectFile.cpp
   Cpu0SelectionDAGInfo.cpp
   )
 
diff -Naur Chapter5_1/Cpu0AsmPrinter.cpp Chapter6_1/Cpu0AsmPrinter.cpp
--- Chapter5_1/Cpu0AsmPrinter.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0AsmPrinter.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -185,6 +185,9 @@
   MCInstLowering.Initialize(Mang, &MF->getContext());
 
   emitFrameDirective();
+  bool EmitCPLoad = (MF->getTarget().getRelocationModel() == Reloc::PIC_) &&
+    Cpu0FI->globalBaseRegSet() &&
+    Cpu0FI->globalBaseRegFixed();
 
   if (OutStreamer.hasRawTextSupport()) {
     SmallString<128> Str;
@@ -192,9 +195,18 @@
     printSavedRegsBitmask(OS);
     OutStreamer.EmitRawText(OS.str());
     OutStreamer.EmitRawText(StringRef("\t.set\tnoreorder"));
+    // Emit .cpload directive if needed.
+    if (EmitCPLoad)
+      OutStreamer.EmitRawText(StringRef("\t.cpload\t$t9"));
     OutStreamer.EmitRawText(StringRef("\t.set\tnomacro"));
     if (Cpu0FI->getEmitNOAT())
-      OutStreamer.EmitRawText(StringRef("\t.set\tat"));
+      OutStreamer.EmitRawText(StringRef("\t.set\tnoat"));
+  } else if (EmitCPLoad) {
+    SmallVector<MCInst, 4> MCInsts;
+    MCInstLowering.LowerCPLOAD(MCInsts);
+    for (SmallVector<MCInst, 4>::iterator I = MCInsts.begin();
+       I != MCInsts.end(); ++I)
+      OutStreamer.EmitInstruction(*I);
   }
 }
 
diff -Naur Chapter5_1/Cpu0InstrInfo.td Chapter6_1/Cpu0InstrInfo.td
--- Chapter5_1/Cpu0InstrInfo.td	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0InstrInfo.td	2013-07-01 10:40:46.377544480 +0800
@@ -27,6 +27,13 @@
                                          [SDTCisInt<0>,
                                           SDTCisSameAs<0, 1>]>;
 
+// Hi and Lo nodes are used to handle global addresses. Used on
+// Cpu0ISelLowering to lower stuff like GlobalAddress, ExternalSymbol
+// static model. (nothing to do with Cpu0 Registers Hi and Lo)
+def Cpu0Hi    : SDNode<"Cpu0ISD::Hi", SDTIntUnaryOp>;
+def Cpu0Lo    : SDNode<"Cpu0ISD::Lo", SDTIntUnaryOp>;
+def Cpu0GPRel : SDNode<"Cpu0ISD::GPRel", SDTIntUnaryOp>;
+
 // Return
 def Cpu0Ret : SDNode<"Cpu0ISD::Ret", SDT_Cpu0Ret, [SDNPHasChain,
                      SDNPOptInGlue]>;
@@ -54,6 +61,11 @@
 
 def shamt       : Operand<i32>;
 
+// Unsigned Operand
+def uimm16      : Operand<i32> {
+  let PrintMethod = "printUnsignedImm";
+}
+
 // Address operand
 def mem : Operand<i32> {
   let PrintMethod = "printMemOperand";
@@ -81,6 +93,17 @@
 // e.g. addi, andi
 def immSExt16  : PatLeaf<(imm), [{ return isInt<16>(N->getSExtValue()); }]>;
 
+// Node immediate fits as 16-bit zero extended on target immediate.
+// The LO16 param means that only the lower 16 bits of the node
+// immediate are caught.
+// e.g. addiu, sltiu
+def immZExt16  : PatLeaf<(imm), [{
+  if (N->getValueType(0) == MVT::i32)
+    return (uint32_t)N->getZExtValue() == (unsigned short)N->getZExtValue();
+  else
+    return (uint64_t)N->getZExtValue() == (unsigned short)N->getZExtValue();
+}]>;
+
 // shamt field must fit in 5 bits.
 def immZExt5 : ImmLeaf<i32, [{return Imm == (Imm & 0x1f);}]>;
 
@@ -273,7 +296,6 @@
 def OR      : ArithLogicR<0x19, "or", or, IIAlu, CPURegs, 1>;
 def XOR     : ArithLogicR<0x1A, "xor", xor, IIAlu, CPURegs, 1>;
 
-
 def MULT    : Mult32<0x50, "mult", IIImul>;
 def MULTu   : Mult32<0x51, "multu", IIImul>;
 
@@ -313,15 +335,26 @@
 //===----------------------------------------------------------------------===//
 
 // Small immediates
-
 def : Pat<(i32 immSExt16:$in),
           (ADDiu ZERO, imm:$in)>;
-          
+
 // Arbitrary immediates
 def : Pat<(i32 imm:$imm),
           (OR (SHL (ADDiu ZERO, (HI16 imm:$imm)), 16), (ADDiu ZERO, (LO16 
               imm:$imm)))>;
 
+// hi/lo relocs
+def : Pat<(Cpu0Hi tglobaladdr:$in), (SHL (ADDiu ZERO, tglobaladdr:$in), 16)>;
+// Expect cpu0 add LUi support, like Mips
+//def : Pat<(Cpu0Hi tglobaladdr:$in), (LUi tglobaladdr:$in)>;
+def : Pat<(Cpu0Lo tglobaladdr:$in), (ADDiu ZERO, tglobaladdr:$in)>;
+
+def : Pat<(add CPURegs:$hi, (Cpu0Lo tglobaladdr:$lo)),
+          (ADDiu CPURegs:$hi, tglobaladdr:$lo)>;
+
+// gp_rel relocs
+def : Pat<(add CPURegs:$gp, (Cpu0GPRel tglobaladdr:$in)),
+          (ADDiu CPURegs:$gp, tglobaladdr:$in)>;
 
 def : Pat<(not CPURegs:$in),
           (XOR CPURegs:$in, (ADDiu ZERO, 1))>;
diff -Naur Chapter5_1/Cpu0ISelDAGToDAG.cpp Chapter6_1/Cpu0ISelDAGToDAG.cpp
--- Chapter5_1/Cpu0ISelDAGToDAG.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0ISelDAGToDAG.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -13,6 +13,7 @@
 
 #define DEBUG_TYPE "cpu0-isel"
 #include "Cpu0.h"
+#include "Cpu0MachineFunction.h"
 #include "Cpu0RegisterInfo.h"
 #include "Cpu0Subtarget.h"
 #include "Cpu0TargetMachine.h"
@@ -94,6 +95,7 @@
   inline SDValue getImm(const SDNode *Node, unsigned Imm) {
     return CurDAG->getTargetConstant(Imm, Node->getValueType(0));
   }
+  void InitGlobalBaseReg(MachineFunction &MF);
 };
 }
 
@@ -103,6 +105,13 @@
   return Ret;
 }
 
+/// getGlobalBaseReg - Output the instructions required to put the
+/// GOT address into a register.
+SDNode *Cpu0DAGToDAGISel::getGlobalBaseReg() {
+  unsigned GlobalBaseReg = MF->getInfo<Cpu0FunctionInfo>()->getGlobalBaseReg();
+  return CurDAG->getRegister(GlobalBaseReg, TLI.getPointerTy()).getNode();
+}
+
 /// ComplexPattern used on Cpu0InstrInfo
 /// Used on Cpu0 Load/Store instructions
 bool Cpu0DAGToDAGISel::
@@ -131,6 +140,19 @@
     return true;
   }
 
+  // on PIC code Load GA
+  if (Addr.getOpcode() == Cpu0ISD::Wrapper) {
+    Base   = Addr.getOperand(0);
+    Offset = Addr.getOperand(1);
+    return true;
+  }
+
+  if (TM.getRelocationModel() != Reloc::PIC_) {
+    if ((Addr.getOpcode() == ISD::TargetExternalSymbol ||
+        Addr.getOpcode() == ISD::TargetGlobalAddress))
+      return false;
+  }
+
   Base   = Addr;
   Offset = CurDAG->getTargetConstant(0, ValTy);
   return true;
@@ -188,6 +210,16 @@
     return SelectMULT(Node, MultOpc, dl, NodeTy, false, true).second;
   }
 
+  // Get target GOT address.
+  // For global variables as follows,
+  //- @gI = global i32 100, align 4
+  //- %2 = load i32* @gI, align 4
+  // =>
+  //- .cpload	$gp
+  //- ld	$2, %got(gI)($gp)
+  case ISD::GLOBAL_OFFSET_TABLE:
+    return getGlobalBaseReg();
+
   case ISD::Constant: {
     const ConstantSDNode *CN = dyn_cast<ConstantSDNode>(Node);
     unsigned Size = CN->getValueSizeInBits(0);
diff -Naur Chapter5_1/Cpu0ISelLowering.cpp Chapter6_1/Cpu0ISelLowering.cpp
--- Chapter5_1/Cpu0ISelLowering.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0ISelLowering.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -14,9 +14,11 @@
 
 #define DEBUG_TYPE "cpu0-lower"
 #include "Cpu0ISelLowering.h"
+#include "Cpu0MachineFunction.h"
 #include "Cpu0TargetMachine.h"
-#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+#include "Cpu0TargetObjectFile.h"
 #include "Cpu0Subtarget.h"
+#include "MCTargetDesc/Cpu0BaseInfo.h"
 #include "llvm/IR/DerivedTypes.h"
 #include "llvm/IR/Function.h"
 #include "llvm/IR/GlobalVariable.h"
@@ -29,20 +31,100 @@
 #include "llvm/CodeGen/MachineRegisterInfo.h"
 #include "llvm/CodeGen/SelectionDAGISel.h"
 #include "llvm/CodeGen/ValueTypes.h"
+#include "llvm/Support/CommandLine.h"
 #include "llvm/Support/Debug.h"
 #include "llvm/Support/ErrorHandling.h"
 #include "llvm/Support/raw_ostream.h"
 
 using namespace llvm;
 
+SDValue Cpu0TargetLowering::getGlobalReg(SelectionDAG &DAG, EVT Ty) const {
+  Cpu0FunctionInfo *FI = DAG.getMachineFunction().getInfo<Cpu0FunctionInfo>();
+  return DAG.getRegister(FI->getGlobalBaseReg(), Ty);
+}
+
+static SDValue getTargetNode(SDValue Op, SelectionDAG &DAG, unsigned Flag) {
+  EVT Ty = Op.getValueType();
+
+  if (GlobalAddressSDNode *N = dyn_cast<GlobalAddressSDNode>(Op))
+    return DAG.getTargetGlobalAddress(N->getGlobal(), Op.getDebugLoc(), Ty, 0,
+                                      Flag);
+  if (ExternalSymbolSDNode *N = dyn_cast<ExternalSymbolSDNode>(Op))
+    return DAG.getTargetExternalSymbol(N->getSymbol(), Ty, Flag);
+  if (BlockAddressSDNode *N = dyn_cast<BlockAddressSDNode>(Op))
+    return DAG.getTargetBlockAddress(N->getBlockAddress(), Ty, 0, Flag);
+  if (JumpTableSDNode *N = dyn_cast<JumpTableSDNode>(Op))
+    return DAG.getTargetJumpTable(N->getIndex(), Ty, Flag);
+  if (ConstantPoolSDNode *N = dyn_cast<ConstantPoolSDNode>(Op))
+    return DAG.getTargetConstantPool(N->getConstVal(), Ty, N->getAlignment(),
+                                     N->getOffset(), Flag);
+
+  llvm_unreachable("Unexpected node type.");
+  return SDValue();
+}
+
+SDValue Cpu0TargetLowering::getAddrLocal(SDValue Op, SelectionDAG &DAG) const {
+  DebugLoc DL = Op.getDebugLoc();
+  EVT Ty = Op.getValueType();
+  unsigned GOTFlag = Cpu0II::MO_GOT;
+  SDValue GOT = DAG.getNode(Cpu0ISD::Wrapper, DL, Ty, getGlobalReg(DAG, Ty),
+                            getTargetNode(Op, DAG, GOTFlag));
+  SDValue Load = DAG.getLoad(Ty, DL, DAG.getEntryNode(), GOT,
+                             MachinePointerInfo::getGOT(), false, false, false,
+                             0);
+  unsigned LoFlag = Cpu0II::MO_ABS_LO;
+  SDValue Lo = DAG.getNode(Cpu0ISD::Lo, DL, Ty, getTargetNode(Op, DAG, LoFlag));
+  return DAG.getNode(ISD::ADD, DL, Ty, Load, Lo);
+}
+
+SDValue Cpu0TargetLowering::getAddrGlobal(SDValue Op, SelectionDAG &DAG,
+                                          unsigned Flag) const {
+  DebugLoc DL = Op.getDebugLoc();
+  EVT Ty = Op.getValueType();
+  SDValue Tgt = DAG.getNode(Cpu0ISD::Wrapper, DL, Ty, getGlobalReg(DAG, Ty),
+                            getTargetNode(Op, DAG, Flag));
+  return DAG.getLoad(Ty, DL, DAG.getEntryNode(), Tgt,
+                     MachinePointerInfo::getGOT(), false, false, false, 0);
+}
+
+SDValue Cpu0TargetLowering::getAddrGlobalLargeGOT(SDValue Op, SelectionDAG &DAG,
+                                                  unsigned HiFlag,
+                                                  unsigned LoFlag) const {
+  DebugLoc DL = Op.getDebugLoc();
+  EVT Ty = Op.getValueType();
+  SDValue Hi = DAG.getNode(Cpu0ISD::Hi, DL, Ty, getTargetNode(Op, DAG, HiFlag));
+  Hi = DAG.getNode(ISD::ADD, DL, Ty, Hi, getGlobalReg(DAG, Ty));
+  SDValue Wrapper = DAG.getNode(Cpu0ISD::Wrapper, DL, Ty, Hi,
+                                getTargetNode(Op, DAG, LoFlag));
+  return DAG.getLoad(Ty, DL, DAG.getEntryNode(), Wrapper,
+                     MachinePointerInfo::getGOT(), false, false, false, 0);
+}
+
+const char *Cpu0TargetLowering::getTargetNodeName(unsigned Opcode) const {
+  switch (Opcode) {
+  case Cpu0ISD::JmpLink:           return "Cpu0ISD::JmpLink";
+  case Cpu0ISD::Hi:                return "Cpu0ISD::Hi";
+  case Cpu0ISD::Lo:                return "Cpu0ISD::Lo";
+  case Cpu0ISD::GPRel:             return "Cpu0ISD::GPRel";
+  case Cpu0ISD::Ret:               return "Cpu0ISD::Ret";
+  case Cpu0ISD::DivRem:            return "Cpu0ISD::DivRem";
+  case Cpu0ISD::DivRemU:           return "Cpu0ISD::DivRemU";
+  case Cpu0ISD::Wrapper:           return "Cpu0ISD::Wrapper";
+  default:                         return NULL;
+  }
+}
+
 Cpu0TargetLowering::
 Cpu0TargetLowering(Cpu0TargetMachine &TM)
-  : TargetLowering(TM, new TargetLoweringObjectFileELF()),
+  : TargetLowering(TM, new Cpu0TargetObjectFile()),
     Subtarget(&TM.getSubtarget<Cpu0Subtarget>()) {
 
   // Set up the register classes
   addRegisterClass(MVT::i32, &Cpu0::CPURegsRegClass);
 
+  // Cpu0 Custom Operations
+  setOperationAction(ISD::GlobalAddress,      MVT::i32,   Custom);
+
   setOperationAction(ISD::SDIV, MVT::i32, Expand);
   setOperationAction(ISD::SREM, MVT::i32, Expand);
   setOperationAction(ISD::UDIV, MVT::i32, Expand);
@@ -112,6 +194,63 @@
   return SDValue();
 }
 
+SDValue Cpu0TargetLowering::
+LowerOperation(SDValue Op, SelectionDAG &DAG) const
+{
+  switch (Op.getOpcode())
+  {
+    case ISD::GlobalAddress:      return LowerGlobalAddress(Op, DAG);
+  }
+  return SDValue();
+}
+
+//===----------------------------------------------------------------------===//
+//  Lower helper functions
+//===----------------------------------------------------------------------===//
+
+//===----------------------------------------------------------------------===//
+//  Misc Lower Operation implementation
+//===----------------------------------------------------------------------===//
+
+SDValue Cpu0TargetLowering::LowerGlobalAddress(SDValue Op,
+                                               SelectionDAG &DAG) const {
+  // FIXME there isn't actually debug info here
+  DebugLoc dl = Op.getDebugLoc();
+  const GlobalValue *GV = cast<GlobalAddressSDNode>(Op)->getGlobal();
+
+  Cpu0TargetObjectFile &TLOF = (Cpu0TargetObjectFile&)getObjFileLowering();
+
+  if (getTargetMachine().getRelocationModel() != Reloc::PIC_) {
+    SDVTList VTs = DAG.getVTList(MVT::i32);
+
+    // %gp_rel relocation
+    if (TLOF.IsGlobalInSmallSection(GV, getTargetMachine())) {
+      SDValue GA = DAG.getTargetGlobalAddress(GV, dl, MVT::i32, 0,
+                                              Cpu0II::MO_GPREL);
+      SDValue GPRelNode = DAG.getNode(Cpu0ISD::GPRel, dl, VTs, &GA, 1);
+      SDValue GOT = DAG.getGLOBAL_OFFSET_TABLE(MVT::i32);
+      return DAG.getNode(ISD::ADD, dl, MVT::i32, GOT, GPRelNode);
+    }
+    // %hi/%lo relocation
+    SDValue GAHi = DAG.getTargetGlobalAddress(GV, dl, MVT::i32, 0,
+                                              Cpu0II::MO_ABS_HI);
+    SDValue GALo = DAG.getTargetGlobalAddress(GV, dl, MVT::i32, 0,
+                                              Cpu0II::MO_ABS_LO);
+    SDValue HiPart = DAG.getNode(Cpu0ISD::Hi, dl, VTs, &GAHi, 1);
+    SDValue Lo = DAG.getNode(Cpu0ISD::Lo, dl, MVT::i32, GALo);
+    return DAG.getNode(ISD::ADD, dl, MVT::i32, HiPart, Lo);
+  }
+
+  if (GV->hasInternalLinkage() || (GV->hasLocalLinkage() && !isa<Function>(GV)))
+    return getAddrLocal(Op, DAG);
+
+  if (TLOF.IsGlobalInSmallSection(GV, getTargetMachine()))
+    return getAddrGlobal(Op, DAG, Cpu0II::MO_GOT16);
+  else
+    return getAddrGlobalLargeGOT(Op, DAG, Cpu0II::MO_GOT_HI16,
+                                 Cpu0II::MO_GOT_LO16);
+}
+
 #include "Cpu0GenCallingConv.inc"
 
 /// LowerFormalArguments - transform physical registers into virtual registers
diff -Naur Chapter5_1/Cpu0ISelLowering.h Chapter6_1/Cpu0ISelLowering.h
--- Chapter5_1/Cpu0ISelLowering.h	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0ISelLowering.h	2013-07-01 10:40:46.377544480 +0800
@@ -25,10 +25,32 @@
     enum NodeType {
       // Start the numbering from where ISD NodeType finishes.
       FIRST_NUMBER = ISD::BUILTIN_OP_END,
+
+      // Jump and link (call)
+      JmpLink,
+
+      // Get the Higher 16 bits from a 32-bit immediate
+      // No relation with Cpu0 Hi register
+      Hi,
+      // Get the Lower 16 bits from a 32-bit immediate
+      // No relation with Cpu0 Lo register
+      Lo,
+
+      // Handle gp_rel (small data/bss sections) relocation.
+      GPRel,
+
+      // Thread Pointer
+      ThreadPointer,
+      // Return
       Ret,
+
       // DivRem(u)
       DivRem,
-      DivRemU
+      DivRemU,
+
+      Wrapper,
+      DynAlloc,
+      Sync
     };
   }
 
@@ -40,12 +62,33 @@
   public:
     explicit Cpu0TargetLowering(Cpu0TargetMachine &TM);
 
+    virtual MVT getShiftAmountTy(EVT LHSTy) const { return MVT::i32; }
+    /// LowerOperation - Provide custom lowering hooks for some operations.
+    virtual SDValue LowerOperation(SDValue Op, SelectionDAG &DAG) const;
+
+    /// getTargetNodeName - This method returns the name of a target specific
+    //  DAG node.
+    virtual const char *getTargetNodeName(unsigned Opcode) const;
+
     virtual SDValue PerformDAGCombine(SDNode *N, DAGCombinerInfo &DCI) const;
 
+  protected:
+    SDValue getGlobalReg(SelectionDAG &DAG, EVT Ty) const;
+
+    SDValue getAddrLocal(SDValue Op, SelectionDAG &DAG) const;
+
+    SDValue getAddrGlobal(SDValue Op, SelectionDAG &DAG, unsigned Flag) const;
+
+    SDValue getAddrGlobalLargeGOT(SDValue Op, SelectionDAG &DAG,
+                                  unsigned HiFlag, unsigned LoFlag) const;
+
   private:
     // Subtarget Info
     const Cpu0Subtarget *Subtarget;
 
+    // Lower Operand specifics
+    SDValue LowerGlobalAddress(SDValue Op, SelectionDAG &DAG) const;
+
 	//- must be exist without function all
     virtual SDValue
       LowerFormalArguments(SDValue Chain,
diff -Naur Chapter5_1/Cpu0MachineFunction.cpp Chapter6_1/Cpu0MachineFunction.cpp
--- Chapter5_1/Cpu0MachineFunction.cpp	1970-01-01 08:00:00.000000000 +0800
+++ Chapter6_1/Cpu0MachineFunction.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -0,0 +1,44 @@
+//===-- Cpu0MachineFunctionInfo.cpp - Private data used for Cpu0 ----------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Cpu0MachineFunction.h"
+#include "Cpu0InstrInfo.h"
+#include "Cpu0Subtarget.h"
+#include "MCTargetDesc/Cpu0BaseInfo.h"
+#include "llvm/IR/Function.h"
+#include "llvm/CodeGen/MachineInstrBuilder.h"
+#include "llvm/CodeGen/MachineRegisterInfo.h"
+
+using namespace llvm;
+
+bool FixGlobalBaseReg = true;
+
+bool Cpu0FunctionInfo::globalBaseRegFixed() const {
+  return FixGlobalBaseReg;
+}
+
+bool Cpu0FunctionInfo::globalBaseRegSet() const {
+  return GlobalBaseReg;
+}
+
+unsigned Cpu0FunctionInfo::getGlobalBaseReg() {
+  // Return if it has already been initialized.
+  if (GlobalBaseReg)
+    return GlobalBaseReg;
+
+  if (FixGlobalBaseReg) // $gp is the global base register.
+    return GlobalBaseReg = Cpu0::GP;
+
+  const TargetRegisterClass *RC;
+  RC = (const TargetRegisterClass*)&Cpu0::CPURegsRegClass;
+
+  return GlobalBaseReg = MF.getRegInfo().createVirtualRegister(RC);
+}
+
+void Cpu0FunctionInfo::anchor() { }
diff -Naur Chapter5_1/Cpu0MachineFunction.h Chapter6_1/Cpu0MachineFunction.h
--- Chapter5_1/Cpu0MachineFunction.h	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0MachineFunction.h	2013-06-24 10:07:14.000000000 +0800
@@ -23,14 +23,26 @@
 /// Cpu0FunctionInfo - This class is derived from MachineFunction private
 /// Cpu0 target-specific information for each MachineFunction.
 class Cpu0FunctionInfo : public MachineFunctionInfo {
+  virtual void anchor();
   MachineFunction& MF;
+
+  /// GlobalBaseReg - keeps track of the virtual register initialized for
+  /// use as the global base register. This is used for PIC in some PIC
+  /// relocation models.
+  unsigned GlobalBaseReg;
+  int GPFI; // Index of the frame object for restoring $gp
   unsigned MaxCallFrameSize;
+  bool EmitNOAT;
 
 public:
   Cpu0FunctionInfo(MachineFunction& MF)
-  : MF(MF), MaxCallFrameSize(0)
+  : MF(MF), GlobalBaseReg(0), MaxCallFrameSize(0), EmitNOAT(false)
   {}
 
+  bool globalBaseRegFixed() const;
+  bool globalBaseRegSet() const;
+  unsigned getGlobalBaseReg();
+
   unsigned getMaxCallFrameSize() const { return MaxCallFrameSize; }
   void setMaxCallFrameSize(unsigned S) { MaxCallFrameSize = S; }
   bool getEmitNOAT() const { return EmitNOAT; }
diff -Naur Chapter5_1/Cpu0MCInstLower.cpp Chapter6_1/Cpu0MCInstLower.cpp
--- Chapter5_1/Cpu0MCInstLower.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0MCInstLower.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -42,6 +42,18 @@
 
   switch(MO.getTargetFlags()) {
   default:                   llvm_unreachable("Invalid target flag!");
+// Cpu0_GPREL is for llc -march=cpu0 -relocation-model=static -cpu0-islinux-
+//  format=false (global var in .sdata).
+  case Cpu0II::MO_GPREL:     Kind = MCSymbolRefExpr::VK_Cpu0_GPREL; break;
+
+  case Cpu0II::MO_GOT16:     Kind = MCSymbolRefExpr::VK_Cpu0_GOT16; break;
+  case Cpu0II::MO_GOT:       Kind = MCSymbolRefExpr::VK_Cpu0_GOT; break;
+// ABS_HI and ABS_LO is for llc -march=cpu0 -relocation-model=static (global 
+//  var in .data).
+  case Cpu0II::MO_ABS_HI:    Kind = MCSymbolRefExpr::VK_Cpu0_ABS_HI; break;
+  case Cpu0II::MO_ABS_LO:    Kind = MCSymbolRefExpr::VK_Cpu0_ABS_LO; break;
+  case Cpu0II::MO_GOT_HI16:  Kind = MCSymbolRefExpr::VK_Cpu0_GOT_HI16; break;
+  case Cpu0II::MO_GOT_LO16:  Kind = MCSymbolRefExpr::VK_Cpu0_GOT_LO16; break;
   }
 
   switch (MOTy) {
@@ -66,6 +78,42 @@
   return MCOperand::CreateExpr(AddExpr);
 }
 
+static void CreateMCInst(MCInst& Inst, unsigned Opc, const MCOperand& Opnd0,
+                         const MCOperand& Opnd1,
+                         const MCOperand& Opnd2 = MCOperand()) {
+  Inst.setOpcode(Opc);
+  Inst.addOperand(Opnd0);
+  Inst.addOperand(Opnd1);
+  if (Opnd2.isValid())
+    Inst.addOperand(Opnd2);
+}
+
+// Lower ".cpload $reg" to
+//  "addiu $gp, $zero, %hi(_gp_disp)"
+//  "shl   $gp, $gp, 16"
+//  "addiu $gp, $gp, %lo(_gp_disp)"
+//  "addu  $gp, $gp, $t9"
+void Cpu0MCInstLower::LowerCPLOAD(SmallVector<MCInst, 4>& MCInsts) {
+  MCOperand GPReg = MCOperand::CreateReg(Cpu0::GP);
+  MCOperand T9Reg = MCOperand::CreateReg(Cpu0::T9);
+  MCOperand ZEROReg = MCOperand::CreateReg(Cpu0::ZERO);
+  StringRef SymName("_gp_disp");
+  const MCSymbol *Sym = Ctx->GetOrCreateSymbol(SymName);
+  const MCSymbolRefExpr *MCSym;
+
+  MCSym = MCSymbolRefExpr::Create(Sym, MCSymbolRefExpr::VK_Cpu0_ABS_HI, *Ctx);
+  MCOperand SymHi = MCOperand::CreateExpr(MCSym);
+  MCSym = MCSymbolRefExpr::Create(Sym, MCSymbolRefExpr::VK_Cpu0_ABS_LO, *Ctx);
+  MCOperand SymLo = MCOperand::CreateExpr(MCSym);
+
+  MCInsts.resize(4);
+
+  CreateMCInst(MCInsts[0], Cpu0::ADDiu, GPReg, ZEROReg, SymHi);
+  CreateMCInst(MCInsts[1], Cpu0::SHL, GPReg, GPReg, MCOperand::CreateImm(16));
+  CreateMCInst(MCInsts[2], Cpu0::ADDiu, GPReg, GPReg, SymLo);
+  CreateMCInst(MCInsts[3], Cpu0::ADD, GPReg, GPReg, T9Reg);
+}
+
 MCOperand Cpu0MCInstLower::LowerOperand(const MachineOperand& MO,
                                         unsigned offset) const {
   MachineOperandType MOTy = MO.getType();
@@ -78,6 +126,8 @@
     return MCOperand::CreateReg(MO.getReg());
   case MachineOperand::MO_Immediate:
     return MCOperand::CreateImm(MO.getImm() + offset);
+  case MachineOperand::MO_GlobalAddress:
+    return LowerSymbolOperand(MO, MOTy, offset);
   case MachineOperand::MO_RegisterMask:
     break;
  }
diff -Naur Chapter5_1/Cpu0MCInstLower.h Chapter6_1/Cpu0MCInstLower.h
--- Chapter5_1/Cpu0MCInstLower.h	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0MCInstLower.h	2013-07-01 10:40:46.377544480 +0800
@@ -33,6 +33,7 @@
   Cpu0MCInstLower(Cpu0AsmPrinter &asmprinter);
   void Initialize(Mangler *mang, MCContext* C);
   void Lower(const MachineInstr *MI, MCInst &OutMI) const;
+  void LowerCPLOAD(SmallVector<MCInst, 4>& MCInsts);
 private:
   MCOperand LowerSymbolOperand(const MachineOperand &MO,
                                MachineOperandType MOTy, unsigned Offset) const;
diff -Naur Chapter5_1/Cpu0RegisterInfo.cpp Chapter6_1/Cpu0RegisterInfo.cpp
--- Chapter5_1/Cpu0RegisterInfo.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0RegisterInfo.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -77,6 +77,11 @@
   for (unsigned I = 0; I < array_lengthof(ReservedCPURegs); ++I)
     Reserved.set(ReservedCPURegs[I]);
 
+  // Reserve GP if small section is used.
+  if (Subtarget.useSmallSection()) {
+    Reserved.set(Cpu0::GP);
+  }
+
   return Reserved;
 }
 
diff -Naur Chapter5_1/Cpu0Subtarget.cpp Chapter6_1/Cpu0Subtarget.cpp
--- Chapter5_1/Cpu0Subtarget.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0Subtarget.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -14,6 +14,7 @@
 #include "Cpu0Subtarget.h"
 #include "Cpu0.h"
 #include "llvm/Support/TargetRegistry.h"
+#include "llvm/Support/CommandLine.h"
 
 #define GET_SUBTARGETINFO_TARGET_DESC
 #define GET_SUBTARGETINFO_CTOR
@@ -21,12 +22,18 @@
 
 using namespace llvm;
 
+static cl::opt<bool>
+UseSmallSectionOpt("cpu0-use-small-section", cl::Hidden, cl::init(false),
+                 cl::desc("Use small section. Only work when -relocation-model="
+                 "static. pic always not use small section."));
+
 void Cpu0Subtarget::anchor() { }
 
 Cpu0Subtarget::Cpu0Subtarget(const std::string &TT, const std::string &CPU,
-                             const std::string &FS, bool little) :
+                             const std::string &FS, bool little, 
+                             Reloc::Model _RM) :
   Cpu0GenSubtargetInfo(TT, CPU, FS),
-  Cpu0ABI(UnknownABI), IsLittle(little)
+  Cpu0ABI(UnknownABI), IsLittle(little), RM(_RM)
 {
   std::string CPUName = CPU;
   if (CPUName.empty())
@@ -41,5 +48,8 @@
   // Set Cpu0ABI if it hasn't been set yet.
   if (Cpu0ABI == UnknownABI)
     Cpu0ABI = O32;
+
+  // Set UseSmallSection.
+  UseSmallSection = UseSmallSectionOpt;
 }
 
diff -Naur Chapter5_1/Cpu0Subtarget.h Chapter6_1/Cpu0Subtarget.h
--- Chapter5_1/Cpu0Subtarget.h	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0Subtarget.h	2013-07-01 10:40:46.377544480 +0800
@@ -47,15 +47,21 @@
   // IsLittle - The target is Little Endian
   bool IsLittle;
 
+  // UseSmallSection - Small section is used.
+  bool UseSmallSection;
+
   InstrItineraryData InstrItins;
 
+  // Relocation Model
+  Reloc::Model RM;
+
 public:
   unsigned getTargetABI() const { return Cpu0ABI; }
 
   /// This constructor initializes the data members to match that
   /// of the specified triple.
   Cpu0Subtarget(const std::string &TT, const std::string &CPU,
-                const std::string &FS, bool little);
+                const std::string &FS, bool little, Reloc::Model _RM);
 
 //- Vitual function, must have
   /// ParseSubtargetFeatures - Parses features string setting specified
@@ -63,6 +69,7 @@
   void ParseSubtargetFeatures(StringRef CPU, StringRef FS);
 
   bool isLittle() const { return IsLittle; }
+  bool useSmallSection() const { return UseSmallSection; }
 };
 } // End llvm namespace
 
diff -Naur Chapter5_1/Cpu0TargetMachine.cpp Chapter6_1/Cpu0TargetMachine.cpp
--- Chapter5_1/Cpu0TargetMachine.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/Cpu0TargetMachine.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -41,7 +41,7 @@
                   bool isLittle)
   //- Default is big endian
   : LLVMTargetMachine(T, TT, CPU, FS, Options, RM, CM, OL),
-    Subtarget(TT, CPU, FS, isLittle),
+    Subtarget(TT, CPU, FS, isLittle, RM),
     DL(isLittle ?
                ("e-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32") :
                ("E-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32")),
diff -Naur Chapter5_1/Cpu0TargetObjectFile.cpp Chapter6_1/Cpu0TargetObjectFile.cpp
--- Chapter5_1/Cpu0TargetObjectFile.cpp	1970-01-01 08:00:00.000000000 +0800
+++ Chapter6_1/Cpu0TargetObjectFile.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -0,0 +1,104 @@
+//===-- Cpu0TargetObjectFile.cpp - Cpu0 Object Files ----------------------===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#include "Cpu0TargetObjectFile.h"
+#include "Cpu0Subtarget.h"
+#include "llvm/IR/DerivedTypes.h"
+#include "llvm/IR/GlobalVariable.h"
+#include "llvm/IR/DataLayout.h"
+#include "llvm/MC/MCContext.h"
+#include "llvm/MC/MCSectionELF.h"
+#include "llvm/Target/TargetMachine.h"
+#include "llvm/Support/CommandLine.h"
+#include "llvm/Support/ELF.h"
+using namespace llvm;
+
+static cl::opt<unsigned>
+SSThreshold("cpu0-ssection-threshold", cl::Hidden,
+            cl::desc("Small data and bss section threshold size (default=8)"),
+            cl::init(8));
+
+void Cpu0TargetObjectFile::Initialize(MCContext &Ctx, const TargetMachine &TM){
+  TargetLoweringObjectFileELF::Initialize(Ctx, TM);
+
+  SmallDataSection =
+    getContext().getELFSection(".sdata", ELF::SHT_PROGBITS,
+                               ELF::SHF_WRITE |ELF::SHF_ALLOC,
+                               SectionKind::getDataRel());
+
+  SmallBSSSection =
+    getContext().getELFSection(".sbss", ELF::SHT_NOBITS,
+                               ELF::SHF_WRITE |ELF::SHF_ALLOC,
+                               SectionKind::getBSS());
+
+}
+
+// A address must be loaded from a small section if its size is less than the
+// small section size threshold. Data in this section must be addressed using
+// gp_rel operator.
+static bool IsInSmallSection(uint64_t Size) {
+  return Size > 0 && Size <= SSThreshold;
+}
+
+bool Cpu0TargetObjectFile::IsGlobalInSmallSection(const GlobalValue *GV,
+                                                const TargetMachine &TM) const {
+  if (GV->isDeclaration() || GV->hasAvailableExternallyLinkage())
+    return false;
+
+  return IsGlobalInSmallSection(GV, TM, getKindForGlobal(GV, TM));
+}
+
+/// IsGlobalInSmallSection - Return true if this global address should be
+/// placed into small data/bss section.
+bool Cpu0TargetObjectFile::
+IsGlobalInSmallSection(const GlobalValue *GV, const TargetMachine &TM,
+                       SectionKind Kind) const {
+
+  // Only use small section for non linux targets.
+  const Cpu0Subtarget &Subtarget = TM.getSubtarget<Cpu0Subtarget>();
+
+  // Return if small section is not available.
+  if (!Subtarget.useSmallSection())
+    return false;
+
+  // Only global variables, not functions.
+  const GlobalVariable *GVA = dyn_cast<GlobalVariable>(GV);
+  if (!GVA)
+    return false;
+
+  // We can only do this for datarel or BSS objects for now.
+  if (!Kind.isBSS() && !Kind.isDataRel())
+    return false;
+
+  // If this is a internal constant string, there is a special
+  // section for it, but not in small data/bss.
+  if (Kind.isMergeable1ByteCString())
+    return false;
+
+  Type *Ty = GV->getType()->getElementType();
+  return IsInSmallSection(TM.getDataLayout()->getTypeAllocSize(Ty));
+}
+
+
+
+const MCSection *Cpu0TargetObjectFile::
+SelectSectionForGlobal(const GlobalValue *GV, SectionKind Kind,
+                       Mangler *Mang, const TargetMachine &TM) const {
+  // TODO: Could also support "weak" symbols as well with ".gnu.linkonce.s.*"
+  // sections?
+
+  // Handle Small Section classification here.
+  if (Kind.isBSS() && IsGlobalInSmallSection(GV, TM, Kind))
+    return SmallBSSSection;
+  if (Kind.isDataNoRel() && IsGlobalInSmallSection(GV, TM, Kind))
+    return SmallDataSection;
+
+  // Otherwise, we work the same as ELF.
+  return TargetLoweringObjectFileELF::SelectSectionForGlobal(GV, Kind, Mang,TM);
+}
diff -Naur Chapter5_1/Cpu0TargetObjectFile.h Chapter6_1/Cpu0TargetObjectFile.h
--- Chapter5_1/Cpu0TargetObjectFile.h	1970-01-01 08:00:00.000000000 +0800
+++ Chapter6_1/Cpu0TargetObjectFile.h	2013-07-01 10:40:46.377544480 +0800
@@ -0,0 +1,41 @@
+//===-- llvm/Target/Cpu0TargetObjectFile.h - Cpu0 Object Info ---*- C++ -*-===//
+//
+//                     The LLVM Compiler Infrastructure
+//
+// This file is distributed under the University of Illinois Open Source
+// License. See LICENSE.TXT for details.
+//
+//===----------------------------------------------------------------------===//
+
+#ifndef LLVM_TARGET_CPU0_TARGETOBJECTFILE_H
+#define LLVM_TARGET_CPU0_TARGETOBJECTFILE_H
+
+#include "llvm/CodeGen/TargetLoweringObjectFileImpl.h"
+
+namespace llvm {
+
+  class Cpu0TargetObjectFile : public TargetLoweringObjectFileELF {
+    const MCSection *SmallDataSection;
+    const MCSection *SmallBSSSection;
+  public:
+
+    void Initialize(MCContext &Ctx, const TargetMachine &TM);
+
+
+    /// IsGlobalInSmallSection - Return true if this global address should be
+    /// placed into small data/bss section.
+    bool IsGlobalInSmallSection(const GlobalValue *GV,
+                                const TargetMachine &TM, SectionKind Kind)const;
+    bool IsGlobalInSmallSection(const GlobalValue *GV,
+                                const TargetMachine &TM) const;
+
+    const MCSection *SelectSectionForGlobal(const GlobalValue *GV,
+                                            SectionKind Kind,
+                                            Mangler *Mang,
+                                            const TargetMachine &TM) const;
+
+    // TODO: Classify globals as cpu0 wishes.
+  };
+} // end namespace llvm
+
+#endif
diff -Naur Chapter5_1/InstPrinter/Cpu0InstPrinter.cpp Chapter6_1/InstPrinter/Cpu0InstPrinter.cpp
--- Chapter5_1/InstPrinter/Cpu0InstPrinter.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/InstPrinter/Cpu0InstPrinter.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -56,6 +56,14 @@
   switch (Kind) {
   default:                                 llvm_unreachable("Invalid kind!");
   case MCSymbolRefExpr::VK_None:           break;
+// Cpu0_GPREL is for llc -march=cpu0 -relocation-model=static
+  case MCSymbolRefExpr::VK_Cpu0_GPREL:     OS << "%gp_rel("; break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT16:     OS << "%got(";    break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT:       OS << "%got(";    break;
+  case MCSymbolRefExpr::VK_Cpu0_ABS_HI:    OS << "%hi(";     break;
+  case MCSymbolRefExpr::VK_Cpu0_ABS_LO:    OS << "%lo(";     break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT_HI16:  OS << "%got_hi("; break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT_LO16:  OS << "%got_lo("; break;
   }
 
   OS << SRE->getSymbol();
diff -Naur Chapter5_1/MCTargetDesc/Cpu0AsmBackend.cpp Chapter6_1/MCTargetDesc/Cpu0AsmBackend.cpp
--- Chapter5_1/MCTargetDesc/Cpu0AsmBackend.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/MCTargetDesc/Cpu0AsmBackend.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -36,6 +36,7 @@
   case FK_GPRel_4:
   case FK_Data_4:
   case Cpu0::fixup_Cpu0_LO16:
+  case Cpu0::fixup_Cpu0_GOT_LO16:
     break;
   case Cpu0::fixup_Cpu0_PC24:
     // So far we are only using this type for branches.
@@ -48,6 +49,7 @@
     break;
   case Cpu0::fixup_Cpu0_HI16:
   case Cpu0::fixup_Cpu0_GOT_Local:
+  case Cpu0::fixup_Cpu0_GOT_HI16:
     // Get the higher 16-bits. Also add 1 if bit 15 is 1.
     Value = ((Value + 0x8000) >> 16) & 0xffff;
     break;
@@ -153,7 +155,9 @@
       { "fixup_Cpu0_TLSLDM",       0,     16,   0 },
       { "fixup_Cpu0_DTPREL_HI",    0,     16,   0 },
       { "fixup_Cpu0_DTPREL_LO",    0,     16,   0 },
-      { "fixup_Cpu0_Branch_PCRel", 0,     16,  MCFixupKindInfo::FKF_IsPCRel }
+      { "fixup_Cpu0_Branch_PCRel", 0,     16,  MCFixupKindInfo::FKF_IsPCRel },
+      { "fixup_Cpu0_GOT_HI16",     0,     16,   0 },
+      { "fixup_Cpu0_GOT_LO16",     0,     16,   0 }
     };
 
     if (Kind < FirstTargetFixupKind)
diff -Naur Chapter5_1/MCTargetDesc/Cpu0BaseInfo.h Chapter6_1/MCTargetDesc/Cpu0BaseInfo.h
--- Chapter5_1/MCTargetDesc/Cpu0BaseInfo.h	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/MCTargetDesc/Cpu0BaseInfo.h	2013-07-01 10:40:46.377544480 +0800
@@ -79,7 +79,11 @@
     MO_GPOFF_LO,
     MO_GOT_DISP,
     MO_GOT_PAGE,
-    MO_GOT_OFST
+    MO_GOT_OFST,
+
+    /// MO_GOT_HI16/LO16 - Relocations used for large GOTs.
+    MO_GOT_HI16,
+    MO_GOT_LO16
   };
 
   enum {
diff -Naur Chapter5_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp Chapter6_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp
--- Chapter5_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -145,6 +145,12 @@
   case Cpu0::fixup_Cpu0_PC24:
     Type = ELF::R_CPU0_PC24;
     break;
+  case Cpu0::fixup_Cpu0_GOT_HI16:
+    Type = ELF::R_CPU0_GOT_HI16;
+    break;
+  case Cpu0::fixup_Cpu0_GOT_LO16:
+    Type = ELF::R_CPU0_GOT_LO16;
+    break;
   }
 
   return Type;
diff -Naur Chapter5_1/MCTargetDesc/Cpu0FixupKinds.h Chapter6_1/MCTargetDesc/Cpu0FixupKinds.h
--- Chapter5_1/MCTargetDesc/Cpu0FixupKinds.h	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/MCTargetDesc/Cpu0FixupKinds.h	2013-07-01 10:40:46.377544480 +0800
@@ -96,6 +96,12 @@
     // PC relative branch fixup resulting in - R_CPU0_PC16
     fixup_Cpu0_Branch_PCRel,
 
+    // resulting in - R_MIPS_GOT_HI16
+    fixup_Cpu0_GOT_HI16,
+
+    // resulting in - R_MIPS_GOT_LO16
+    fixup_Cpu0_GOT_LO16,
+
     // Marker
     LastTargetFixupKind,
     NumTargetFixupKinds = LastTargetFixupKind - FirstTargetFixupKind
diff -Naur Chapter5_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp Chapter6_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp
--- Chapter5_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2013-07-01 10:40:46.377544480 +0800
+++ Chapter6_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp	2013-07-01 10:40:46.377544480 +0800
@@ -157,6 +157,36 @@
 
   assert (Kind == MCExpr::SymbolRef);
 
+  Cpu0::Fixups FixupKind = Cpu0::Fixups(0);
+
+  switch(cast<MCSymbolRefExpr>(Expr)->getKind()) {
+  case MCSymbolRefExpr::VK_Cpu0_GPREL:
+    FixupKind = Cpu0::fixup_Cpu0_GPREL16;
+    break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT16:
+    FixupKind = Cpu0::fixup_Cpu0_GOT_Global;
+    break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT:
+    FixupKind = Cpu0::fixup_Cpu0_GOT_Local;
+    break;
+  case MCSymbolRefExpr::VK_Cpu0_ABS_HI:
+    FixupKind = Cpu0::fixup_Cpu0_HI16;
+    break;
+  case MCSymbolRefExpr::VK_Cpu0_ABS_LO:
+    FixupKind = Cpu0::fixup_Cpu0_LO16;
+    break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT_HI16:
+    FixupKind = Cpu0::fixup_Cpu0_GOT_HI16;
+    break;
+  case MCSymbolRefExpr::VK_Cpu0_GOT_LO16:
+    FixupKind = Cpu0::fixup_Cpu0_GOT_LO16;
+    break;
+  default:
+    break;
+  } // switch
+
+  Fixups.push_back(MCFixup::Create(0, MO.getExpr(), MCFixupKind(FixupKind)));
+
   // All of the information is in the fixup.
   return 0;
 }
