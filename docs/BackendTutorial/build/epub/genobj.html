

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Generating object files</title>
    
    <link rel="stylesheet" href="_static/epub.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" /> 
  </head>
  <body>
    <div class="related">
      <h3>Navigation</h3>
      <ul>
        <li class="right" style="margin-right: 10px">
          <a href="genindex.html" title="General Index"
             accesskey="I">index</a></li>
        <li class="right" >
          <a href="globalvar.html" title="Global variables"
             accesskey="N">next</a> |</li>
        <li class="right" >
          <a href="otherinst.html" title="Arithmetic and logic lsupport"
             accesskey="P">previous</a> |</li>
        <li><a href="index.html">Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</a> &raquo;</li> 
      </ul>
    </div>

    <div class="document">
      <div class="documentwrapper">
          <div class="body">
            
  <div class="section" id="generating-object-files">
<span id="sec-genobjfiles"></span><h1>Generating object files</h1>
<p>The previous chapters only introduce the assembly code generated.
This chapter will introduce you the obj support first, and display the obj by
objdump utility. With LLVM support, the cpu0 backend can generate both big
endian and little endian obj files with only a few code added.
The Target Registration mechanism and their structure will be introduced in
this chapter.</p>
<div class="section" id="translate-into-obj-file">
<h2>Translate into obj file</h2>
<p>Currently, we only support translate llvm IR code into assembly code.
If you try to run Chapter4_2/ to translate obj code will get the error message as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>/usr/local/llvm/test/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>obj ch4_1.bc -o ch4_1.cpu0.o
/usr/local/llvm/test/cmake_debug_build/bin/llc: target does not
support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p>The Chapter5_1/ support obj file generated.
It can get result for big endian and little endian with command
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=cpu0</span></tt> and <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=cpu0el</span></tt>.
Run it will get the obj files as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost InputFiles<span class="o">]</span><span class="nv">$ </span>cat ch4_1.cpu0.s
...
  .set  nomacro
<span class="c"># BB#0:                                 # %entry</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 40
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
...

<span class="o">[</span>Gamma@localhost 3<span class="o">]</span><span class="nv">$ </span>/usr/local/llvm/test/cmake_debug_build/bin/
llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>obj ch4_1.bc -o ch4_1.cpu0.o
<span class="o">[</span>Gamma@localhost InputFiles<span class="o">]</span><span class="nv">$ </span>objdump -s ch4_1.cpu0.o

ch4_1.cpu0.o:     file format elf32-big

Contents of section .text:
 0000 09ddffc8 09200005 022d0034 09200002  ..... ...-.4. ..
 0010 022d0030 0920fffb 022d002c 012d0030  .-.0. ...-.,.-.0
 0020 013d0034 11232000 022d0028 012d0030  .<span class="o">=</span>.4.# ..-.<span class="o">(</span>.-.0
 0030 013d0034 12232000 022d0024 012d0030  .<span class="o">=</span>.4.# ..-.<span class="nv">$.</span>-.0
 0040 013d0034 17232000 022d0020 012d0034  .<span class="o">=</span>.4.# ..-. .-.4
 0050 1e220002 022d001c 012d002c 1e220001  .<span class="s2">&quot;...-...-.,.&quot;</span>..
 0060 022d000c 012d0034 1d220002 022d0018  .-...-.4.<span class="s2">&quot;...-..</span>
<span class="s2"> 0070 012d002c 1f22001e 022d0008 09200001  .-.,.&quot;</span>...-... ..
 0080 013d0034 21323000 023d0014 013d0030  .<span class="o">=</span>.4!20..<span class="o">=</span>...<span class="o">=</span>.0
 0090 21223000 022d0004 09200080 013d0034  !<span class="s2">&quot;0..-... ...=.4</span>
<span class="s2"> 00a0 22223000 022d0010 012d0034 013d0030  &quot;&quot;0..-...-.4.=.0</span>
<span class="s2"> 00b0 20232000 022d0000 09dd0038 3ce00000   # ..-.....8&lt;...</span>

<span class="s2">[Gamma@localhost InputFiles]$ /usr/local/llvm/test/</span>
<span class="s2">cmake_debug_build/bin/llc -march=cpu0el -relocation-model=pic -filetype=obj</span>
<span class="s2">ch4_1.bc -o ch4_1.cpu0el.o</span>
<span class="s2">[Gamma@localhost InputFiles]$ objdump -s ch4_1.cpu0el.o</span>

<span class="s2">ch4_1.cpu0el.o:     file format elf32-little</span>

<span class="s2">Contents of section .text:</span>
<span class="s2"> 0000 c8ffdd09 05002009 34002d02 02002009  ...... .4.-... .</span>
<span class="s2"> 0010 30002d02 fbff2009 2c002d02 30002d01  0.-... .,.-.0.-.</span>
<span class="s2"> 0020 34003d01 00202311 28002d02 30002d01  4.=.. #.(.-.0.-.</span>
<span class="s2"> 0030 34003d01 00202312 24002d02 30002d01  4.=.. #.$.-.0.-.</span>
<span class="s2"> 0040 34003d01 00202317 20002d02 34002d01  4.=.. #. .-.4.-.</span>
<span class="s2"> 0050 0200221e 1c002d02 2c002d01 0100221e  ..&quot;</span>...-.,.-...<span class="s2">&quot;.</span>
<span class="s2"> 0060 0c002d02 34002d01 0200221d 18002d02  ..-.4.-...&quot;</span>...-.
 0070 2c002d01 1e00221f 08002d02 01002009  ,.-...<span class="s2">&quot;...-... .</span>
<span class="s2"> 0080 34003d01 00303221 14003d02 30003d01  4.=..02!..=.0.=.</span>
<span class="s2"> 0090 00302221 04002d02 80002009 34003d01  .0&quot;</span>!..-... .4.<span class="o">=</span>.
 00a0 00302222 10002d02 34002d01 30003d01  .0<span class="s2">&quot;&quot;</span>..-.4.-.0.<span class="o">=</span>.
 00b0 00202320 00002d02 3800dd09 0000e03c  . <span class="c"># ..-.8......&lt;</span>
</pre></div>
</div>
<p>The first instruction is <strong>“addiu  $sp, -56”</strong> and it&#8217;s corresponding obj is
0x09ddffc8.
The addiu opcode is 0x09, 8 bits, $sp register number is 13(0xd), 4bits, and
the immediate is 16 bits -56(=0xffc8), so it&#8217;s correct.
The third instruction <strong>“st  $2, 52($fp)”</strong> and it&#8217;s corresponding obj
is 0x022b0034. The <strong>st</strong> opcode is <strong>0x02</strong>, $2 is 0x2, $fp is 0xb and
immediate is 52(0x0034).
Thanks to cpu0 instruction format which opcode, register operand and
offset(imediate value) size are multiple of 4 bits.
Base on the 4 bits multiple, the obj format is easy to check by eyes.
The big endian (B0, B1, B2, B3) = (09, dd, ff, c8), objdump from B0 to B3 as
0x09ddffc8 and the little endian is (B3, B2, B1, B0) = (09, dd, ff, c8),
objdump from B0 to B3 as 0xc8ffdd09.</p>
</div>
<div class="section" id="backend-target-registration-structure">
<h2>Backend Target Registration Structure</h2>
<p>To support elf obj generated, the following code changed  and added to
Chapter5_1.</p>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_library</span><span class="p">(</span><span class="n">LLVMCpu0Desc</span>
  <span class="n">Cpu0AsmBackend</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="n">Cpu0MCCodeEmitter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="n">Cpu0ELFObjectWriter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0ASMBackend.cpp - Cpu0 Asm Backend  ----------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file implements the Cpu0AsmBackend and Cpu0ELFObjectWriter classes.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>

<span class="cp">#include &quot;Cpu0FixupKinds.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCAsmBackend.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCAssembler.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCDirectives.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCELFObjectWriter.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCFixupKindInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCObjectWriter.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSubtargetInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">// Prepare value for the target space for it</span>
<span class="k">static</span> <span class="kt">unsigned</span> <span class="n">adjustFixupValue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Kind</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Value</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Add/subtract and shift</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">case</span> <span class="nl">FK_GPRel_4:</span>
  <span class="k">case</span> <span class="nl">FK_Data_4:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_LO16:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_PC24:</span>
    <span class="c1">// So far we are only using this type for branches and jump.</span>
    <span class="c1">// For branches we start 1 instruction after the branch</span>
    <span class="c1">// so the displacement will be one instruction size less.</span>
    <span class="n">Value</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_24:</span>
    <span class="c1">// So far we are only using this type for instruction SWI.</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_HI16:</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_GOT_Local:</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// Get the higher 16-bits. Also add 1 if bit 15 is 1.</span>
    <span class="n">Value</span> <span class="o">=</span> <span class="p">((</span><span class="n">Value</span> <span class="o">+</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Value</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0AsmBackend</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCAsmBackend</span> <span class="p">{</span>
  <span class="n">Triple</span><span class="o">::</span><span class="n">OSType</span> <span class="n">OSType</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsLittle</span><span class="p">;</span> <span class="c1">// Big or little endian</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0AsmBackend</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>  <span class="n">Triple</span><span class="o">::</span><span class="n">OSType</span> <span class="n">_OSType</span><span class="p">,</span>
                 <span class="kt">bool</span> <span class="n">_isLittle</span><span class="p">)</span>
    <span class="o">:</span><span class="n">MCAsmBackend</span><span class="p">(),</span> <span class="n">OSType</span><span class="p">(</span><span class="n">_OSType</span><span class="p">),</span> <span class="n">IsLittle</span><span class="p">(</span><span class="n">_isLittle</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">MCObjectWriter</span> <span class="o">*</span><span class="n">createObjectWriter</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Change Reason:</span>
  <span class="c1">// Reduce the exposure of Triple::OSType in the ELF object writer. This will</span>
  <span class="c1">//  avoid including ADT/Triple.h in many places when the target specific bits </span>
  <span class="c1">//  are moved.</span>
    <span class="k">return</span> <span class="n">createCpu0ELFObjectWriter</span><span class="p">(</span><span class="n">OS</span><span class="p">,</span>
      <span class="n">MCELFObjectTargetWriter</span><span class="o">::</span><span class="n">getOSABI</span><span class="p">(</span><span class="n">OSType</span><span class="p">),</span> <span class="n">IsLittle</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// ApplyFixup - Apply the \arg Value for given \arg Fixup into the provided</span>
  <span class="c1">/// data fragment, at the offset specified by the fixup and following the</span>
  <span class="c1">/// fixup kind as appropriate.</span>
  <span class="kt">void</span> <span class="n">applyFixup</span><span class="p">(</span><span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Data</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">DataSize</span><span class="p">,</span>
                  <span class="n">uint64_t</span> <span class="n">Value</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">MCFixupKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Fixup</span><span class="p">.</span><span class="n">getKind</span><span class="p">();</span>
    <span class="n">Value</span> <span class="o">=</span> <span class="n">adjustFixupValue</span><span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">Kind</span><span class="p">,</span> <span class="n">Value</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Value</span><span class="p">)</span>
      <span class="k">return</span><span class="p">;</span> <span class="c1">// Doesn&#39;t change encoding.</span>

    <span class="c1">// Where do we start in the object</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">Fixup</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="c1">// Number of bytes we need to fixup</span>
    <span class="kt">unsigned</span> <span class="n">NumBytes</span> <span class="o">=</span> <span class="p">(</span><span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">Kind</span><span class="p">).</span><span class="n">TargetSize</span> <span class="o">+</span> <span class="mi">7</span><span class="p">)</span> <span class="o">/</span> <span class="mi">8</span><span class="p">;</span>
    <span class="c1">// Used to point to big endian bytes</span>
    <span class="kt">unsigned</span> <span class="n">FullSize</span><span class="p">;</span>

    <span class="k">switch</span> <span class="p">((</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_24:</span>
      <span class="n">FullSize</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">default</span><span class="o">:</span>
      <span class="n">FullSize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Grab current value, if any, from bits.</span>
    <span class="n">uint64_t</span> <span class="n">CurVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">NumBytes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">IsLittle</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="p">(</span><span class="n">FullSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">CurVal</span> <span class="o">|=</span> <span class="p">(</span><span class="n">uint64_t</span><span class="p">)((</span><span class="n">uint8_t</span><span class="p">)</span><span class="n">Data</span><span class="p">[</span><span class="n">Offset</span> <span class="o">+</span> <span class="n">Idx</span><span class="p">])</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="n">uint64_t</span> <span class="n">Mask</span> <span class="o">=</span> <span class="p">((</span><span class="n">uint64_t</span><span class="p">)(</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">Kind</span><span class="p">).</span><span class="n">TargetSize</span><span class="p">));</span>
    <span class="n">CurVal</span> <span class="o">|=</span> <span class="n">Value</span> <span class="o">&amp;</span> <span class="n">Mask</span><span class="p">;</span>

    <span class="c1">// Write out the fixed up bytes back to the code/data bits.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">NumBytes</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Idx</span> <span class="o">=</span> <span class="n">IsLittle</span> <span class="o">?</span> <span class="n">i</span> <span class="o">:</span> <span class="p">(</span><span class="n">FullSize</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">);</span>
      <span class="n">Data</span><span class="p">[</span><span class="n">Offset</span> <span class="o">+</span> <span class="n">Idx</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="n">uint8_t</span><span class="p">)((</span><span class="n">CurVal</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">8</span><span class="p">))</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">getNumFixupKinds</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">NumTargetFixupKinds</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// This table *must* be in same the order of fixup_* kinds in</span>
      <span class="c1">// Cpu0FixupKinds.h.</span>
      <span class="c1">//</span>
      <span class="c1">// name                        offset  bits  flags</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_24&quot;</span><span class="p">,</span>             <span class="mi">0</span><span class="p">,</span>     <span class="mi">24</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_32&quot;</span><span class="p">,</span>             <span class="mi">0</span><span class="p">,</span>     <span class="mi">32</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_HI16&quot;</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_LO16&quot;</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_GPREL16&quot;</span><span class="p">,</span>        <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_GOT_Global&quot;</span><span class="p">,</span>     <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_GOT_Local&quot;</span><span class="p">,</span>      <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_PC24&quot;</span><span class="p">,</span>           <span class="mi">0</span><span class="p">,</span>     <span class="mi">24</span><span class="p">,</span>  <span class="n">MCFixupKindInfo</span><span class="o">::</span><span class="n">FKF_IsPCRel</span> <span class="p">},</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_GOT_HI16&quot;</span><span class="p">,</span>       <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">},</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_GOT_LO16&quot;</span><span class="p">,</span>       <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>   <span class="mi">0</span> <span class="p">}</span>
    <span class="p">};</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">&lt;</span> <span class="n">FirstTargetFixupKind</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">MCAsmBackend</span><span class="o">::</span><span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">Kind</span><span class="p">);</span>

    <span class="n">assert</span><span class="p">(</span><span class="kt">unsigned</span><span class="p">(</span><span class="n">Kind</span> <span class="o">-</span> <span class="n">FirstTargetFixupKind</span><span class="p">)</span> <span class="o">&lt;</span> <span class="n">getNumFixupKinds</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Invalid kind!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Kind</span> <span class="o">-</span> <span class="n">FirstTargetFixupKind</span><span class="p">];</span>
  <span class="p">}</span>

  <span class="c1">/// @name Target Relaxation Interfaces</span>
  <span class="c1">/// @{</span>

  <span class="c1">/// MayNeedRelaxation - Check whether the given instruction may need</span>
  <span class="c1">/// relaxation.</span>
  <span class="c1">///</span>
  <span class="c1">/// \param Inst - The instruction to test.</span>
  <span class="kt">bool</span> <span class="n">mayNeedRelaxation</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// fixupNeedsRelaxation - Target specific predicate for whether a given</span>
  <span class="c1">/// fixup requires the associated instruction to be relaxed.</span>
  <span class="kt">bool</span> <span class="n">fixupNeedsRelaxation</span><span class="p">(</span><span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                            <span class="n">uint64_t</span> <span class="n">Value</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">MCRelaxableFragment</span> <span class="o">*</span><span class="n">DF</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">MCAsmLayout</span> <span class="o">&amp;</span><span class="n">Layout</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// FIXME.</span>
    <span class="n">assert</span><span class="p">(</span><span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;RelaxInstruction() unimplemented&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// RelaxInstruction - Relax the instruction in the given fragment</span>
  <span class="c1">/// to the next wider instruction.</span>
  <span class="c1">///</span>
  <span class="c1">/// \param Inst - The instruction to relax, which may be the same</span>
  <span class="c1">/// as the output.</span>
  <span class="c1">/// \parm Res [output] - On return, the relaxed instruction.</span>
  <span class="kt">void</span> <span class="n">relaxInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Res</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="c1">/// @}</span>

  <span class="c1">/// WriteNopData - Write an (optimal) nop sequence of Count bytes</span>
  <span class="c1">/// to the given output. If the target cannot generate such a sequence,</span>
  <span class="c1">/// it should return an error.</span>
  <span class="c1">///</span>
  <span class="c1">/// \return - True on success.</span>
  <span class="kt">bool</span> <span class="n">writeNopData</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Count</span><span class="p">,</span> <span class="n">MCObjectWriter</span> <span class="o">*</span><span class="n">OW</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">};</span> <span class="c1">// class Cpu0AsmBackend</span>

<span class="p">}</span> <span class="c1">// namespace</span>

<span class="c1">// MCAsmBackend</span>
<span class="n">MCAsmBackend</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0AsmBackendEL32</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                                             <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0AsmBackend</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Triple</span><span class="p">(</span><span class="n">TT</span><span class="p">).</span><span class="n">getOS</span><span class="p">(),</span>
                            <span class="cm">/*IsLittle*/</span><span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MCAsmBackend</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0AsmBackendEB32</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                                             <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0AsmBackend</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">Triple</span><span class="p">(</span><span class="n">TT</span><span class="p">).</span><span class="n">getOS</span><span class="p">(),</span>
                            <span class="cm">/*IsLittle*/</span><span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0FixupKinds.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">/// Target Operand Flag enum.</span>
  <span class="k">enum</span> <span class="n">TOF</span> <span class="p">{</span>
    <span class="c1">//===------------------------------------------------------------------===//</span>
    <span class="c1">// Cpu0 Specific MachineOperand flags.</span>

    <span class="n">MO_NO_FLAG</span><span class="p">,</span>

    <span class="c1">/// MO_GOT16 - Represents the offset into the global offset table at which</span>
    <span class="c1">/// the address the relocation entry symbol resides during execution.</span>
    <span class="n">MO_GOT16</span><span class="p">,</span>
    <span class="n">MO_GOT</span><span class="p">,</span>

    <span class="c1">/// MO_GOT_CALL - Represents the offset into the global offset table at</span>
    <span class="c1">/// which the address of a call site relocation entry symbol resides</span>
    <span class="c1">/// during execution. This is different from the above since this flag</span>
    <span class="c1">/// can only be present in call instructions.</span>
    <span class="n">MO_GOT_CALL</span><span class="p">,</span>

    <span class="c1">/// MO_GPREL - Represents the offset from the current gp value to be used</span>
    <span class="c1">/// for the relocatable object file being produced.</span>
    <span class="n">MO_GPREL</span><span class="p">,</span>

    <span class="c1">/// MO_ABS_HI/LO - Represents the hi or low part of an absolute symbol</span>
    <span class="c1">/// address.</span>
    <span class="n">MO_ABS_HI</span><span class="p">,</span>
    <span class="n">MO_ABS_LO</span><span class="p">,</span>

    <span class="c1">/// MO_TLSGD - Represents the offset into the global offset table at which</span>
    <span class="c1">// the module ID and TSL block offset reside during execution (General</span>
    <span class="c1">// Dynamic TLS).</span>
    <span class="n">MO_TLSGD</span><span class="p">,</span>

    <span class="c1">/// MO_TLSLDM - Represents the offset into the global offset table at which</span>
    <span class="c1">// the module ID and TSL block offset reside during execution (Local</span>
    <span class="c1">// Dynamic TLS).</span>
    <span class="n">MO_TLSLDM</span><span class="p">,</span>
    <span class="n">MO_DTPREL_HI</span><span class="p">,</span>
    <span class="n">MO_DTPREL_LO</span><span class="p">,</span>

    <span class="c1">/// MO_GOTTPREL - Represents the offset from the thread pointer (Initial</span>
    <span class="c1">// Exec TLS).</span>
    <span class="n">MO_GOTTPREL</span><span class="p">,</span>

    <span class="c1">/// MO_TPREL_HI/LO - Represents the hi and low part of the offset from</span>
    <span class="c1">// the thread pointer (Local Exec TLS).</span>
    <span class="n">MO_TPREL_HI</span><span class="p">,</span>
    <span class="n">MO_TPREL_LO</span><span class="p">,</span>

    <span class="c1">// N32/64 Flags.</span>
    <span class="n">MO_GPOFF_HI</span><span class="p">,</span>
    <span class="n">MO_GPOFF_LO</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">MO_GOT_DISP</span><span class="p">,</span>
    <span class="n">MO_GOT_PAGE</span><span class="p">,</span>
    <span class="n">MO_GOT_OFST</span>
  <span class="p">};</span> <span class="c1">// enum TOF {</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kr">inline</span> <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span><span class="o">*</span><span class="p">,</span> <span class="n">int64_t</span><span class="o">&gt;</span>
<span class="n">Cpu0GetSymAndOffset</span><span class="p">(</span><span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCFixupKind</span> <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Fixup</span><span class="p">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">FixupKind</span> <span class="o">&lt;</span> <span class="n">FirstTargetFixupKind</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">FixupKind</span> <span class="o">&gt;=</span> <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LastTargetFixupKind</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">((</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">int64_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">Fixup</span><span class="p">.</span><span class="n">getValue</span><span class="p">();</span>
  <span class="n">MCExpr</span><span class="o">::</span><span class="n">ExprKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCExpr</span><span class="o">::</span><span class="n">Binary</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MCBinaryExpr</span> <span class="o">*</span><span class="n">BE</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCBinaryExpr</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">LHS</span> <span class="o">=</span> <span class="n">BE</span><span class="o">-&gt;</span><span class="n">getLHS</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">CE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BE</span><span class="o">-&gt;</span><span class="n">getRHS</span><span class="p">());</span>

    <span class="k">if</span> <span class="p">((</span><span class="n">LHS</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">()</span> <span class="o">!=</span> <span class="n">MCExpr</span><span class="o">::</span><span class="n">SymbolRef</span><span class="p">)</span> <span class="o">||</span> <span class="o">!</span><span class="n">CE</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">((</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">int64_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">LHS</span><span class="p">),</span> <span class="n">CE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">!=</span> <span class="n">MCExpr</span><span class="o">::</span><span class="n">SymbolRef</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">((</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span><span class="o">*</span><span class="p">)</span><span class="mi">0</span><span class="p">,</span> <span class="p">(</span><span class="n">int64_t</span><span class="p">)</span><span class="mi">0</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">),</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// Cpu0GetSymAndOffset</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0ELFObjectWriter.cpp - Cpu0 ELF Writer -------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0FixupKinds.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCAssembler.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCELFObjectWriter.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSection.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCValue.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &lt;list&gt;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">RelEntry</span> <span class="p">{</span>
    <span class="n">RelEntry</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFRelocationEntry</span> <span class="o">&amp;</span><span class="n">R</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">S</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">O</span><span class="p">)</span> <span class="o">:</span>
      <span class="n">Reloc</span><span class="p">(</span><span class="n">R</span><span class="p">),</span> <span class="n">Sym</span><span class="p">(</span><span class="n">S</span><span class="p">),</span> <span class="n">Offset</span><span class="p">(</span><span class="n">O</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">ELFRelocationEntry</span> <span class="n">Reloc</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Sym</span><span class="p">;</span>
    <span class="n">int64_t</span> <span class="n">Offset</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="k">typedef</span> <span class="n">std</span><span class="o">::</span><span class="n">list</span><span class="o">&lt;</span><span class="n">RelEntry</span><span class="o">&gt;</span> <span class="n">RelLs</span><span class="p">;</span>
  <span class="k">typedef</span> <span class="n">RelLs</span><span class="o">::</span><span class="n">iterator</span> <span class="n">RelLsIter</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0ELFObjectWriter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCELFObjectTargetWriter</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="n">Cpu0ELFObjectWriter</span><span class="p">(</span><span class="n">uint8_t</span> <span class="n">OSABI</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="o">~</span><span class="n">Cpu0ELFObjectWriter</span><span class="p">();</span>

    <span class="k">virtual</span> <span class="kt">unsigned</span> <span class="n">GetRelocType</span><span class="p">(</span><span class="k">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                  <span class="kt">bool</span> <span class="n">IsPCRel</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsRelocWithSymbol</span><span class="p">,</span>
                                  <span class="n">int64_t</span> <span class="n">Addend</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">unsigned</span> <span class="n">getEFlags</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">ExplicitRelSym</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAssembler</span> <span class="o">&amp;</span><span class="n">Asm</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">MCFragment</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="kt">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">sortRelocs</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAssembler</span> <span class="o">&amp;</span><span class="n">Asm</span><span class="p">,</span>
                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ELFRelocationEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Relocs</span><span class="p">);</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">Cpu0ELFObjectWriter</span><span class="p">(</span><span class="n">uint8_t</span> <span class="n">OSABI</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">MCELFObjectTargetWriter</span><span class="p">(</span><span class="cm">/*_is64Bit=false*/</span> <span class="kc">false</span><span class="p">,</span> <span class="n">OSABI</span><span class="p">,</span> <span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="p">,</span>
                            <span class="cm">/*HasRelocationAddend*/</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{}</span>

<span class="n">Cpu0ELFObjectWriter</span><span class="o">::~</span><span class="n">Cpu0ELFObjectWriter</span><span class="p">()</span> <span class="p">{}</span>

<span class="c1">// FIXME: get the real EABI Version from the Subtarget class.</span>
<span class="kt">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">getEFlags</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>

  <span class="c1">// FIXME: We can&#39;t tell if we are PIC (dynamic) or CPIC (static)</span>
  <span class="kt">unsigned</span> <span class="n">Flag</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">EF_CPU0_NOREORDER</span><span class="p">;</span>

  <span class="n">Flag</span> <span class="o">|=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">EF_CPU0_ARCH_32R2</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">Flag</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">ExplicitRelSym</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAssembler</span> <span class="o">&amp;</span><span class="n">Asm</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">MCFragment</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">,</span>
                                                    <span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                                    <span class="kt">bool</span> <span class="n">IsPCRel</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Target</span><span class="p">.</span><span class="n">getSymA</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;SymA cannot be 0.&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">&amp;</span><span class="n">Sym</span> <span class="o">=</span> <span class="n">Target</span><span class="p">.</span><span class="n">getSymA</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">().</span><span class="n">AliasedSymbol</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Sym</span><span class="p">.</span><span class="n">getSection</span><span class="p">().</span><span class="n">getKind</span><span class="p">().</span><span class="n">isMergeableCString</span><span class="p">()</span> <span class="o">||</span>
      <span class="n">Sym</span><span class="p">.</span><span class="n">getSection</span><span class="p">().</span><span class="n">getKind</span><span class="p">().</span><span class="n">isMergeableConst</span><span class="p">())</span>
    <span class="k">return</span> <span class="o">&amp;</span><span class="n">Sym</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">GetRelocType</span><span class="p">(</span><span class="k">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="kt">bool</span> <span class="n">IsPCRel</span><span class="p">,</span>
                                           <span class="kt">bool</span> <span class="n">IsRelocWithSymbol</span><span class="p">,</span>
                                           <span class="n">int64_t</span> <span class="n">Addend</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// determine the type of the relocation</span>
  <span class="kt">unsigned</span> <span class="n">Type</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_NONE</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">Kind</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="n">Fixup</span><span class="p">.</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;invalid fixup kind!&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="nl">FK_Data_4:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_32</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_24:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_24</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_32:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_32</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_HI16:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_HI16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_LO16:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_LO16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_GPREL16:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GPREL16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_GOT_Global:</span>
<span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_GOT_Local:</span>
  <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GOT16</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_PC16:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_PC16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_PC24:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_PC24</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_GOT_HI16:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GOT_HI16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">fixup_Cpu0_GOT_LO16:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GOT_LO16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Type</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Return true if R is either a GOT16 against a local symbol or HI16.</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="n">NeedsMatchingLo</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAssembler</span> <span class="o">&amp;</span><span class="n">Asm</span><span class="p">,</span> <span class="k">const</span> <span class="n">RelEntry</span> <span class="o">&amp;</span><span class="n">R</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">R</span><span class="p">.</span><span class="n">Sym</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">MCSymbolData</span> <span class="o">&amp;</span><span class="n">SD</span> <span class="o">=</span> <span class="n">Asm</span><span class="p">.</span><span class="n">getSymbolData</span><span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">Sym</span><span class="o">-&gt;</span><span class="n">AliasedSymbol</span><span class="p">());</span>

  <span class="k">return</span> <span class="p">((</span><span class="n">R</span><span class="p">.</span><span class="n">Reloc</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GOT16</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SD</span><span class="p">.</span><span class="n">isExternal</span><span class="p">())</span> <span class="o">||</span>
    <span class="p">(</span><span class="n">R</span><span class="p">.</span><span class="n">Reloc</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_HI16</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="n">HasMatchingLo</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAssembler</span> <span class="o">&amp;</span><span class="n">Asm</span><span class="p">,</span> <span class="n">RelLsIter</span> <span class="n">I</span><span class="p">,</span> <span class="n">RelLsIter</span> <span class="n">Last</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">==</span> <span class="n">Last</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">RelLsIter</span> <span class="n">Hi</span> <span class="o">=</span> <span class="n">I</span><span class="o">++</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">Reloc</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_LO16</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Hi</span><span class="o">-&gt;</span><span class="n">Sym</span> <span class="o">==</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">Sym</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="p">(</span><span class="n">Hi</span><span class="o">-&gt;</span><span class="n">Offset</span> <span class="o">==</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">Offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="n">HasSameSymbol</span><span class="p">(</span><span class="k">const</span> <span class="n">RelEntry</span> <span class="o">&amp;</span><span class="n">R0</span><span class="p">,</span> <span class="k">const</span> <span class="n">RelEntry</span> <span class="o">&amp;</span><span class="n">R1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">R0</span><span class="p">.</span><span class="n">Sym</span> <span class="o">==</span> <span class="n">R1</span><span class="p">.</span><span class="n">Sym</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="n">CompareOffset</span><span class="p">(</span><span class="k">const</span> <span class="n">RelEntry</span> <span class="o">&amp;</span><span class="n">R0</span><span class="p">,</span> <span class="k">const</span> <span class="n">RelEntry</span> <span class="o">&amp;</span><span class="n">R1</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">R0</span><span class="p">.</span><span class="n">Offset</span> <span class="o">&gt;</span> <span class="n">R1</span><span class="p">.</span><span class="n">Offset</span><span class="p">)</span> <span class="o">?</span> <span class="mi">1</span> <span class="o">:</span> <span class="p">((</span><span class="n">R0</span><span class="p">.</span><span class="n">Offset</span> <span class="o">==</span> <span class="n">R1</span><span class="p">.</span><span class="n">Offset</span><span class="p">)</span> <span class="o">?</span> <span class="mi">0</span> <span class="o">:</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">sortRelocs</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAssembler</span> <span class="o">&amp;</span><span class="n">Asm</span><span class="p">,</span>
                                     <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ELFRelocationEntry</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Relocs</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Call the defualt function first. Relocations are sorted in descending</span>
  <span class="c1">// order of r_offset.</span>
  <span class="n">MCELFObjectTargetWriter</span><span class="o">::</span><span class="n">sortRelocs</span><span class="p">(</span><span class="n">Asm</span><span class="p">,</span> <span class="n">Relocs</span><span class="p">);</span>
  
  <span class="n">RelLs</span> <span class="n">RelocLs</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RelLsIter</span><span class="o">&gt;</span> <span class="n">Unmatched</span><span class="p">;</span>

  <span class="c1">// Fill RelocLs. Traverse Relocs backwards so that relocations in RelocLs</span>
  <span class="c1">// are in ascending order of r_offset.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">ELFRelocationEntry</span><span class="o">&gt;::</span><span class="n">reverse_iterator</span> <span class="n">R</span> <span class="o">=</span> <span class="n">Relocs</span><span class="p">.</span><span class="n">rbegin</span><span class="p">();</span>
       <span class="n">R</span> <span class="o">!=</span> <span class="n">Relocs</span><span class="p">.</span><span class="n">rend</span><span class="p">();</span> <span class="o">++</span><span class="n">R</span><span class="p">)</span> <span class="p">{</span>
     <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span><span class="o">*</span><span class="p">,</span> <span class="n">int64_t</span><span class="o">&gt;</span> <span class="n">P</span> <span class="o">=</span>
       <span class="n">Cpu0GetSymAndOffset</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">Fixup</span><span class="p">);</span>
     <span class="n">RelocLs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">RelEntry</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="p">,</span> <span class="n">P</span><span class="p">.</span><span class="n">first</span> <span class="o">?</span> <span class="o">&amp;</span><span class="n">P</span><span class="p">.</span><span class="n">first</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">()</span> <span class="o">:</span> <span class="mi">0</span><span class="p">,</span>
                                <span class="n">P</span><span class="p">.</span><span class="n">second</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Get list of unmatched HI16 and GOT16.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">RelLsIter</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">R</span> <span class="o">!=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">R</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">NeedsMatchingLo</span><span class="p">(</span><span class="n">Asm</span><span class="p">,</span> <span class="o">*</span><span class="n">R</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">HasMatchingLo</span><span class="p">(</span><span class="n">Asm</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="o">--</span><span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">()))</span>
      <span class="n">Unmatched</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">R</span><span class="p">);</span>

  <span class="c1">// Insert unmatched HI16 and GOT16 immediately before their matching LO16.</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RelLsIter</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">U</span> <span class="o">=</span> <span class="n">Unmatched</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">U</span> <span class="o">!=</span> <span class="n">Unmatched</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">U</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">RelLsIter</span> <span class="n">LoPos</span> <span class="o">=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">HiPos</span> <span class="o">=</span> <span class="o">*</span><span class="n">U</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">MatchedLo</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">RelLsIter</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">R</span> <span class="o">!=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">R</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">R</span><span class="o">-&gt;</span><span class="n">Reloc</span><span class="p">.</span><span class="n">Type</span> <span class="o">==</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_LO16</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">HasSameSymbol</span><span class="p">(</span><span class="o">*</span><span class="n">HiPos</span><span class="p">,</span> <span class="o">*</span><span class="n">R</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="p">(</span><span class="n">CompareOffset</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="p">,</span> <span class="o">*</span><span class="n">HiPos</span><span class="p">)</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
          <span class="p">((</span><span class="n">LoPos</span> <span class="o">==</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="o">||</span> <span class="p">((</span><span class="n">CompareOffset</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="p">,</span> <span class="o">*</span><span class="n">LoPos</span><span class="p">)</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">))</span> <span class="o">||</span>
           <span class="p">(</span><span class="o">!</span><span class="n">MatchedLo</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">CompareOffset</span><span class="p">(</span><span class="o">*</span><span class="n">R</span><span class="p">,</span> <span class="o">*</span><span class="n">LoPos</span><span class="p">))))</span>
        <span class="n">LoPos</span> <span class="o">=</span> <span class="n">R</span><span class="p">;</span>

      <span class="n">MatchedLo</span> <span class="o">=</span> <span class="n">NeedsMatchingLo</span><span class="p">(</span><span class="n">Asm</span><span class="p">,</span> <span class="o">*</span><span class="n">R</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
        <span class="n">HasMatchingLo</span><span class="p">(</span><span class="n">Asm</span><span class="p">,</span> <span class="n">R</span><span class="p">,</span> <span class="o">--</span><span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
    <span class="p">}</span>

    <span class="c1">// If a matching LoPos was found, move HiPos and insert it before LoPos.</span>
    <span class="c1">// Make the offsets of HiPos and LoPos match.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">LoPos</span> <span class="o">!=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">HiPos</span><span class="o">-&gt;</span><span class="n">Offset</span> <span class="o">=</span> <span class="n">LoPos</span><span class="o">-&gt;</span><span class="n">Offset</span><span class="p">;</span>
      <span class="n">RelocLs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">LoPos</span><span class="p">,</span> <span class="o">*</span><span class="n">HiPos</span><span class="p">);</span>
      <span class="n">RelocLs</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">HiPos</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Put the sorted list back in reverse order.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Relocs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">RelLsIter</span> <span class="n">R</span> <span class="o">=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">R</span> <span class="o">!=</span> <span class="n">RelocLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">R</span><span class="p">)</span>
    <span class="n">Relocs</span><span class="p">[</span><span class="o">--</span><span class="n">I</span><span class="p">]</span> <span class="o">=</span> <span class="n">R</span><span class="o">-&gt;</span><span class="n">Reloc</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MCObjectWriter</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0ELFObjectWriter</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
                                                <span class="n">uint8_t</span> <span class="n">OSABI</span><span class="p">,</span>
                                                <span class="kt">bool</span> <span class="n">IsLittleEndian</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCELFObjectTargetWriter</span> <span class="o">*</span><span class="n">MOTW</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0ELFObjectWriter</span><span class="p">(</span><span class="n">OSABI</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">createELFObjectWriter</span><span class="p">(</span><span class="n">MOTW</span><span class="p">,</span> <span class="n">OS</span><span class="p">,</span> <span class="n">IsLittleEndian</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0FixupKinds.h - Cpu0 Specific Fixup Entries ----------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLVM_CPU0_CPU0FIXUPKINDS_H</span>
<span class="cp">#define LLVM_CPU0_CPU0FIXUPKINDS_H</span>

<span class="cp">#include &quot;llvm/MC/MCFixup.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Cpu0</span> <span class="p">{</span>
  <span class="c1">// Although most of the current fixup types reflect a unique relocation</span>
  <span class="c1">// one can have multiple fixup types for a given relocation and thus need</span>
  <span class="c1">// to be uniquely named.</span>
  <span class="c1">//</span>
  <span class="c1">// This table *must* be in the save order of</span>
  <span class="c1">// MCFixupKindInfo Infos[Cpu0::NumTargetFixupKinds]</span>
  <span class="c1">// in Cpu0AsmBackend.cpp.</span>
  <span class="c1">//</span>
  <span class="k">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
    <span class="c1">// Jump 24 bit fixup resulting in - R_CPU0_24.</span>
    <span class="n">fixup_Cpu0_24</span> <span class="o">=</span> <span class="n">FirstTargetFixupKind</span><span class="p">,</span>

    <span class="c1">// Pure upper 32 bit fixup resulting in - R_CPU0_32.</span>
    <span class="n">fixup_Cpu0_32</span><span class="p">,</span>

    <span class="c1">// Pure upper 16 bit fixup resulting in - R_CPU0_HI16.</span>
    <span class="n">fixup_Cpu0_HI16</span><span class="p">,</span>

    <span class="c1">// Pure lower 16 bit fixup resulting in - R_CPU0_LO16.</span>
    <span class="n">fixup_Cpu0_LO16</span><span class="p">,</span>

    <span class="c1">// Pure lower 16 bit fixup resulting in - R_CPU0_GPREL16.</span>
    <span class="n">fixup_Cpu0_GPREL16</span><span class="p">,</span>

    <span class="c1">// Global symbol fixup resulting in - R_CPU0_GOT16.</span>
    <span class="n">fixup_Cpu0_GOT_Global</span><span class="p">,</span>

    <span class="c1">// Local symbol fixup resulting in - R_CPU0_GOT16.</span>
    <span class="n">fixup_Cpu0_GOT_Local</span><span class="p">,</span>
    
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    
    <span class="c1">// PC relative branch fixup resulting in - R_CPU0_PC24.</span>
    <span class="c1">// cpu0 PC24, e.g. jeq, jmp</span>
    <span class="n">fixup_Cpu0_PC24</span><span class="p">,</span>
    
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="c1">// resulting in - R_CPU0_GOT_HI16</span>
    <span class="n">fixup_Cpu0_GOT_HI16</span><span class="p">,</span>

    <span class="c1">// resulting in - R_CPU0_GOT_LO16</span>
    <span class="n">fixup_Cpu0_GOT_LO16</span><span class="p">,</span>

    <span class="c1">// Marker</span>
    <span class="n">LastTargetFixupKind</span><span class="p">,</span>
    <span class="n">NumTargetFixupKinds</span> <span class="o">=</span> <span class="n">LastTargetFixupKind</span> <span class="o">-</span> <span class="n">FirstTargetFixupKind</span>
  <span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace Cpu0</span>
<span class="p">}</span> <span class="c1">// namespace llvm</span>


<span class="cp">#endif </span><span class="c1">// LLVM_CPU0_CPU0FIXUPKINDS_H</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCCodeEmitter.cpp - Convert Cpu0 Code to Machine Code ---------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file implements the Cpu0MCCodeEmitter class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="cp">#define DEBUG_TYPE &quot;mccodeemitter&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0FixupKinds.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/APFloat.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Statistic.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCCodeEmitter.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCRegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSubtargetInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0MCCodeEmitter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCCodeEmitter</span> <span class="p">{</span>
  <span class="c1">// #define LLVM_DELETED_FUNCTION</span>
  <span class="c1">//  LLVM_DELETED_FUNCTION - Expands to = delete if the compiler supports it. </span>
  <span class="c1">//  Use to mark functions as uncallable. Member functions with this should be </span>
  <span class="c1">//  declared private so that some behavior is kept in C++03 mode.</span>
  <span class="c1">//  class DontCopy { private: DontCopy(const DontCopy&amp;) LLVM_DELETED_FUNCTION;</span>
  <span class="c1">//  DontCopy &amp;operator =(const DontCopy&amp;) LLVM_DELETED_FUNCTION; public: ... };</span>
  <span class="c1">//  Definition at line 79 of file Compiler.h.</span>

  <span class="n">Cpu0MCCodeEmitter</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0MCCodeEmitter</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0MCCodeEmitter</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">;</span>
  <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsLittleEndian</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0MCCodeEmitter</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">mcii</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">sti</span><span class="p">,</span>
                    <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">IsLittle</span><span class="p">)</span> <span class="o">:</span>
            <span class="n">MCII</span><span class="p">(</span><span class="n">mcii</span><span class="p">),</span> <span class="n">STI</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span> <span class="p">,</span> <span class="n">Ctx</span><span class="p">(</span><span class="n">ctx</span><span class="p">),</span> <span class="n">IsLittleEndian</span><span class="p">(</span><span class="n">IsLittle</span><span class="p">)</span> <span class="p">{}</span>

  <span class="o">~</span><span class="n">Cpu0MCCodeEmitter</span><span class="p">()</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">EmitByte</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">C</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">C</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">EmitInstruction</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Val</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="c1">// Output the instruction encoding in little endian byte order.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Size</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Shift</span> <span class="o">=</span> <span class="n">IsLittleEndian</span> <span class="o">?</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">8</span> <span class="o">:</span> <span class="p">(</span><span class="n">Size</span> <span class="o">-</span> <span class="mi">1</span> <span class="o">-</span> <span class="n">i</span><span class="p">)</span> <span class="o">*</span> <span class="mi">8</span><span class="p">;</span>
      <span class="n">EmitByte</span><span class="p">((</span><span class="n">Val</span> <span class="o">&gt;&gt;</span> <span class="n">Shift</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">EncodeInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="c1">// getBinaryCodeForInstr - TableGen&#39;erated function for getting the</span>
  <span class="c1">// binary encoding for an instruction.</span>
  <span class="n">uint64_t</span> <span class="n">getBinaryCodeForInstr</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span>
                                 <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// getMachineOpValue - Return binary encoding of operand. If the machin</span>
  <span class="c1">// operand requires relocation, record the relocation and return zero.</span>
  <span class="kt">unsigned</span> <span class="n">getMachineOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span><span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                             <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">unsigned</span> <span class="n">getMemEncoding</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                          <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span> <span class="c1">// class Cpu0MCCodeEmitter</span>
<span class="p">}</span>  <span class="c1">// namespace</span>

<span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0MCCodeEmitterEB</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">,</span>
                                               <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">(</span><span class="n">MCII</span><span class="p">,</span> <span class="n">STI</span><span class="p">,</span> <span class="n">Ctx</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0MCCodeEmitterEL</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                               <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">,</span>
                                               <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0MCCodeEmitter</span><span class="p">(</span><span class="n">MCII</span><span class="p">,</span> <span class="n">STI</span><span class="p">,</span> <span class="n">Ctx</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// EncodeInstruction - Emit the instruction.</span>
<span class="c1">/// Size the instruction (currently only 4 bytes</span>
<span class="kt">void</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">EncodeInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="n">uint32_t</span> <span class="n">Binary</span> <span class="o">=</span> <span class="n">getBinaryCodeForInstr</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">Fixups</span><span class="p">);</span>

  <span class="c1">// Check for unimplemented opcodes.</span>
  <span class="c1">// Unfortunately in CPU0 both NOT and SLL will come in with Binary == 0</span>
  <span class="c1">// so we have to special check for them.</span>
  <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">Opcode</span> <span class="o">!=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">NOP</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">!=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SHL</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Binary</span><span class="p">)</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unimplemented opcode in EncodeInstruction()&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">MCInstrDesc</span> <span class="o">&amp;</span><span class="n">Desc</span> <span class="o">=</span> <span class="n">MCII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">MI</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">());</span>
  <span class="n">uint64_t</span> <span class="n">TSFlags</span> <span class="o">=</span> <span class="n">Desc</span><span class="p">.</span><span class="n">TSFlags</span><span class="p">;</span>

  <span class="c1">// Pseudo instructions don&#39;t get encoded and shouldn&#39;t be here</span>
  <span class="c1">// in the first place!</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">TSFlags</span> <span class="o">&amp;</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">FormMask</span><span class="p">)</span> <span class="o">==</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">Pseudo</span><span class="p">)</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Pseudo opcode found in EncodeInstruction()&quot;</span><span class="p">);</span>

  <span class="c1">// For now all instructions are 4 bytes</span>
  <span class="kt">int</span> <span class="n">Size</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="c1">// FIXME: Have Desc.getSize() return the correct value!</span>

  <span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Binary</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// getMachineOpValue - Return binary encoding of operand. If the machine</span>
<span class="c1">/// operand requires relocation, record the relocation and return zero.</span>
<span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getMachineOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isReg</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">RegNo</span> <span class="o">=</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">RegNo</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImm</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">());</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isFPImm</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">APFloat</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getFPImm</span><span class="p">())</span>
        <span class="p">.</span><span class="n">bitcastToAPInt</span><span class="p">().</span><span class="n">getHiBits</span><span class="p">(</span><span class="mi">32</span><span class="p">).</span><span class="n">getLimitedValue</span><span class="p">());</span>
  <span class="p">}</span> 

  <span class="c1">// MO must be an Expr.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isExpr</span><span class="p">());</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getExpr</span><span class="p">();</span>
  <span class="n">MCExpr</span><span class="o">::</span><span class="n">ExprKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCExpr</span><span class="o">::</span><span class="n">Binary</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Expr</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCBinaryExpr</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getLHS</span><span class="p">();</span>
    <span class="n">Kind</span> <span class="o">=</span> <span class="n">Expr</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">assert</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCExpr</span><span class="o">::</span><span class="n">SymbolRef</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// All of the information is in the fixup.</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// getMemEncoding - Return binary encoding of memory related operand.</span>
<span class="c1">/// If the offset operand requires relocation, record the relocation.</span>
<span class="kt">unsigned</span>
<span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span><span class="n">getMemEncoding</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Base register is encoded in bits 20-16, offset is encoded in bits 15-0.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNo</span><span class="p">).</span><span class="n">isReg</span><span class="p">());</span>
  <span class="kt">unsigned</span> <span class="n">RegBits</span> <span class="o">=</span> <span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNo</span><span class="p">),</span><span class="n">Fixups</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="mi">16</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">OffBits</span> <span class="o">=</span> <span class="n">getMachineOpValue</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNo</span><span class="o">+</span><span class="mi">1</span><span class="p">),</span> <span class="n">Fixups</span><span class="p">);</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">OffBits</span> <span class="o">&amp;</span> <span class="mh">0xFFFF</span><span class="p">)</span> <span class="o">|</span> <span class="n">RegBits</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;Cpu0GenMCCodeEmitter.inc&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">MCStreamer</span> <span class="o">*</span><span class="n">createMCStreamer</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                                    <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span> <span class="n">MCAsmBackend</span> <span class="o">&amp;</span><span class="n">MAB</span><span class="p">,</span>
                                    <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">_OS</span><span class="p">,</span>
                                    <span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="n">_Emitter</span><span class="p">,</span>
                                    <span class="kt">bool</span> <span class="n">RelaxAll</span><span class="p">,</span>
                                    <span class="kt">bool</span> <span class="n">NoExecStack</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Triple</span> <span class="n">TheTriple</span><span class="p">(</span><span class="n">TT</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">createELFStreamer</span><span class="p">(</span><span class="n">Ctx</span><span class="p">,</span> <span class="n">MAB</span><span class="p">,</span> <span class="n">_OS</span><span class="p">,</span> <span class="n">_Emitter</span><span class="p">,</span> <span class="n">RelaxAll</span><span class="p">,</span> <span class="n">NoExecStack</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - createMCStreamer</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Register the MC Code Emitter</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeEmitter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeEmitterEB</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeEmitter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeEmitterEL</span><span class="p">);</span>

  <span class="c1">// Register the object streamer.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCObjectStreamer</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createMCStreamer</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCObjectStreamer</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createMCStreamer</span><span class="p">);</span>

  <span class="c1">// Register the asm backend.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCAsmBackend</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                       <span class="n">createCpu0AsmBackendEB32</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCAsmBackend</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                       <span class="n">createCpu0AsmBackendEL32</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter5_1/MCTargetDesc/Cpu0MCTargetDesc.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MCRegisterInfo</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="n">createCpu0MCCodeEmitterEB</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">,</span>
                                         <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">);</span>
<span class="n">MCCodeEmitter</span> <span class="o">*</span><span class="n">createCpu0MCCodeEmitterEL</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MCII</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                         <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">,</span>
                                         <span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">);</span>
<span class="c1">// lbd document - mark - createCpu0MCCodeEmitterEL</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCObjectWriter</span> <span class="o">*</span><span class="n">createCpu0ELFObjectWriter</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span>
                                          <span class="n">uint8_t</span> <span class="n">OSABI</span><span class="p">,</span>
                                          <span class="kt">bool</span> <span class="n">IsLittleEndian</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
</pre></div>
</div>
<p>Now, let&#8217;s examine Cpu0MCTargetDesc.cpp.
Cpu0MCTargetDesc.cpp do the target registration as mentioned in
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id2" id="id1">[1]</a> of the last chapter.
Drawing the register function and those class it registered in
Figure  1 to Figure  9 for explanation.</p>
<div class="figure align-center" id="genobj-f1">
<a class="reference internal image-reference" href="_images/14.png"><img alt="_images/14.png" src="_images/14.png" style="width: 731.0px; height: 634.0px;" /></a>
<p class="caption">Figure 1: Register Cpu0MCAsmInfo</p>
</div>
<div class="figure align-center" id="genobj-f2">
<a class="reference internal image-reference" href="_images/23.png"><img alt="_images/23.png" src="_images/23.png" style="width: 685.0px; height: 450.0px;" /></a>
<p class="caption">Figure 2: Register MCCodeGenInfo</p>
</div>
<div class="figure align-center" id="genobj-f3">
<a class="reference internal image-reference" href="_images/32.png"><img alt="_images/32.png" src="_images/32.png" style="width: 606.0px; height: 313.0px;" /></a>
<p class="caption">Figure 3: Register MCInstrInfo</p>
</div>
<div class="figure align-center" id="genobj-f4">
<a class="reference internal image-reference" href="_images/42.png"><img alt="_images/42.png" src="_images/42.png" style="width: 615.0px; height: 678.0px;" /></a>
<p class="caption">Figure 4: Register MCRegisterInfo</p>
</div>
<div class="figure align-center" id="genobj-f5">
<a class="reference internal image-reference" href="_images/52.png"><img alt="_images/52.png" src="_images/52.png" style="width: 750.0px; height: 635.0px;" /></a>
<p class="caption">Figure 5: Register Cpu0MCCodeEmitter</p>
</div>
<div class="figure align-center" id="genobj-f6">
<a class="reference internal image-reference" href="_images/62.png"><img alt="_images/62.png" src="_images/62.png" style="width: 776.0px; height: 617.0px;" /></a>
<p class="caption">Figure 6: Register MCELFStreamer</p>
</div>
<div class="figure align-center" id="genobj-f7">
<a class="reference internal image-reference" href="_images/71.png"><img alt="_images/71.png" src="_images/71.png" style="width: 810.0px; height: 570.0px;" /></a>
<p class="caption">Figure 7: Register Cpu0AsmBackend</p>
</div>
<div class="figure align-center" id="genobj-f8">
<a class="reference internal image-reference" href="_images/81.png"><img alt="_images/81.png" src="_images/81.png" style="width: 621.0px; height: 483.0px;" /></a>
<p class="caption">Figure 8: Register Cpu0MCSubtargetInfo</p>
</div>
<div class="figure align-center" id="genobj-f9">
<a class="reference internal image-reference" href="_images/91.png"><img alt="_images/91.png" src="_images/91.png" style="width: 794.0px; height: 569.0px;" /></a>
<p class="caption">Figure 9: Register Cpu0InstPrinter</p>
</div>
<div class="figure align-center" id="genobj-f10">
<a class="reference internal image-reference" href="_images/101.png"><img alt="_images/101.png" src="_images/101.png" style="width: 783.0px; height: 596.0px;" /></a>
<p class="caption">Figure 10: MCELFStreamer inherit tree</p>
</div>
<p>In Figure  1, registering the object of class Cpu0AsmInfo for
target TheCpu0Target and TheCpu0elTarget.
TheCpu0Target is for big endian and TheCpu0elTarget is for little endian.
Cpu0AsmInfo is derived from MCAsmInfo which is llvm built-in class.
Most code is implemented in it&#8217;s parent, back end reuse those code by inherit.</p>
<p>In Figure  2, instancing MCCodeGenInfo, and initialize it by
pass
Roloc::PIC because we use command <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=pic</span></tt> to tell <tt class="docutils literal"><span class="pre">llc</span></tt>
compile using position-independent code mode.
Recall the addressing mode in system program book has two mode, one is PIC
mode, the other is absolute addressing mode.
MC stands for Machine Code.</p>
<p>In Figure  3, instancing MCInstrInfo object X, and initialize it
by InitCpu0MCInstrInfo(X).
Since InitCpu0MCInstrInfo(X) is defined in Cpu0GenInstrInfo.inc, it will add
the information from Cpu0InstrInfo.td we specified.
Figure  4 is similar to Figure  3, but it
initialize the register information specified in Cpu0RegisterInfo.td.
They share a lot of code with instruction/register td description.</p>
<p>Figure  5, instancing two objects Cpu0MCCodeEmitter, one is for
big endian and the other is for little endian.
They take care the obj format generated.
So, it&#8217;s not defined in Chapter4_2/ which support assembly code only.</p>
<p>Figure  6, MCELFStreamer take care the obj format also.
Figure  5 Cpu0MCCodeEmitter take care code emitter while
MCELFStreamer take care the obj output streamer.
Figure  10 is MCELFStreamer inherit tree.
You can find a lot of operations in that inherit tree.</p>
<p>Reader maybe has the question for what are the actual arguments in
createCpu0MCCodeEmitterEB(const MCInstrInfo &amp;MCII,  const MCSubtargetInfo &amp;STI,
MCContext &amp;Ctx) and at when they are assigned.
Yes, we didn&#8217;t assign it, we register the createXXX() function by function
pointer only (according C, TargetRegistry::RegisterXXX(TheCpu0Target,
createXXX()) where createXXX is function pointer).
LLVM keep a function pointer to createXXX() when we call target registry, and
will call these createXXX() function back at proper time with arguments
assigned during the target registration process, RegisterXXX().</p>
<p>Figure  7, Cpu0AsmBackend class is the bridge for asm to obj.
Two objects take care big endian and little endian also.
It derived from MCAsmBackend.
Most of code for object file generated is implemented by MCELFStreamer and it&#8217;s
parent, MCAsmBackend.</p>
<p>Figure  8, instancing MCSubtargetInfo object and initialize with
Cpu0.td information.
Figure  9, instancing Cpu0InstPrinter to take care printing
function for instructions.
Like Figure  1 to Figure  4, it has been defined
in Chapter4_2/ code for assembly file generated support.</p>
<table class="docutils footnote" frame="void" id="id2" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
</div>
</div>


          </div>
      </div>
      <div class="clearer"></div>
    </div>
    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>