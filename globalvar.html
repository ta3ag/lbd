

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Global variables, structs and arrays, other type &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Control flow statements" href="ctrlflow.html" />
    <link rel="prev" title="Generating object files" href="genobj.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Global variables, structs and arrays, other type</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="genobj.html">Generating object files</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ctrlflow.html">Control flow statements</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="global-variables-structs-and-arrays-other-type">
<span id="sec-globalvars"></span><h1>Global variables, structs and arrays, other type<a class="headerlink" href="#global-variables-structs-and-arrays-other-type" title="Permalink to this headline">¶</a></h1>
<p>In the previous two chapters, we only access the local variables.
This chapter will deal global variable access translation.
After that, introducing the types of struct and array as well as
their corresponding llvm IR statement, and how the cpu0
translate these llvm IR statements in <a class="reference external" href="http://jonathan2251.github.com/lbd/globalvar.html#array-and-struct-support">section Array and struct support</a>.
Finally, we deal the other types such as <strong>&#8220;short int&#8221;</strong> and <strong>char</strong> in the
last section.</p>
<p>The global variable DAG translation is different from the previous DAG
translation we have now.
It create DAG nodes at run time in our backend C++ code according the
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model</span></tt> option while the others of DAG just do IR DAG to
Machine DAG translation directly according the input file IR DAG.</p>
<div class="section" id="global-variable">
<h2>Global variable<a class="headerlink" href="#global-variable" title="Permalink to this headline">¶</a></h2>
<p>Chapter6_1/ support the global variable, let&#8217;s compile ch6_1.cpp with this version
first, and explain the code changes after that.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch6_1.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10</pre></div></td><td class="code"><div class="highlight"><pre><span class="kt">int</span> <span class="n">gStart</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">gI</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>
<span class="kt">int</span> <span class="n">fun</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">c</span> <span class="o">=</span> <span class="n">gI</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>llvm-dis ch6_1.bc -o -
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch6_1.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="s2">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-</span>
<span class="s2">n8:16:32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-apple-macosx10.8.0&quot;</span>

@gStart <span class="o">=</span> global i32 2, align 4
@gI <span class="o">=</span> global i32 100, align 4

define i32 @_Z3funv<span class="o">()</span> nounwind uwtable ssp <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  %c <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  store i32 0, i32* %c, align 4
  %2 <span class="o">=</span> load i32* @gI, align 4
  store i32 %2, i32* %c, align 4
  %3 <span class="o">=</span> load i32* %c, align 4
  ret i32 %3
<span class="o">}</span>
</pre></div>
</div>
<div class="section" id="cpu0-global-variable-options">
<h3>Cpu0 global variable options<a class="headerlink" href="#cpu0-global-variable-options" title="Permalink to this headline">¶</a></h3>
<p>Cpu0 like Mips supports both static and pic mode. There are two different layout
of global variables for static mode which controlled by option cpu0-use-small-section.
Chapter6_1/ support the global variable translation.
Let&#8217;s run Chapter6_1/ with ch6_1.cpp via three different options
<tt class="docutils literal"><span class="pre">llc</span>&nbsp; <span class="pre">-relocation-model=static</span> <span class="pre">-cpu0-use-small-section=false</span></tt>,
<tt class="docutils literal"><span class="pre">llc</span>&nbsp; <span class="pre">-relocation-model=static</span> <span class="pre">-cpu0-use-small-section=true</span></tt> and
<tt class="docutils literal"><span class="pre">llc</span>&nbsp; <span class="pre">-relocation-model=pic</span></tt> to trace the DAG and Cpu0 instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>clang -c ch6_1.cpp -emit-llvm -o ch6_1.bc
118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -cpu0-use-small-section<span class="o">=</span><span class="nb">false</span>
-filetype<span class="o">=</span>asm -debug ch6_1.bc -o -

...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 12 nodes:
  ...
      0x7ffd5902cc10: &lt;multiple use&gt;
    0x7ffd5902cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7ffd5902cd10, 0x7ffd5902ca10, 0x7ffd5902ce10,
    0x7ffd5902cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7ffd5902d010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7ffd5902cc10: &lt;multiple use&gt;
  0x7ffd5902d110: i32,ch <span class="o">=</span> load 0x7ffd5902cf10, 0x7ffd5902d010,
  0x7ffd5902cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 16 nodes:
  ...
      0x7ffd5902cc10: &lt;multiple use&gt;
    0x7ffd5902cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7ffd5902cd10, 0x7ffd5902ca10, 0x7ffd5902ce10,
    0x7ffd5902cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>

        0x7ffd5902d310: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>5<span class="o">]</span>

      0x7ffd5902d710: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Hi 0x7ffd5902d310

        0x7ffd5902d610: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>6<span class="o">]</span>

      0x7ffd5902d810: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Lo 0x7ffd5902d610

    0x7ffd5902fe10: <span class="nv">i32</span> <span class="o">=</span> add 0x7ffd5902d710, 0x7ffd5902d810

    0x7ffd5902cc10: &lt;multiple use&gt;
  0x7ffd5902d110: i32,ch <span class="o">=</span> load 0x7ffd5902cf10, 0x7ffd5902fe10,
  0x7ffd5902cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
  ...

      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>gI<span class="o">)</span>
      shl     <span class="nv">$2</span>, <span class="nv">$2</span>, 16
      addiu   <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>gI<span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
      ...
      .type   gStart,@object          <span class="c"># @gStart</span>
      .data
      .globl  gStart
      .align  2
gStart:
      .4byte  2                       <span class="c"># 0x2</span>
      .size   gStart, 4

      .type   gI,@object              <span class="c"># @gI</span>
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -cpu0-use-small-section<span class="o">=</span><span class="nb">true</span>
-filetype<span class="o">=</span>asm -debug ch6_1.bc -o -

...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 12 nodes:
  ...
      0x7fc5f382cc10: &lt;multiple use&gt;
    0x7fc5f382cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fc5f382cd10, 0x7fc5f382ca10, 0x7fc5f382ce10,
    0x7fc5f382cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fc5f382d010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fc5f382cc10: &lt;multiple use&gt;
  0x7fc5f382d110: i32,ch <span class="o">=</span> load 0x7fc5f382cf10, 0x7fc5f382d010,
  0x7fc5f382cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 15 nodes:
  ...
      0x7fc5f382cc10: &lt;multiple use&gt;
    0x7fc5f382cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fc5f382cd10, 0x7fc5f382ca10, 0x7fc5f382ce10,
    0x7fc5f382cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>

      0x7fc5f382d710: <span class="nv">i32</span> <span class="o">=</span> GLOBAL_OFFSET_TABLE

        0x7fc5f382d310: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>4<span class="o">]</span>

      0x7fc5f382d610: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::GPRel 0x7fc5f382d310

    0x7fc5f382d810: <span class="nv">i32</span> <span class="o">=</span> add 0x7fc5f382d710, 0x7fc5f382d610

    0x7fc5f382cc10: &lt;multiple use&gt;
  0x7fc5f382d110: i32,ch <span class="o">=</span> load 0x7fc5f382cf10, 0x7fc5f382d810,
  0x7fc5f382cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
  ...

      addiu   <span class="nv">$2</span>, <span class="nv">$gp</span>, %gp_rel<span class="o">(</span>gI<span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
      ...
      .type   gStart,@object          <span class="c"># @gStart</span>
      .section        .sdata,<span class="s2">&quot;aw&quot;</span>,@progbits
      .globl  gStart
      .align  2
gStart:
      .4byte  2                       <span class="c"># 0x2</span>
      .size   gStart, 4

      .type   gI,@object              <span class="c"># @gI</span>
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch6_1.bc
-o -

...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 12 nodes:
  ...
      0x7fad7102cc10: &lt;multiple use&gt;
    0x7fad7102cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fad7102cd10, 0x7fad7102ca10, 0x7fad7102ce10,
    0x7fad7102cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fad7102d010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fad7102cc10: &lt;multiple use&gt;
  0x7fad7102d110: i32,ch <span class="o">=</span> load 0x7fad7102cf10, 0x7fad7102d010,
  0x7fad7102cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...
Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 15 nodes:
  0x7ff3c9c10b98: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>
  ...
      0x7fad7102cc10: &lt;multiple use&gt;
    0x7fad7102cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fad7102cd10, 0x7fad7102ca10, 0x7fad7102ce10,
    0x7fad7102cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>

      0x7fad70c10b98: &lt;multiple use&gt;
        0x7fad7102d610: <span class="nv">i32</span> <span class="o">=</span> Register %GP

        0x7fad7102d310: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>1<span class="o">]</span>

      0x7fad7102d710: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Wrapper 0x7fad7102d610, 0x7fad7102d310

      0x7fad7102cc10: &lt;multiple use&gt;
    0x7fad7102d810: i32,ch <span class="o">=</span> load 0x7fad70c10b98, 0x7fad7102d710,
    0x7fad7102cc10&lt;LD4<span class="o">[</span>&lt;unknown&gt;<span class="o">]</span>&gt;

    0x7ff3ca02cc10: &lt;multiple use&gt;
  0x7ff3ca02d110: i32,ch <span class="o">=</span> load 0x7ff3ca02cf10, 0x7ff3ca02d810,
  0x7ff3ca02cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
  ...
        .set  noreorder
        .cpload       <span class="nv">$6</span>
        .set  nomacro
  ...
      ld      <span class="nv">$2</span>, %got<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ...
      .type   gStart,@object          <span class="c"># @gStart</span>
      .data
      .globl  gStart
      .align  2
gStart:
      .4byte  2                       <span class="c"># 0x2</span>
      .size   gStart, 4

      .type   gI,@object              <span class="c"># @gI</span>
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<p>Summary above information to Table: Cpu0 global variable options.</p>
<table border="1" class="docutils">
<caption>Cpu0 global variable options</caption>
<colgroup>
<col width="24%" />
<col width="17%" />
<col width="16%" />
<col width="42%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">option name</th>
<th class="head">default</th>
<th class="head">other option value</th>
<th class="head">discription</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>-relocation-model</td>
<td>pic</td>
<td>static</td>
<td><ul class="first last simple">
<li>pic: Postion Independent Address</li>
<li>static: Absolute Address</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>-cpu0-use-small-section</td>
<td>false</td>
<td>true</td>
<td><ul class="first last simple">
<li>false: .data or .bss, 16 bits addressable</li>
<li>true: .sdata or .sbss, 32 bits addressable</li>
</ul>
</td>
</tr>
</tbody>
</table>
<table border="1" class="docutils">
<caption>Cpu0 DAGs and instructions for -relocation-model=static</caption>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">option: cpu0-use-small-section</th>
<th class="head">false</th>
<th class="head">true</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>addressing mode</td>
<td>absolute</td>
<td>$gp relative</td>
</tr>
<tr class="row-odd"><td>addressing</td>
<td>absolute</td>
<td>$gp+offset</td>
</tr>
<tr class="row-even"><td>Legalized selection DAG</td>
<td>(add Cpu0ISD::Hi&lt;gI offset Hi16&gt; Cpu0ISD::Lo&lt;gI offset Lo16&gt;)</td>
<td>(add GLOBAL_OFFSET_TABLE, Cpu0ISD::GPRel&lt;gI offset&gt;)</td>
</tr>
<tr class="row-odd"><td>Cpu0</td>
<td>addiu $2, $zero, %hi(gI); shl $2, $2, 16; addiu $2, $2, %lo(gI);</td>
<td>addiu   $2, $gp, %gp_rel(gI);</td>
</tr>
<tr class="row-even"><td>relocation records solved</td>
<td>link time</td>
<td>link time</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>In static, cpu0-use-small-section=true, offset between gI and .data can be calculated since the $gp is assigned at fixed address of the start of global address table.</li>
<li>In &#8220;static, cpu0-use-small-section=false&#8221;, the gI high and low address (%hi(gI) and %lo(gI)) are translated into absolute address.</li>
</ul>
<table border="1" class="docutils">
<caption>Cpu0 DAGs and instructions for -relocation-model=pic</caption>
<colgroup>
<col width="33%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">option: cpu0-use-small-section</th>
<th class="head">false</th>
<th class="head">true</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>addressing mode</td>
<td>$gp relative</td>
<td>$gp relative</td>
</tr>
<tr class="row-odd"><td>addressing</td>
<td>$gp+offset</td>
<td>$gp+offset</td>
</tr>
<tr class="row-even"><td>Legalized selection DAG</td>
<td>(load (Cpu0ISD::Wrapper %GP, &lt;gI offset&gt;))</td>
<td>(load EntryToken, (Cpu0ISD::Wrapper (add Cpu0ISD::Hi&lt;gI offset Hi16&gt;, Register %GP), Cpu0ISD::Lo&lt;gI offset Lo16&gt;))</td>
</tr>
<tr class="row-odd"><td>Cpu0</td>
<td>ld $2, %got(gI)($gp);</td>
<td>addiu      $2, $zero, %got_hi(gI); shl $2, $2, 16; add $2, $2, $gp; ld $2, %got_lo(gI)($2);</td>
</tr>
<tr class="row-even"><td>relocation records solved</td>
<td>link/load time</td>
<td>link/load time</td>
</tr>
</tbody>
</table>
<ul class="simple">
<li>In pic, offset between gI and .data cannot be calculated if the function is loaded at run time (dynamic link); the offset can be calculated if use static link.</li>
<li>In C, all variable names binding staticly. In C++, the overload variable or function are binding dynamicly.</li>
</ul>
<p>According book of system program, there are Absolute Addressing Mode and
Position Independent Addressing Mode. The dynamic function must compiled with
Position Independent Addressing Mode. In principle, option -relocation-model is
used to generate Absolute Addressing or Position Independent Addressing.
The exception is -relocation-model=static and -cpu0-use-small-section=false.
In this case, the register $gp is reserved to set at the start address of global
variable area. Cpu0 use $gp relative addressing in this mode.</p>
<p>To support global variable, first add <strong>UseSmallSectionOpt</strong> command variable to
Cpu0Subtarget.cpp.
After that, user can run llc with option <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-cpu0-use-small-section=false</span></tt>
to specify <strong>UseSmallSectionOpt</strong> to false.
The default of <strong>UseSmallSectionOpt</strong> is false if without specify it further.
About the <strong>cl::opt</strong> command line variable, you can refer to <a class="footnote-reference" href="#id7" id="id1">[1]</a> further.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0Subtarget.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0Subtarget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenSubtargetInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// UseSmallSection - Small section is used.</span>
  <span class="kt">bool</span> <span class="n">UseSmallSection</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">useSmallSection</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">UseSmallSection</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0Subtarget.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">UseSmallSectionOpt</span><span class="p">(</span><span class="s">&quot;cpu0-use-small-section&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="kc">false</span><span class="p">),</span>
                 <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Use small section. Only work with -relocation-model=&quot;</span>
                 <span class="s">&quot;static. pic always not use small section.&quot;</span><span class="p">));</span>
</pre></div>
</div>
<p>Next add file Cpu0TargetObjectFile.h, Cpu0TargetObjectFile.cpp and the
following code to Cpu0RegisterInfo.cpp and Cpu0ISelLowering.cpp.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0TargetObjectFile.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- llvm/Target/Cpu0TargetObjectFile.h - Cpu0 Object Info ---*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLVM_TARGET_CPU0_TARGETOBJECTFILE_H</span>
<span class="cp">#define LLVM_TARGET_CPU0_TARGETOBJECTFILE_H</span>

<span class="cp">#include &quot;llvm/CodeGen/TargetLoweringObjectFileImpl.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetObjectFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLoweringObjectFileELF</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MCSection</span> <span class="o">*</span><span class="n">SmallDataSection</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">MCSection</span> <span class="o">*</span><span class="n">SmallBSSSection</span><span class="p">;</span>
  <span class="k">public</span><span class="o">:</span>

    <span class="kt">void</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>


    <span class="c1">/// IsGlobalInSmallSection - Return true if this global address should be</span>
    <span class="c1">/// placed into small data/bss section.</span>
    <span class="kt">bool</span> <span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span> <span class="n">SectionKind</span> <span class="n">Kind</span><span class="p">)</span><span class="k">const</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">const</span> <span class="n">MCSection</span> <span class="o">*</span><span class="n">SelectSectionForGlobal</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">,</span>
                                            <span class="n">SectionKind</span> <span class="n">Kind</span><span class="p">,</span>
                                            <span class="n">Mangler</span> <span class="o">*</span><span class="n">Mang</span><span class="p">,</span>
                                            <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// TODO: Classify globals as cpu0 wishes.</span>
  <span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0TargetObjectFile.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetObjectFile.cpp - Cpu0 Object Files ----------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetObjectFile.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DerivedTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/GlobalVariable.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSectionELF.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ELF.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span>
<span class="n">SSThreshold</span><span class="p">(</span><span class="s">&quot;cpu0-ssection-threshold&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">,</span>
            <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Small data and bss section threshold size (default=8)&quot;</span><span class="p">),</span>
            <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>

<span class="kt">void</span> <span class="n">Cpu0TargetObjectFile</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">){</span>
  <span class="n">TargetLoweringObjectFileELF</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Ctx</span><span class="p">,</span> <span class="n">TM</span><span class="p">);</span>

  <span class="n">SmallDataSection</span> <span class="o">=</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">getELFSection</span><span class="p">(</span><span class="s">&quot;.sdata&quot;</span><span class="p">,</span> <span class="n">ELF</span><span class="o">::</span><span class="n">SHT_PROGBITS</span><span class="p">,</span>
                               <span class="n">ELF</span><span class="o">::</span><span class="n">SHF_WRITE</span> <span class="o">|</span><span class="n">ELF</span><span class="o">::</span><span class="n">SHF_ALLOC</span><span class="p">,</span>
                               <span class="n">SectionKind</span><span class="o">::</span><span class="n">getDataRel</span><span class="p">());</span>

  <span class="n">SmallBSSSection</span> <span class="o">=</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">getELFSection</span><span class="p">(</span><span class="s">&quot;.sbss&quot;</span><span class="p">,</span> <span class="n">ELF</span><span class="o">::</span><span class="n">SHT_NOBITS</span><span class="p">,</span>
                               <span class="n">ELF</span><span class="o">::</span><span class="n">SHF_WRITE</span> <span class="o">|</span><span class="n">ELF</span><span class="o">::</span><span class="n">SHF_ALLOC</span><span class="p">,</span>
                               <span class="n">SectionKind</span><span class="o">::</span><span class="n">getBSS</span><span class="p">());</span>

<span class="p">}</span>

<span class="c1">// A address must be loaded from a small section if its size is less than the</span>
<span class="c1">// small section size threshold. Data in this section must be addressed using</span>
<span class="c1">// gp_rel operator.</span>
<span class="k">static</span> <span class="kt">bool</span> <span class="n">IsInSmallSection</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Size</span> <span class="o">&gt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">Size</span> <span class="o">&lt;=</span> <span class="n">SSThreshold</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0TargetObjectFile</span><span class="o">::</span><span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">,</span>
                                                <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">GV</span><span class="o">-&gt;</span><span class="n">isDeclaration</span><span class="p">()</span> <span class="o">||</span> <span class="n">GV</span><span class="o">-&gt;</span><span class="n">hasAvailableExternallyLinkage</span><span class="p">())</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">TM</span><span class="p">,</span> <span class="n">getKindForGlobal</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">TM</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">/// IsGlobalInSmallSection - Return true if this global address should be</span>
<span class="c1">/// placed into small data/bss section.</span>
<span class="kt">bool</span> <span class="n">Cpu0TargetObjectFile</span><span class="o">::</span>
<span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>
                       <span class="n">SectionKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

  <span class="c1">// Only use small section for non linux targets.</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span> <span class="o">=</span> <span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Return if small section is not available.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Subtarget</span><span class="p">.</span><span class="n">useSmallSection</span><span class="p">())</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="c1">// Only global variables, not functions.</span>
  <span class="k">const</span> <span class="n">GlobalVariable</span> <span class="o">*</span><span class="n">GVA</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalVariable</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GV</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">GVA</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="c1">// We can only do this for datarel or BSS objects for now.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Kind</span><span class="p">.</span><span class="n">isBSS</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Kind</span><span class="p">.</span><span class="n">isDataRel</span><span class="p">())</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="c1">// If this is a internal constant string, there is a special</span>
  <span class="c1">// section for it, but not in small data/bss.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span><span class="p">.</span><span class="n">isMergeable1ByteCString</span><span class="p">())</span>
    <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">Type</span> <span class="o">*</span><span class="n">Ty</span> <span class="o">=</span> <span class="n">GV</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getElementType</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">IsInSmallSection</span><span class="p">(</span><span class="n">TM</span><span class="p">.</span><span class="n">getDataLayout</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getTypeAllocSize</span><span class="p">(</span><span class="n">Ty</span><span class="p">));</span>
<span class="p">}</span>



<span class="k">const</span> <span class="n">MCSection</span> <span class="o">*</span><span class="n">Cpu0TargetObjectFile</span><span class="o">::</span>
<span class="n">SelectSectionForGlobal</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span><span class="p">,</span> <span class="n">SectionKind</span> <span class="n">Kind</span><span class="p">,</span>
                       <span class="n">Mangler</span> <span class="o">*</span><span class="n">Mang</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// TODO: Could also support &quot;weak&quot; symbols as well with &quot;.gnu.linkonce.s.*&quot;</span>
  <span class="c1">// sections?</span>

  <span class="c1">// Handle Small Section classification here.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span><span class="p">.</span><span class="n">isBSS</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">TM</span><span class="p">,</span> <span class="n">Kind</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SmallBSSSection</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span><span class="p">.</span><span class="n">isDataNoRel</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">TM</span><span class="p">,</span> <span class="n">Kind</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">SmallDataSection</span><span class="p">;</span>

  <span class="c1">// Otherwise, we work the same as ELF.</span>
  <span class="k">return</span> <span class="n">TargetLoweringObjectFileELF</span><span class="o">::</span><span class="n">SelectSectionForGlobal</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">Kind</span><span class="p">,</span> <span class="n">Mang</span><span class="p">,</span><span class="n">TM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pure virtual method</span>
<span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Reserve GP if small section is used.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Subtarget</span><span class="p">.</span><span class="n">useSmallSection</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include &quot;Cpu0TargetObjectFile.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="p">...</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getGlobalReg</span><span class="p">(</span><span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">EVT</span> <span class="n">Ty</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">FI</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">FI</span><span class="o">-&gt;</span><span class="n">getGlobalBaseReg</span><span class="p">(),</span> <span class="n">Ty</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">SDValue</span> <span class="n">getTargetNode</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GlobalAddressSDNode</span> <span class="o">*</span><span class="n">N</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalAddressSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">(),</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                      <span class="n">Flag</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExternalSymbolSDNode</span> <span class="o">*</span><span class="n">N</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ExternalSymbolSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetExternalSymbol</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">(),</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Flag</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">BlockAddressSDNode</span> <span class="o">*</span><span class="n">N</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">BlockAddressSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetBlockAddress</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getBlockAddress</span><span class="p">(),</span> <span class="n">Ty</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Flag</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">JumpTableSDNode</span> <span class="o">*</span><span class="n">N</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">JumpTableSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetJumpTable</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Flag</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConstantPoolSDNode</span> <span class="o">*</span><span class="n">N</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantPoolSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetConstantPool</span><span class="p">(</span><span class="n">N</span><span class="o">-&gt;</span><span class="n">getConstVal</span><span class="p">(),</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">N</span><span class="o">-&gt;</span><span class="n">getAlignment</span><span class="p">(),</span>
                                     <span class="n">N</span><span class="o">-&gt;</span><span class="n">getOffset</span><span class="p">(),</span> <span class="n">Flag</span><span class="p">);</span>

  <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unexpected node type.&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getAddrLocal</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">GOTFlag</span> <span class="o">=</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">GOT</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Ty</span><span class="p">),</span>
                            <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">GOTFlag</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">Load</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">Ty</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">GOT</span><span class="p">,</span>
                             <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span>
                             <span class="mi">0</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">LoFlag</span> <span class="o">=</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_LO</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">LoFlag</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Load</span><span class="p">,</span> <span class="n">Lo</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getAddrGlobal</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                          <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Tgt</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Ty</span><span class="p">),</span>
                            <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Flag</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">Ty</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">Tgt</span><span class="p">,</span>
                     <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getAddrGlobalLargeGOT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                                  <span class="kt">unsigned</span> <span class="n">HiFlag</span><span class="p">,</span>
                                                  <span class="kt">unsigned</span> <span class="n">LoFlag</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Hi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Hi</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">HiFlag</span><span class="p">));</span>
  <span class="n">Hi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Hi</span><span class="p">,</span> <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Ty</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">Wrapper</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Hi</span><span class="p">,</span>
                                <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">LoFlag</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">Ty</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">Wrapper</span><span class="p">,</span>
                     <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getTargetNodeName</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Opcode</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">JmpLink:</span>           <span class="k">return</span> <span class="s">&quot;Cpu0ISD::JmpLink&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Hi:</span>                <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Hi&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Lo:</span>                <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Lo&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">GPRel:</span>             <span class="k">return</span> <span class="s">&quot;Cpu0ISD::GPRel&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Ret:</span>               <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Ret&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">DivRem:</span>            <span class="k">return</span> <span class="s">&quot;Cpu0ISD::DivRem&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">DivRemU:</span>           <span class="k">return</span> <span class="s">&quot;Cpu0ISD::DivRemU&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Wrapper:</span>           <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Wrapper&quot;</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span>                         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
   <span class="p">...</span>
  <span class="c1">// Cpu0 Custom Operations</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">GlobalAddress</span><span class="p">,</span>      <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">GlobalAddress:</span>      <span class="k">return</span> <span class="n">LowerGlobalAddress</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//  Lower helper functions</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//  Misc Lower Operation implementation</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerGlobalAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                               <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// FIXME there isn&#39;t actually debug info here</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">GlobalValue</span> <span class="o">*</span><span class="n">GV</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">GlobalAddressSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDVTList</span> <span class="n">VTs</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getVTList</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">);</span>

    <span class="n">Cpu0TargetObjectFile</span> <span class="o">&amp;</span><span class="n">TLOF</span> <span class="o">=</span> <span class="p">(</span><span class="n">Cpu0TargetObjectFile</span><span class="o">&amp;</span><span class="p">)</span><span class="n">getObjFileLowering</span><span class="p">();</span>

    <span class="c1">// %gp_rel relocation</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">TLOF</span><span class="p">.</span><span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">getTargetMachine</span><span class="p">()))</span> <span class="p">{</span>
      <span class="n">SDValue</span> <span class="n">GA</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GPREL</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">GPRelNode</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">GPRel</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VTs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GA</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">GOT</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getGLOBAL_OFFSET_TABLE</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">GOT</span><span class="p">,</span> <span class="n">GPRelNode</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="c1">// %hi/%lo relocation</span>
    <span class="n">SDValue</span> <span class="n">GAHi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_HI</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">GALo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_LO</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">HiPart</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Hi</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VTs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GAHi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">GALo</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">HiPart</span><span class="p">,</span> <span class="n">Lo</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GV</span><span class="o">-&gt;</span><span class="n">hasInternalLinkage</span><span class="p">()</span> <span class="o">||</span> <span class="p">(</span><span class="n">GV</span><span class="o">-&gt;</span><span class="n">hasLocalLinkage</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isa</span><span class="o">&lt;</span><span class="n">Function</span><span class="o">&gt;</span><span class="p">(</span><span class="n">GV</span><span class="p">)))</span>
    <span class="k">return</span> <span class="n">getAddrLocal</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TLOF</span><span class="p">.</span><span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">getTargetMachine</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">getAddrGlobal</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT16</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">getAddrGlobalLargeGOT</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_HI16</span><span class="p">,</span>
                                 <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_LO16</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The setOperationAction(ISD::GlobalAddress, MVT::i32, Custom) tells <tt class="docutils literal"><span class="pre">llc</span></tt> that
we implement global address operation in C++ function
Cpu0TargetLowering::LowerOperation(). LLVM will call this function only when
llvm want to translate IR DAG of loading global variable into machine code.
Since there are many Custom type of setOperationAction(ISD::XXX, MVT::XXX,
Custom) in construction function Cpu0TargetLowering(), and each of them will
trigger llvm calling Cpu0TargetLowering::LowerOperation() in stage
&#8220;Legalized selection DAG&#8221; .
The global address access can be identified by check if the DAG node of
opcode is equal to ISD::GlobalAddress.</p>
<p>Finally, add the following code in Cpu0InstrInfo.td.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Hi and Lo nodes are used to handle global addresses. Used on
// Cpu0ISelLowering to lower stuff like GlobalAddress, ExternalSymbol
// static model. (nothing to do with Cpu0 Registers Hi and Lo)
def Cpu0Hi    : SDNode&lt;"Cpu0ISD::Hi", SDTIntUnaryOp&gt;;
def Cpu0Lo    : SDNode&lt;"Cpu0ISD::Lo", SDTIntUnaryOp&gt;;
def Cpu0GPRel : SDNode&lt;"Cpu0ISD::GPRel", SDTIntUnaryOp&gt;;
...
// hi/lo relocs
def : Pat&lt;(Cpu0Hi tglobaladdr:$in), (SHL (ADDiu ZERO, tglobaladdr:$in), 16)&gt;;
// Expect cpu0 add LUi support, like Mips
//def : Pat&lt;(Cpu0Hi tglobaladdr:$in), (LUi tglobaladdr:$in)&gt;;
def : Pat&lt;(Cpu0Lo tglobaladdr:$in), (ADDiu ZERO, tglobaladdr:$in)&gt;;

def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaladdr:$lo)),
      (ADDiu CPURegs:$hi, tglobaladdr:$lo)&gt;;

// gp_rel relocs
def : Pat&lt;(add CPURegs:$gp, (Cpu0GPRel tglobaladdr:$in)),
      (ADDiu CPURegs:$gp, tglobaladdr:$in)&gt;;</pre>
</div>
</div>
<div class="section" id="static-mode">
<h3>Static mode<a class="headerlink" href="#static-mode" title="Permalink to this headline">¶</a></h3>
<p>From Table: Cpu0 global variable options, option cpu0-use-small-section=false
put the global varibale in data/bss while cpu0-use-small-section=true in
sdata/sbss. The sdata stands for small data area.
Section data and sdata are areas for global variable with initial value (such
as int gI = 100 in this example) while Section bss and sbss are areas for
global variables without initial value (for example, int gI;).</p>
<div class="section" id="data-or-bss">
<h4>data or bss<a class="headerlink" href="#data-or-bss" title="Permalink to this headline">¶</a></h4>
<p>The data/bss are 32 bits addressable areas since Cpu0 is a 32 bits architecture.
Option cpu0-use-small-section=false will generate the following instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>  ...
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>gI<span class="o">)</span>
      shl     <span class="nv">$2</span>, <span class="nv">$2</span>, 16
      addiu   <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>gI<span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
      ...
      .type   gStart,@object          <span class="c"># @gStart</span>
      .data
      .globl  gStart
      .align  2
gStart:
      .4byte  2                       <span class="c"># 0x2</span>
      .size   gStart, 4

      .type   gI,@object              <span class="c"># @gI</span>
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<p>Above code, it loads the high address part of gI PC relative address (16 bits)
to register $2 and shift 16 bits.
Now, the register $2 got it&#8217;s high part of gI absolute address.
Next, it add register $2 and low part of gI absolute address into $2.
At this point, it get the gI memory address. Finally, it get the gI content by
instruction &#8220;ld $2, 0($2)&#8221;.
The <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=static</span></tt> is for absolute address mode which must be
used in static link mode. The dynamic link must be encoded with Position
Independent Addressing.
As you can see, the PC relative address can be solved in static link.
In static, the function fun() is included to the whole execution file, ELF.
The offset between .data and instruction &#8220;addiu $2, $zero, %hi(gI)&#8221; can be
caculated. Since use PC relative address coding, this program can be loaded
to any address and run well there.
If this program use absolute address and will be loaded at a specific address
known at link stage, the relocation record of gI variable access instruction
such as &#8220;addiu $2, $zero, %hi(gI)&#8221; and &#8220;addiu   $2, $2, %lo(gI)&#8221; can be solved
at link time.
If this program use absolute address and the loading address is known at load
time, then this relocation record will be solved by loader at loading time.</p>
<p>IsGlobalInSmallSection() return true or false depends on UseSmallSectionOpt.</p>
<p>The code fragment of LowerGlobalAddress() as the following corresponding option
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=static</span> <span class="pre">-cpu0-use-small-section=true</span></tt> will translate DAG
(GlobalAddress&lt;i32* &#64;gI&gt; 0) into
(add Cpu0ISD::Hi&lt;gI offset Hi16&gt; Cpu0ISD::Lo&lt;gI offset Lo16&gt;) in
stage &#8220;Legalized selection DAG&#8221; as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Cpu0ISelLowering.cpp</span>
<span class="p">...</span>
    <span class="c1">// %hi/%lo relocation</span>
    <span class="n">SDValue</span> <span class="n">GAHi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_HI</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">GALo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_LO</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">HiPart</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Hi</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VTs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GAHi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">GALo</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">HiPart</span><span class="p">,</span> <span class="n">Lo</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>clang -c ch6_1.cpp -emit-llvm -o ch6_1.bc
118-165-78-166:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -cpu0-use-small-section<span class="o">=</span><span class="nb">false</span>
-filetype<span class="o">=</span>asm -debug ch6_1.bc -o -

...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 12 nodes:
  ...
      0x7ffd5902cc10: &lt;multiple use&gt;
    0x7ffd5902cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7ffd5902cd10, 0x7ffd5902ca10, 0x7ffd5902ce10,
    0x7ffd5902cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7ffd5902d010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7ffd5902cc10: &lt;multiple use&gt;
  0x7ffd5902d110: i32,ch <span class="o">=</span> load 0x7ffd5902cf10, 0x7ffd5902d010,
  0x7ffd5902cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 16 nodes:
  ...
      0x7ffd5902cc10: &lt;multiple use&gt;
    0x7ffd5902cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7ffd5902cd10, 0x7ffd5902ca10, 0x7ffd5902ce10,
    0x7ffd5902cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>

        0x7ffd5902d310: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>5<span class="o">]</span>

      0x7ffd5902d710: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Hi 0x7ffd5902d310

        0x7ffd5902d610: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>6<span class="o">]</span>

      0x7ffd5902d810: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Lo 0x7ffd5902d610

    0x7ffd5902fe10: <span class="nv">i32</span> <span class="o">=</span> add 0x7ffd5902d710, 0x7ffd5902d810

    0x7ffd5902cc10: &lt;multiple use&gt;
  0x7ffd5902d110: i32,ch <span class="o">=</span> load 0x7ffd5902cf10, 0x7ffd5902fe10,
  0x7ffd5902cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
</pre></div>
</div>
<p>Finally, the pattern defined in Cpu0InstrInfo.td as the following will translate
DAG (add Cpu0ISD::Hi&lt;gI offset Hi16&gt; Cpu0ISD::Lo&lt;gI offset Lo16&gt;) into Cpu0
instructions as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Hi and Lo nodes are used to handle global addresses. Used on
// Cpu0ISelLowering to lower stuff like GlobalAddress, ExternalSymbol
// static model. (nothing to do with Cpu0 Registers Hi and Lo)
def Cpu0Hi    : SDNode&lt;"Cpu0ISD::Hi", SDTIntUnaryOp&gt;;
def Cpu0Lo    : SDNode&lt;"Cpu0ISD::Lo", SDTIntUnaryOp&gt;;
...
// hi/lo relocs
def : Pat&lt;(Cpu0Hi tglobaladdr:$in), (SHL (ADDiu ZERO, tglobaladdr:$in), 16)&gt;;
// Expect cpu0 add LUi support, like Mips
//def : Pat&lt;(Cpu0Hi tglobaladdr:$in), (LUi tglobaladdr:$in)&gt;;
def : Pat&lt;(Cpu0Lo tglobaladdr:$in), (ADDiu ZERO, tglobaladdr:$in)&gt;;

def : Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaladdr:$lo)),
      (ADDiu CPURegs:$hi, tglobaladdr:$lo)&gt;;</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>...
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>gI<span class="o">)</span>
    shl     <span class="nv">$2</span>, <span class="nv">$2</span>, 16
    addiu   <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>gI<span class="o">)</span>
    ...
</pre></div>
</div>
<p>As above, Pat&lt;(...),(...)&gt; include two lists of DAGs.
The left is IR DAG and the right is machine instruction DAG.
Pat&lt;(Cpu0Hi tglobaladdr:$in), (SHL (ADDiu ZERO, tglobaladdr:$in), 16)&gt;; will
translate DAG (Cpu0ISD::Hi tglobaladdr) into (shl (addiu ZERO, tglobaladdr), 16).
Pat&lt;(Cpu0Lo tglobaladdr:$in), (ADDiu ZERO, tglobaladdr:$in)&gt;; will translate
(Cpu0ISD::Hi tglobaladdr) into (addiu ZERO, tglobaladdr).
Pat&lt;(add CPURegs:$hi, (Cpu0Lo tglobaladdr:$lo)), (ADDiu CPURegs:$hi, tglobaladdr:$lo)&gt;;
will translate DAG (add Cpu0ISD::Hi, Cpu0ISD::Lo) into Cpu0 instruction
(add Cpu0ISD::Hi, Cpu0ISD::Lo).</p>
</div>
<div class="section" id="sdata-or-sbss">
<h4>sdata or sbss<a class="headerlink" href="#sdata-or-sbss" title="Permalink to this headline">¶</a></h4>
<p>The sdata/sbss are 16 bits addressable areas which planed in ELF for fast access.
Option cpu0-use-small-section=true will generate the following instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>      addiu   <span class="nv">$2</span>, <span class="nv">$gp</span>, %gp_rel<span class="o">(</span>gI<span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
      ...
      .type   gStart,@object          <span class="c"># @gStart</span>
      .section        .sdata,<span class="s2">&quot;aw&quot;</span>,@progbits
      .globl  gStart
      .align  2
gStart:
      .4byte  2                       <span class="c"># 0x2</span>
      .size   gStart, 4

      .type   gI,@object              <span class="c"># @gI</span>
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<p>The code fragment of LowerGlobalAddress() as the following corresponding option
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=static</span> <span class="pre">-cpu0-use-small-section=true</span></tt> will translate DAG
(GlobalAddress&lt;i32* &#64;gI&gt; 0) into
(add GLOBAL_OFFSET_TABLE Cpu0ISD::GPRel&lt;gI offset&gt;) in
stage &#8220;Legalized selection DAG&#8221; as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Cpu0ISelLowering.cpp</span>
  <span class="p">...</span>
  <span class="c1">// %gp_rel relocation</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TLOF</span><span class="p">.</span><span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">getTargetMachine</span><span class="p">()))</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">GA</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                            <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GPREL</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">GPRelNode</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">GPRel</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VTs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GA</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">GOT</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getGLOBAL_OFFSET_TABLE</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">GOT</span><span class="p">,</span> <span class="n">GPRelNode</span><span class="p">);</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 12 nodes:
  ...
      0x7fc5f382cc10: &lt;multiple use&gt;
    0x7fc5f382cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fc5f382cd10, 0x7fc5f382ca10, 0x7fc5f382ce10,
    0x7fc5f382cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fc5f382d010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fc5f382cc10: &lt;multiple use&gt;
  0x7fc5f382d110: i32,ch <span class="o">=</span> load 0x7fc5f382cf10, 0x7fc5f382d010,
  0x7fc5f382cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 15 nodes:
  ...
      0x7fc5f382cc10: &lt;multiple use&gt;
    0x7fc5f382cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fc5f382cd10, 0x7fc5f382ca10, 0x7fc5f382ce10,
    0x7fc5f382cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>

      0x7fc5f382d710: <span class="nv">i32</span> <span class="o">=</span> GLOBAL_OFFSET_TABLE

        0x7fc5f382d310: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>4<span class="o">]</span>

      0x7fc5f382d610: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::GPRel 0x7fc5f382d310

    0x7fc5f382d810: <span class="nv">i32</span> <span class="o">=</span> add 0x7fc5f382d710, 0x7fc5f382d610

    0x7fc5f382cc10: &lt;multiple use&gt;
  0x7fc5f382d110: i32,ch <span class="o">=</span> load 0x7fc5f382cf10, 0x7fc5f382d810,
  0x7fc5f382cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
  ...
</pre></div>
</div>
<p>Finally, the pattern defined in Cpu0InstrInfo.td as the following will translate
DAG (add GLOBAL_OFFSET_TABLE Cpu0ISD::GPRel&lt;gI offset&gt;) into Cpu0
instruction as below. The following code in Cpu0ISelDAGToDAG.cpp make the
GLOBAL_OFFSET_TABLE translate into $gp as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// getGlobalBaseReg - Output the instructions required to put the</span>
<span class="c1">/// GOT address into a register.</span>
<span class="n">SDNode</span> <span class="o">*</span><span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">getGlobalBaseReg</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">GlobalBaseReg</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getGlobalBaseReg</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getRegister</span><span class="p">(</span><span class="n">GlobalBaseReg</span><span class="p">,</span> <span class="n">TLI</span><span class="p">.</span><span class="n">getPointerTy</span><span class="p">()).</span><span class="n">getNode</span><span class="p">();</span>
<span class="p">}</span>

<span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Get target GOT address.</span>
  <span class="c1">// For global variables as follows,</span>
  <span class="c1">//- @gI = global i32 100, align 4</span>
  <span class="c1">//- %2 = load i32* @gI, align 4</span>
  <span class="c1">// =&gt;</span>
  <span class="c1">//- .cpload $gp</span>
  <span class="c1">//- ld      $2, %got(gI)($gp)</span>
  <span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">GLOBAL_OFFSET_TABLE:</span>
    <span class="k">return</span> <span class="n">getGlobalBaseReg</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>//  Cpu0InstrInfo.td
def Cpu0GPRel : SDNode&lt;"Cpu0ISD::GPRel", SDTIntUnaryOp&gt;;
...
// gp_rel relocs
def : Pat&lt;(add CPURegs:$gp, (Cpu0GPRel tglobaladdr:$in)),
          (ADD CPURegs:$gp, (ADDiu ZERO, tglobaladdr:$in))&gt;;</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>addiu   <span class="nv">$2</span>, <span class="nv">$gp</span>, %gp_rel<span class="o">(</span>gI<span class="o">)</span>
...
</pre></div>
</div>
<p>Pat&lt;(add CPURegs:$gp, (Cpu0GPRel tglobaladdr:$in)), (ADD CPURegs:$gp, (ADDiu
ZERO, tglobaladdr:$in))&gt;; will translate (add $gp Cpu0ISD::GPRel tglobaladdr)
into (add $gp, (addiu ZERO, tglobaladdr)).</p>
<p>In this mode, the $gp content is assigned at compile/link time, changed only at
program be loaded, and is fixed during the program running; while the
-relocation-model=pic the $gp can be changed during program running.
For this example, if $gp is assigned to the start address of .sdata by loader
when program ch6_1.cpu0.s is loaded, then linker can caculate %gp_rel(gI) =
(the relative address distance between gI and start of .sdata section.
Which meaning this relocation record can be solved at link time, that&#8217;s why it
is static mode.</p>
<p>In this mode, we reserve $gp to a specfic fixed address of both linker and
loader agree to. So, the $gp cannot be allocated as a general purpose for
variables. The following code tells llvm never allocate $gp for variables.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0Subtarget.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">CPU</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">little</span><span class="p">,</span>
                             <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">_RM</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">Cpu0GenSubtargetInfo</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span>
  <span class="n">Cpu0ABI</span><span class="p">(</span><span class="n">UnknownABI</span><span class="p">),</span> <span class="n">IsLittle</span><span class="p">(</span><span class="n">little</span><span class="p">),</span> <span class="n">RM</span><span class="p">(</span><span class="n">_RM</span><span class="p">)</span>
<span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Set UseSmallSection.</span>
  <span class="n">UseSmallSection</span> <span class="o">=</span> <span class="n">UseSmallSectionOpt</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RM</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Static</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">UseSmallSection</span><span class="p">)</span>
    <span class="n">FixGlobalBaseReg</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">FixGlobalBaseReg</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pure virtual method</span>
<span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">const</span> <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="c1">// Reserve GP if globalBaseRegFixed()</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">())</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="pic-mode">
<h3>pic mode<a class="headerlink" href="#pic-mode" title="Permalink to this headline">¶</a></h3>
<div class="section" id="id2">
<h4>sdata or sbss<a class="headerlink" href="#id2" title="Permalink to this headline">¶</a></h4>
<p>Option <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=pic</span> <span class="pre">-cpu0-use-small-section=true</span></tt> will
generate the following instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>  ...
        .set  noreorder
        .cpload       <span class="nv">$6</span>
        .set  nomacro
  ...
      ld      <span class="nv">$2</span>, %got<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ...
      .type   gStart,@object          <span class="c"># @gStart</span>
      .data
      .globl  gStart
      .align  2
gStart:
      .4byte  2                       <span class="c"># 0x2</span>
      .size   gStart, 4

      .type   gI,@object              <span class="c"># @gI</span>
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<p>The following code fragment of Cpu0AsmPrinter.cpp will emit <strong>.cpload</strong> asm
pseudo instruction at function entry point as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MachineFunction.h - Private data used for Cpu0 ----*- C++ -*-=//</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
  <span class="p">...</span>

  <span class="c1">/// GlobalBaseReg - keeps track of the virtual register initialized for</span>
  <span class="c1">/// use as the global base register. This is used for PIC in some PIC</span>
  <span class="c1">/// relocation models.</span>
  <span class="kt">unsigned</span> <span class="n">GlobalBaseReg</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">GPFI</span><span class="p">;</span> <span class="c1">// Index of the frame object for restoring $gp</span>
  <span class="p">...</span>

  <span class="k">public</span><span class="o">:</span>  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="p">...,</span> <span class="n">GlobalBaseReg</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="p">...</span>
  <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">globalBaseRegFixed</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">globalBaseRegSet</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">getGlobalBaseReg</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end of namespace llvm</span>

<span class="cp">#endif </span><span class="c1">// CPU0_MACHINE_FUNCTION_INFO_H</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0MachineFunction.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MachineFunctionInfo.cpp - Private data used for Cpu0 ----------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineRegisterInfo.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">FixGlobalBaseReg</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">Cpu0FunctionInfo</span><span class="o">::</span><span class="n">globalBaseRegFixed</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">FixGlobalBaseReg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0FunctionInfo</span><span class="o">::</span><span class="n">globalBaseRegSet</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">GlobalBaseReg</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">Cpu0FunctionInfo</span><span class="o">::</span><span class="n">getGlobalBaseReg</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Return if it has already been initialized.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">GlobalBaseReg</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">GlobalBaseReg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">FixGlobalBaseReg</span><span class="p">)</span> <span class="c1">// $gp is the global base register.</span>
    <span class="k">return</span> <span class="n">GlobalBaseReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">;</span>
  <span class="n">RC</span> <span class="o">=</span> <span class="p">(</span><span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">GlobalBaseReg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">RC</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FunctionInfo</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// EmitFunctionBodyStart - Targets can override this to emit stuff before</span>
<span class="c1">/// the first basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">EmitCPLoad</span> <span class="o">=</span> <span class="p">(</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegSet</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noreorder&quot;</span><span class="p">));</span>
    <span class="c1">// Emit .cpload directive if needed.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">EmitCPLoad</span><span class="p">)</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.cpload</span><span class="se">\t</span><span class="s">$6&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">nomacro&quot;</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noat&quot;</span><span class="p">));</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">EmitCPLoad</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MCInsts</span><span class="p">;</span>
    <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">LowerCPLOAD</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">);</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MCInsts</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
       <span class="n">I</span> <span class="o">!=</span> <span class="n">MCInsts</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="o">*</span><span class="n">I</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>...
      .set  noreorder
      .cpload       <span class="nv">$6</span>
      .set  nomacro
...
</pre></div>
</div>
<p>The <strong>.cpload</strong> is the assembly directive (macro) which
will expand to several instructions.
Issue <strong>.cpload</strong> before <strong>.set nomacro</strong> since the <strong>.set nomacro</strong> option
causes the assembler to print a warning whenever
an assembler operation generates more than one machine language instruction,
reference Mips ABI <a class="footnote-reference" href="#id8" id="id3">[2]</a>.</p>
<p>Following code will exspand .cpload into machine instructions as below.
&#8220;09a00000 1eaa0010 09aa0000 13aa6000&#8221; is the <strong>.cpload</strong> machine instructions
displayed in comments of Cpu0MCInstLower.cpp.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInst</span><span class="o">&amp;</span> <span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCOperand</span><span class="o">&amp;</span> <span class="n">Opnd0</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MCOperand</span><span class="o">&amp;</span> <span class="n">Opnd1</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">MCOperand</span><span class="o">&amp;</span> <span class="n">Opnd2</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="p">())</span> <span class="p">{</span>
  <span class="n">Inst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Opc</span><span class="p">);</span>
  <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">Opnd0</span><span class="p">);</span>
  <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">Opnd1</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Opnd2</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
    <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">Opnd2</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// Lower &quot;.cpload $reg&quot; to</span>
<span class="c1">//  &quot;addiu $gp, $zero, %hi(_gp_disp)&quot;</span>
<span class="c1">//  &quot;shl   $gp, $gp, 16&quot;</span>
<span class="c1">//  &quot;addiu $gp, $gp, %lo(_gp_disp)&quot;</span>
<span class="c1">//  &quot;addu  $gp, $gp, $t9&quot;</span>
<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerCPLOAD</span><span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCOperand</span> <span class="n">GPReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="n">MCOperand</span> <span class="n">T9Reg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">);</span>
  <span class="n">MCOperand</span> <span class="n">ZEROReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="n">StringRef</span> <span class="n">SymName</span><span class="p">(</span><span class="s">&quot;_gp_disp&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Sym</span> <span class="o">=</span> <span class="n">Ctx</span><span class="o">-&gt;</span><span class="n">GetOrCreateSymbol</span><span class="p">(</span><span class="n">SymName</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">MCSym</span><span class="p">;</span>

  <span class="n">MCSym</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Sym</span><span class="p">,</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_HI</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="n">MCOperand</span> <span class="n">SymHi</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">MCSym</span><span class="p">);</span>
  <span class="n">MCSym</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Sym</span><span class="p">,</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_LO</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="n">MCOperand</span> <span class="n">SymLo</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">MCSym</span><span class="p">);</span>

  <span class="n">MCInsts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">4</span><span class="p">);</span>

  <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">ZEROReg</span><span class="p">,</span> <span class="n">SymHi</span><span class="p">);</span>
  <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SHL</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="mi">16</span><span class="p">));</span>
  <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">2</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">SymLo</span><span class="p">);</span>
  <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">3</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">T9Reg</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>
obj ch8_2.bc -o ch8_2.cpu0.o
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>gobjdump -s ch6_1.cpu0.o

ch6_1.cpu0.o:     file format elf32-big

Contents of section .text:
 0000 09a00000 1eaa0010 09aa0000 13aa6000  ..............<span class="sb">`</span>.
 0010 09ddfff8 09200000 022d0004 022d0000  ..... ...-...-..
...

118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>gobjdump -tr ch6_1.cpu0.o
...
RELOCATION RECORDS FOR <span class="o">[</span>.text<span class="o">]</span>:
OFFSET   TYPE              VALUE
00000000 UNKNOWN           _gp_disp
00000008 UNKNOWN           _gp_disp
00000020 UNKNOWN           gI
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>// <strong>Mips ABI: _gp_disp</strong>
After calculating the gp, a function allocates the local stack space and saves
the gp on the stack, so it can be restored after subsequent function calls.
In other words, the gp is a caller saved register.</p>
<p>...</p>
<p class="last">_gp_disp represents the offset between the beginning of the function and the
global offset table.
Various optimizations are possible in this code example and the others that
follow.
For example, the calculation of gp need not be done for a position-independent
function that is strictly local to an object module.</p>
</div>
<p>The _gp_disp as above is a relocation record, it means both the machine
instructions 09a00000 (offset 0) which equal to assembly
&#8220;addiu $gp, $zero, %hi(_gp_disp)&#8221; and 09aa0000 (offset 8) which equal to
assembly &#8220;addiu $gp, $gp, %lo(_gp_disp)&#8221; are relocated records depend on
_gp_disp. The loader or OS can caculate _gp_disp by (x - start address of .data)
when load the dynamic function into memory x, and adust these two
instructions offet correctly.
Since shared function is loaded when this function be called, the relocation
record &#8220;ld $2, %got(gI)($gp)&#8221; cannot be resolved in link time.
In spite of the reloation record is solved on load time, the name binding
is static since linker deliver the memory address to loader and loader can solve
this just by caculate the offset directly. No need to search the variable name
at run time.
The ELF relocation records will be introduced in Chapter ELF Support.
Don&#8217;t worry, if you don&#8217;t quite understand it at this point.</p>
<p>The code fragment of LowerGlobalAddress() as the following corresponding option
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=pic</span></tt> will translate DAG (GlobalAddress&lt;i32* &#64;gI&gt; 0) into
(load EntryToken, (Cpu0ISD::Wrapper Register %GP, TargetGlobalAddress&lt;i32* &#64;gI&gt; 0))
in stage &#8220;Legalized selection DAG&#8221; as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getAddrGlobal</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                          <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Tgt</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Ty</span><span class="p">),</span>
                            <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Flag</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">Ty</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">Tgt</span><span class="p">,</span>
                     <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerGlobalAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                               <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TLOF</span><span class="p">.</span><span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">getTargetMachine</span><span class="p">()))</span>
    <span class="k">return</span> <span class="n">getAddrGlobal</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT16</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// ComplexPattern used on Cpu0InstrInfo</span>
<span class="c1">/// Used on Cpu0 Load/Store instructions</span>
<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span>
<span class="n">SelectAddr</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Parent</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Base</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Offset</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// on PIC code Load GA</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Addr</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Base</span>   <span class="o">=</span> <span class="n">Addr</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 12 nodes:
  ...
      0x7fad7102cc10: &lt;multiple use&gt;
    0x7fad7102cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fad7102cd10, 0x7fad7102ca10, 0x7fad7102ce10,
    0x7fad7102cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fad7102d010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fad7102cc10: &lt;multiple use&gt;
  0x7fad7102d110: i32,ch <span class="o">=</span> load 0x7fad7102cf10, 0x7fad7102d010,
  0x7fad7102cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...
Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:entry&#39;</span>
SelectionDAG has 15 nodes:
  0x7ff3c9c10b98: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>
  ...
      0x7fad7102cc10: &lt;multiple use&gt;
    0x7fad7102cf10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fad7102cd10, 0x7fad7102ca10, 0x7fad7102ce10,
    0x7fad7102cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>

      0x7fad70c10b98: &lt;multiple use&gt;
        0x7fad7102d610: <span class="nv">i32</span> <span class="o">=</span> Register %GP

        0x7fad7102d310: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>1<span class="o">]</span>

      0x7fad7102d710: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Wrapper 0x7fad7102d610, 0x7fad7102d310

      0x7fad7102cc10: &lt;multiple use&gt;
    0x7fad7102d810: i32,ch <span class="o">=</span> load 0x7fad70c10b98, 0x7fad7102d710,
    0x7fad7102cc10&lt;LD4<span class="o">[</span>&lt;unknown&gt;<span class="o">]</span>&gt;
    0x7ff3ca02cc10: &lt;multiple use&gt;
  0x7ff3ca02d110: i32,ch <span class="o">=</span> load 0x7ff3ca02cf10, 0x7ff3ca02d810,
  0x7ff3ca02cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
  ...
</pre></div>
</div>
<p>Finally, the pattern Cpu0 instruction <strong>ld</strong> defined before in Cpu0InstrInfo.td
will translate DAG (load EntryToken, (Cpu0ISD::Wrapper Register %GP,
TargetGlobalAddress&lt;i32* &#64;gI&gt; 0)) into Cpu0 instruction as below.</p>
<div class="highlight-bash"><div class="highlight"><pre>...
    ld      <span class="nv">$2</span>, %got<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
...
</pre></div>
</div>
<p>Remind in pic mode, Cpu0 use &#8221;.cpload&#8221; and &#8220;ld $2, %got(gI)($gp)&#8221; to access
global variable. It take 5 instructions in Cpu0 and 4 instructions in Mips.
The cost came from we didn&#8217;t assume the register $gp is always assigned to
address .sdata and fixed there. Even we reserve $gp in this function, the $gp
register can be changed at other functions. In last sub-section, the $gp is
assumed to preserve at any function. If $gp is fixed during the run time, then
&#8221;.cpload&#8221; can be removed here and have only one instruction cost in global
variable access. The advantage of &#8221;.cpload&#8221; removing came from losing one
general purpose register $gp which can be allocated for variables.
In last sub-section, .sdata mode, we use &#8221;.cpload&#8221; removing since it is
static link, and without &#8221;.cpload&#8221; will save four instructions which has the
faster result in speed.
In pic mode, the dynamic loading takes too much time.
Romove &#8221;.cpload&#8221; with the cost of losing one general purpose register at all
functions is not deserved here. Anyway, in pic mode and used in static link, you
can choose &#8221;.cpload&#8221; removing. But we perfered use $gp for general purpose
register as the solution.
The relocation records of &#8221;.cpload&#8221; from <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=pic</span></tt> can also
be solved in link stage if we want to link this function by static link.</p>
</div>
<div class="section" id="id4">
<h4>data or bss<a class="headerlink" href="#id4" title="Permalink to this headline">¶</a></h4>
<p>The code fragment of LowerGlobalAddress() as the following corresponding option
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-relocation-model=pic</span></tt> will translate DAG (GlobalAddress&lt;i32* &#64;gI&gt; 0) into
(load EntryToken, (Cpu0ISD::Wrapper (add Cpu0ISD::Hi&lt;gI offset Hi16&gt;, Register %GP),
TargetGlobalAddress&lt;i32* &#64;gI&gt; 0))
in stage &#8220;Legalized selection DAG&#8221; as below.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getAddrGlobalLargeGOT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                                  <span class="kt">unsigned</span> <span class="n">HiFlag</span><span class="p">,</span>
                                                  <span class="kt">unsigned</span> <span class="n">LoFlag</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">EVT</span> <span class="n">Ty</span> <span class="o">=</span> <span class="n">Op</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>
  <span class="n">SDValue</span> <span class="n">Hi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Hi</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">HiFlag</span><span class="p">));</span>
  <span class="n">Hi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Hi</span><span class="p">,</span> <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">Ty</span><span class="p">));</span>
  <span class="n">SDValue</span> <span class="n">Wrapper</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Ty</span><span class="p">,</span> <span class="n">Hi</span><span class="p">,</span>
                                <span class="n">getTargetNode</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">LoFlag</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">Ty</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">Wrapper</span><span class="p">,</span>
                     <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerGlobalAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                               <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TLOF</span><span class="p">.</span><span class="n">IsGlobalInSmallSection</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">getTargetMachine</span><span class="p">()))</span>
    <span class="p">...</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">getAddrGlobalLargeGOT</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_HI16</span><span class="p">,</span>
                                 <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_LO16</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>...
Type-legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:&#39;</span>
SelectionDAG has 10 nodes:
  ...
    0x7fb77a02cd10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fb779c10a08, 0x7fb77a02ca10, 0x7fb77a02cb10,
    0x7fb77a02cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fb77a02ce10: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>

    0x7fb77a02cc10: &lt;multiple use&gt;
  0x7fb77a02cf10: i32,ch <span class="o">=</span> load 0x7fb77a02cd10, 0x7fb77a02ce10,
  0x7fb77a02cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>-3<span class="o">]</span>
  ...

Legalized selection DAG: BB#0 <span class="s1">&#39;_Z3funv:&#39;</span>
SelectionDAG has 16 nodes:
  ...
    0x7fb77a02cd10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fb779c10a08, 0x7fb77a02ca10, 0x7fb77a02cb10,
    0x7fb77a02cc10&lt;ST4<span class="o">[</span>%c<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

      0x7fb779c10a08: &lt;multiple use&gt;
            0x7fb77a02d110: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>19<span class="o">]</span>

          0x7fb77a02d410: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Hi 0x7fb77a02d110

          0x7fb77a02d510: <span class="nv">i32</span> <span class="o">=</span> Register %GP

        0x7fb77a02d610: <span class="nv">i32</span> <span class="o">=</span> add 0x7fb77a02d410, 0x7fb77a02d510

        0x7fb77a02d710: <span class="nv">i32</span> <span class="o">=</span> TargetGlobalAddress&lt;i32* @gI&gt; 0 <span class="o">[</span><span class="nv">TF</span><span class="o">=</span>20<span class="o">]</span>

      0x7fb77a02d810: <span class="nv">i32</span> <span class="o">=</span> Cpu0ISD::Wrapper 0x7fb77a02d610, 0x7fb77a02d710

      0x7fb77a02cc10: &lt;multiple use&gt;
    0x7fb77a02fe10: i32,ch <span class="o">=</span> load 0x7fb779c10a08, 0x7fb77a02d810,
    0x7fb77a02cc10&lt;LD4<span class="o">[</span>GOT<span class="o">]</span>&gt;

    0x7fb77a02cc10: &lt;multiple use&gt;
  0x7fb77a02cf10: i32,ch <span class="o">=</span> load 0x7fb77a02cd10, 0x7fb77a02fe10,
  0x7fb77a02cc10&lt;LD4<span class="o">[</span>@gI<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>
  ...
</pre></div>
</div>
<p>Finally, the pattern Cpu0 instruction <strong>ld</strong> defined before in Cpu0InstrInfo.td
will translate DAG (load EntryToken, (Cpu0ISD::Wrapper (add Cpu0ISD::Hi&lt;gI
offset Hi16&gt;, Register %GP), Cpu0ISD::Lo&lt;gI offset Lo16&gt;)) into Cpu0
instructions as below.</p>
<div class="highlight-bash"><div class="highlight"><pre>...
      addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %got_hi<span class="o">(</span>gI<span class="o">)</span>
      shl   <span class="nv">$2</span>, <span class="nv">$2</span>, 16
      add   <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$gp</span>
      ld    <span class="nv">$2</span>, %got_lo<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$2</span><span class="o">)</span>
...
</pre></div>
</div>
</div>
</div>
<div class="section" id="global-variable-print-support">
<h3>Global variable print support<a class="headerlink" href="#global-variable-print-support" title="Permalink to this headline">¶</a></h3>
<p>Above code is for global address DAG translation.
Next, add the following code to Cpu0MCInstLower.cpp, Cpu0InstPrinter.cpp and
Cpu0ISelLowering.cpp for global variable printing operand function.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>                   <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Invalid target flag!&quot;</span><span class="p">);</span>
<span class="c1">// Cpu0_GPREL is for llc -march=cpu0 -relocation-model=static</span>
<span class="c1">//  -cpu0-use-small-section=false (global var in .sdata)</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="nl">MO_GPREL:</span>     <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPREL</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="nl">MO_GOT16:</span>     <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT16</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="nl">MO_GOT:</span>       <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
<span class="c1">// ABS_HI and ABS_LO is for llc -march=cpu0 -relocation-model=static</span>
<span class="c1">//  (global var in .data)</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="nl">MO_ABS_HI:</span>    <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_HI</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="nl">MO_ABS_LO:</span>    <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_LO</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_GlobalAddress:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">Mang</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">default</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;&lt;unknown operand type&gt;&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                          <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_GlobalAddress:</span>
    <span class="k">return</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">,</span> <span class="n">MOTy</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">...</span>
 <span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="n">printExpr</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>                                 <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Invalid kind!&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_None:</span>           <span class="k">break</span><span class="p">;</span>
<span class="c1">// Cpu0_GPREL is for llc -march=cpu0 -relocation-model=static</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_Cpu0_GPREL:</span>     <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%gp_rel(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_Cpu0_GOT16:</span>     <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got(&quot;</span><span class="p">;</span>    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_Cpu0_GOT:</span>       <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got(&quot;</span><span class="p">;</span>    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_Cpu0_ABS_HI:</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%hi(&quot;</span><span class="p">;</span>     <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="nl">VK_Cpu0_ABS_LO:</span>    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%lo(&quot;</span><span class="p">;</span>     <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The following function is for llc -debug DAG node name printing.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">getTargetNodeName</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Opcode</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">JmpLink:</span>           <span class="k">return</span> <span class="s">&quot;Cpu0ISD::JmpLink&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Hi:</span>                <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Hi&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Lo:</span>                <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Lo&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">GPRel:</span>             <span class="k">return</span> <span class="s">&quot;Cpu0ISD::GPRel&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Ret:</span>               <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Ret&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">DivRem:</span>            <span class="k">return</span> <span class="s">&quot;MipsISD::DivRem&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">DivRemU:</span>           <span class="k">return</span> <span class="s">&quot;MipsISD::DivRemU&quot;</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0ISD</span><span class="o">::</span><span class="nl">Wrapper:</span>           <span class="k">return</span> <span class="s">&quot;Cpu0ISD::Wrapper&quot;</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span>                         <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>OS is the output stream which output to the assembly file.</p>
</div>
<div class="section" id="summary">
<h3>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h3>
<p>The global variable Instruction Selection for DAG translation is not like the
ordinary IR node translation, it has static (absolute address) and PIC mode.
Backend deals this translation by create DAG nodes in function
LowerGlobalAddress() which called by LowerOperation().
Function LowerOperation() take care all Custom type of operation.
Backend set global address as Custom operation by
<strong>”setOperationAction(ISD::GlobalAddress, MVT::i32, Custom);”</strong> in
Cpu0TargetLowering() constructor.
Different address mode has it&#8217;s own DAG list be created.
By set the pattern Pat&lt;&gt; in Cpu0InstrInfo.td, the llvm can apply the compiler
mechanism, pattern match, in the Instruction Selection stage.</p>
<p>There are three type for setXXXAction(), Promote, Expand and Custom.
Except Custom, the other two maybe no need to coding.
The section &#8220;Instruction Selector&#8221; of <a class="footnote-reference" href="#id9" id="id5">[3]</a> is the references.</p>
<p>As shown in the section, the global variable can be laid in
.sdata/.sbss by option -cpu0-use-small-section=true.
It is possible, the small data section (16 bits
addressable) is full out at link stage. When this happens, linker will highlight
this error and force the toolchain user to fix it. The toolchain user, need to
reconsider which global variables should be move from .sdata/.sbss to .data/.bss
by set option -cpu0-use-small-section=false for that global variables declared
file. The rule for global variables allocation is &#8220;set the small and frequent
variables in small 16 addressable area&#8221;.</p>
</div>
</div>
<div class="section" id="array-and-struct-support">
<h2>Array and struct support<a class="headerlink" href="#array-and-struct-support" title="Permalink to this headline">¶</a></h2>
<p>LLVM use getelementptr to represent the array and struct type in C.
Please reference section getelementptr of <a class="footnote-reference" href="#id10" id="id6">[4]</a>.
For ch6_2.cpp, the llvm IR as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch6_2.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Date</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">day</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>// ch6_2.ll
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch6_2.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:32:32:32-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:32:64-</span>
<span class="s2">f32:32:32-f64:32:64-v64:64:64-v128:128:128-a0:0:64-f80:128:128-n8:16:32-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;i386-apple-macosx10.8.0&quot;</span>

%struct.Date <span class="o">=</span> <span class="nb">type</span> <span class="o">{</span> i32, i32, i32 <span class="o">}</span>

@date <span class="o">=</span> global %struct.Date <span class="o">{</span> i32 2012, i32 10, i32 12 <span class="o">}</span>, align 4
@a <span class="o">=</span> global <span class="o">[</span>3 x i32<span class="o">]</span> <span class="o">[</span>i32 2012, i32 10, i32 12<span class="o">]</span>, align 4

define i32 @main<span class="o">()</span> nounwind ssp <span class="o">{</span>
entry:
  %retval <span class="o">=</span> alloca i32, align 4
  %day <span class="o">=</span> alloca i32, align 4
  %i <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %retval
  %0 <span class="o">=</span> load i32* getelementptr inbounds <span class="o">(</span>%struct.Date* @date, i32 0, i32 2<span class="o">)</span>,
  align 4
  store i32 %0, i32* %day, align 4
  %1 <span class="o">=</span> load i32* getelementptr inbounds <span class="o">([</span>3 x i32<span class="o">]</span>* @a, i32 0, i32 1<span class="o">)</span>, align 4
  store i32 %1, i32* %i, align 4
  ret i32 0
<span class="o">}</span>
</pre></div>
</div>
<p>Run Chapter6_1/ with ch6_2.bc on static mode will get the incorrect asm file as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_
debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch6_2.bc -o ch6_2.cpu0.static.s
118-165-66-82:InputFiles Jonathan<span class="nv">$ </span>cat ch6_2.cpu0.static.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch6_2.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,16,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>date<span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>date<span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>   // the correct one is   ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>a<span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>a<span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc

  .type date,@object            <span class="c"># @date</span>
  .data
  .globl  date
  .align  2
date:
  .4byte  2012                    <span class="c"># 0x7dc</span>
  .4byte  10                      <span class="c"># 0xa</span>
  .4byte  12                      <span class="c"># 0xc</span>
  .size date, 12

  .type a,@object               <span class="c"># @a</span>
  .globl  a
  .align  2
a:
  .4byte  2012                    <span class="c"># 0x7dc</span>
  .4byte  10                      <span class="c"># 0xa</span>
  .4byte  12                      <span class="c"># 0xc</span>
  .size a, 12
</pre></div>
</div>
<p>For <strong>“day = date.day”</strong>, the correct one is <strong>“ld $2, 8($2)”</strong>, not
<strong>“ld $2, 0($2)”</strong>, since date.day is offset 8(date).
Type int is 4 bytes in cpu0, and the date.day has fields year and month before
it.
Let use debug option in llc to see what&#8217;s wrong,</p>
<div class="highlight-bash"><div class="highlight"><pre>jonathantekiimac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -debug -relocation-model<span class="o">=</span>static
-filetype<span class="o">=</span>asm ch6_2.bc -o ch6_2.cpu0.static.s
...
<span class="o">===</span> main
Initial selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 20 nodes:
  0x7f7f5b02d210: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5ac10590: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d210: &lt;multiple use&gt;
    0x7f7f5b02d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7f7f5ac10590, 0x7f7f5b02d010, 0x7f7f5b02d110,
    0x7f7f5b02d210&lt;ST4<span class="o">[</span>%retval<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d410: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;%struct.Date* @date&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

      0x7f7f5b02d510: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;8&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7f7f5b02d610: <span class="nv">i32</span> <span class="o">=</span> add 0x7f7f5b02d410, 0x7f7f5b02d510 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

    0x7f7f5b02d210: &lt;multiple use&gt;
  0x7f7f5b02d710: i32,ch <span class="o">=</span> load 0x7f7f5b02d310, 0x7f7f5b02d610, 0x7f7f5b02d210
  &lt;LD4<span class="o">[</span>getelementptr inbounds <span class="o">(</span>%struct.Date* @date, i32 0, i32 2<span class="o">)]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span>

  0x7f7f5b02db10: <span class="nv">i64</span> <span class="o">=</span> Constant&lt;4&gt;

      0x7f7f5b02d710: &lt;multiple use&gt;
      0x7f7f5b02d710: &lt;multiple use&gt;
      0x7f7f5b02d810: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7f7f5b02d210: &lt;multiple use&gt;
    0x7f7f5b02d910: <span class="nv">ch</span> <span class="o">=</span> store 0x7f7f5b02d710:1, 0x7f7f5b02d710, 0x7f7f5b02d810,
     0x7f7f5b02d210&lt;ST4<span class="o">[</span>%day<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7f7f5b02da10: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;<span class="o">[</span>3 x i32<span class="o">]</span>* @a&gt; 0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

      0x7f7f5b02dc10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;4&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

    0x7f7f5b02dd10: <span class="nv">i32</span> <span class="o">=</span> add 0x7f7f5b02da10, 0x7f7f5b02dc10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

    0x7f7f5b02d210: &lt;multiple use&gt;
  0x7f7f5b02de10: i32,ch <span class="o">=</span> load 0x7f7f5b02d910, 0x7f7f5b02dd10, 0x7f7f5b02d210
  &lt;LD4<span class="o">[</span>getelementptr inbounds <span class="o">([</span>3 x i32<span class="o">]</span>* @a, i32 0, i32 1<span class="o">)]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

...


Replacing.3 0x7f7f5b02dd10: <span class="nv">i32</span> <span class="o">=</span> add 0x7f7f5b02da10, 0x7f7f5b02dc10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>5<span class="o">]</span>

With: 0x7f7f5b030010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;<span class="o">[</span>3 x i32<span class="o">]</span>* @a&gt; + 4


Replacing.3 0x7f7f5b02d610: <span class="nv">i32</span> <span class="o">=</span> add 0x7f7f5b02d410, 0x7f7f5b02d510 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

With: 0x7f7f5b02db10: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;%struct.Date* @date&gt; + 8

Optimized lowered selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 15 nodes:
  0x7f7f5b02d210: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5ac10590: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x7f7f5b02d210: &lt;multiple use&gt;
    0x7f7f5b02d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7f7f5ac10590, 0x7f7f5b02d010, 0x7f7f5b02d110,
    0x7f7f5b02d210&lt;ST4<span class="o">[</span>%retval<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

    0x7f7f5b02db10: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;%struct.Date* @date&gt; + 8

    0x7f7f5b02d210: &lt;multiple use&gt;
  0x7f7f5b02d710: i32,ch <span class="o">=</span> load 0x7f7f5b02d310, 0x7f7f5b02db10, 0x7f7f5b02d210
  &lt;LD4<span class="o">[</span>getelementptr inbounds <span class="o">(</span>%struct.Date* @date, i32 0, i32 2<span class="o">)]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span>

      0x7f7f5b02d710: &lt;multiple use&gt;
      0x7f7f5b02d710: &lt;multiple use&gt;
      0x7f7f5b02d810: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

      0x7f7f5b02d210: &lt;multiple use&gt;
    0x7f7f5b02d910: <span class="nv">ch</span> <span class="o">=</span> store 0x7f7f5b02d710:1, 0x7f7f5b02d710, 0x7f7f5b02d810,
     0x7f7f5b02d210&lt;ST4<span class="o">[</span>%day<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>4<span class="o">]</span>

    0x7f7f5b030010: <span class="nv">i32</span> <span class="o">=</span> GlobalAddress&lt;<span class="o">[</span>3 x i32<span class="o">]</span>* @a&gt; + 4

    0x7f7f5b02d210: &lt;multiple use&gt;
  0x7f7f5b02de10: i32,ch <span class="o">=</span> load 0x7f7f5b02d910, 0x7f7f5b030010, 0x7f7f5b02d210
  &lt;LD4<span class="o">[</span>getelementptr inbounds <span class="o">([</span>3 x i32<span class="o">]</span>* @a, i32 0, i32 1<span class="o">)]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>6<span class="o">]</span>

...
</pre></div>
</div>
<p>By <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt>, you can see the DAG translation process.
As above, the DAG list
for date.day (add GlobalAddress&lt;[3 x i32]* &#64;a&gt; 0, Constant&lt;8&gt;) with 3 nodes is
replaced by 1 node GlobalAddress&lt;%struct.Date* &#64;date&gt; + 8.
The DAG list for a[1] is same.
The replacement occurs since TargetLowering.cpp::isOffsetFoldingLegal(...)
return true in <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-static</span></tt> static addressing mode as below.
In Cpu0 the <strong>ld</strong> instruction format is <strong>“ld $r1, offset($r2)”</strong> which
meaning load $r2 address+offset to $r1.
So, we just replace the isOffsetFoldingLegal(...) function by override
mechanism as below.</p>
<p class="rubric">lib/CodeGen/SelectionDAG/TargetLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span>
<span class="n">TargetLowering</span><span class="o">::</span><span class="n">isOffsetFoldingLegal</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalAddressSDNode</span> <span class="o">*</span><span class="n">GA</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Assume that everything is safe in static mode.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Static</span><span class="p">)</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>

  <span class="c1">// In dynamic-no-pic mode, assume that known defined values are safe.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">DynamicNoPIC</span> <span class="o">&amp;&amp;</span>
     <span class="n">GA</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">GA</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isDeclaration</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
     <span class="o">!</span><span class="n">GA</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">isWeakForLinker</span><span class="p">())</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>

  <span class="c1">// Otherwise assume nothing is safe.</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">isOffsetFoldingLegal</span><span class="p">(</span><span class="k">const</span> <span class="n">GlobalAddressSDNode</span> <span class="o">*</span><span class="n">GA</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// The Cpu0 target isn&#39;t yet aware of offsets.</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Beyond that, we need to add the following code fragment to Cpu0ISelDAGToDAG.cpp,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  Cpu0ISelDAGToDAG.cpp</span>
<span class="c1">/// ComplexPattern used on Cpu0InstrInfo</span>
<span class="c1">/// Used on Cpu0 Load/Store instructions</span>
<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span>
<span class="n">SelectAddr</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Parent</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Base</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Offset</span><span class="p">)</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="c1">// Addresses of the form FI+const or FI|const</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">isBaseWithConstantOffset</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">CN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Addr</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">CN</span><span class="o">-&gt;</span><span class="n">getSExtValue</span><span class="p">()))</span> <span class="p">{</span>

      <span class="c1">// If the first operand is a FI, get the TargetFI Node</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">FrameIndexSDNode</span> <span class="o">*</span><span class="n">FIN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">FrameIndexSDNode</span><span class="o">&gt;</span>
                                          <span class="p">(</span><span class="n">Addr</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">)))</span>
        <span class="n">Base</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetFrameIndex</span><span class="p">(</span><span class="n">FIN</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">ValTy</span><span class="p">);</span>
      <span class="k">else</span>
        <span class="n">Base</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

      <span class="n">Offset</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">CN</span><span class="o">-&gt;</span><span class="n">getZExtValue</span><span class="p">(),</span> <span class="n">ValTy</span><span class="p">);</span>
      <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Recall we have translated DAG list for date.day
(add GlobalAddress&lt;[3 x i32]* &#64;a&gt; 0, Constant&lt;8&gt;) into
(add (add Cpu0ISD::Hi (Cpu0II::MO_ABS_HI), Cpu0ISD::Lo(Cpu0II::MO_ABS_LO)),
Constant&lt;8&gt;) by the following code in Cpu0ISelLowering.cpp.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0ISelLowering.cpp</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerGlobalAddress</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                    <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
    <span class="c1">// %hi/%lo relocation</span>
    <span class="n">SDValue</span> <span class="n">GAHi</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_HI</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">GALo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">GV</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span>
                                              <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_ABS_LO</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">HiPart</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Hi</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">VTs</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">GAHi</span><span class="p">,</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">GALo</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">HiPart</span><span class="p">,</span> <span class="n">Lo</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>So, when the SelectAddr(...) of Cpu0ISelDAGToDAG.cpp is called.
The Addr SDValue in SelectAddr(..., Addr, ...) is DAG list for date.day
(add (add Cpu0ISD::Hi (Cpu0II::MO_ABS_HI), Cpu0ISD::Lo(Cpu0II::MO_ABS_LO)),
Constant&lt;8&gt;).
Since Addr.getOpcode() = ISD:ADD, Addr.getOperand(0) =
(add Cpu0ISD::Hi (Cpu0II::MO_ABS_HI), Cpu0ISD::Lo(Cpu0II::MO_ABS_LO)) and
Addr.getOperand(1).getOpcode() = ISD::Constant, the Base = SDValue
(add Cpu0ISD::Hi (Cpu0II::MO_ABS_HI), Cpu0ISD::Lo(Cpu0II::MO_ABS_LO)) and
Offset = Constant&lt;8&gt;.
After set Base and Offset, the load DAG will translate the global address
date.day into machine instruction <strong>“ld $r1, 8($r2)”</strong> in Instruction Selection
stage.</p>
<p>Chapter6_2/ include these changes as above, you can run it with ch6_2.cpp to get
the correct generated instruction <strong>“ld $r1, 8($r2)”</strong> for date.day access, as
follows.</p>
<div class="highlight-bash"><div class="highlight"><pre>...
ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>a<span class="o">)</span>
shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>a<span class="o">)</span>
ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
</pre></div>
</div>
</div>
<div class="section" id="type-of-char-and-short-int">
<h2>Type of char and short int<a class="headerlink" href="#type-of-char-and-short-int" title="Permalink to this headline">¶</a></h2>
<p>To support signed/unsigned char and short int, we add the following code to
Chapter6_3/.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter6_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">sextloadi16_a</span>   <span class="o">:</span> <span class="n">AlignedLoad</span><span class="o">&lt;</span><span class="n">sextloadi16</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">zextloadi16_a</span>   <span class="o">:</span> <span class="n">AlignedLoad</span><span class="o">&lt;</span><span class="n">zextloadi16</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">extloadi16_a</span>    <span class="o">:</span> <span class="n">AlignedLoad</span><span class="o">&lt;</span><span class="n">extloadi16</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">truncstorei16_a</span> <span class="o">:</span> <span class="n">AlignedStore</span><span class="o">&lt;</span><span class="n">truncstorei16</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">...</span>
<span class="n">defm</span> <span class="n">LB</span>     <span class="o">:</span> <span class="n">LoadM32</span><span class="o">&lt;</span><span class="mh">0x03</span><span class="p">,</span> <span class="s">&quot;lb&quot;</span><span class="p">,</span>  <span class="n">sextloadi8</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">LBu</span>    <span class="o">:</span> <span class="n">LoadM32</span><span class="o">&lt;</span><span class="mh">0x04</span><span class="p">,</span> <span class="s">&quot;lbu&quot;</span><span class="p">,</span> <span class="n">zextloadi8</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">SB</span>     <span class="o">:</span> <span class="n">StoreM32</span><span class="o">&lt;</span><span class="mh">0x05</span><span class="p">,</span> <span class="s">&quot;sb&quot;</span><span class="p">,</span> <span class="n">truncstorei8</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">LH</span>     <span class="o">:</span> <span class="n">LoadM32</span><span class="o">&lt;</span><span class="mh">0x06</span><span class="p">,</span> <span class="s">&quot;lh&quot;</span><span class="p">,</span>  <span class="n">sextloadi16_a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">LHu</span>    <span class="o">:</span> <span class="n">LoadM32</span><span class="o">&lt;</span><span class="mh">0x07</span><span class="p">,</span> <span class="s">&quot;lhu&quot;</span><span class="p">,</span> <span class="n">zextloadi16_a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">SH</span>     <span class="o">:</span> <span class="n">StoreM32</span><span class="o">&lt;</span><span class="mh">0x08</span><span class="p">,</span> <span class="s">&quot;sh&quot;</span><span class="p">,</span> <span class="n">truncstorei16_a</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Run Chapter6_3/ with ch6_3.cpp will get the following result.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/InputFiles/ch6_3.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22</pre></div></td><td class="code"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Date</span>
<span class="p">{</span>
  <span class="kt">short</span> <span class="n">year</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">month</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">day</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">hour</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">minute</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>

<span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">b</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="sc">&#39;a&#39;</span><span class="p">,</span> <span class="sc">&#39;b&#39;</span><span class="p">,</span> <span class="sc">&#39;c&#39;</span><span class="p">,</span> <span class="sc">&#39;\0&#39;</span><span class="p">};</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">a</span> <span class="o">=</span> <span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="kt">char</span> <span class="n">c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">b</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>
  <span class="n">Date</span> <span class="n">date1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">11</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">25</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">9</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">40</span><span class="p">,</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="mi">15</span><span class="p">};</span>
  <span class="kt">char</span> <span class="n">m</span> <span class="o">=</span> <span class="n">date1</span><span class="p">.</span><span class="n">month</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">s</span> <span class="o">=</span> <span class="n">date1</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-64-245:InputFiles Jonathan<span class="nv">$ </span>clang -c ch6_3.cpp -emit-llvm -o ch6_3.bc
118-165-64-245:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch6_3.bc -o
ch6_3.cpu0.s
118-165-64-245:InputFiles Jonathan<span class="nv">$ </span>cat ch6_3.cpu0.s
      .section .mdebug.abi32
      .previous
      .file   <span class="s2">&quot;ch6_3.bc&quot;</span>
      .text
      .globl  main
      .align  2
      .type   main,@function
      .ent    main                    <span class="c"># @main</span>
main:
      .cfi_startproc
      .frame  <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
      .mask   0x00000000,0
      .set    noreorder
      .cpload <span class="nv">$6</span>
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
      .cfi_def_cfa_offset 32
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
      st      <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, %got<span class="o">(</span>b<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      lbu     <span class="nv">$4</span>, 1<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      sb      <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      lbu     <span class="nv">$3</span>, 1<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      sb      <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, %got<span class="o">(</span><span class="nv">$_ZZ4mainE5date1</span><span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      addiu   <span class="nv">$3</span>, <span class="nv">$3</span>, %lo<span class="o">(</span><span class="nv">$_ZZ4mainE5date1</span><span class="o">)</span>
      lhu     <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      shl     <span class="nv">$4</span>, <span class="nv">$4</span>, 16
      lhu     <span class="nv">$5</span>, 6<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      or      <span class="nv">$4</span>, <span class="nv">$4</span>, <span class="nv">$5</span>
      st      <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             // store hour, minute and second on 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      lhu     <span class="nv">$4</span>, 2<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      lhu     <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      shl     <span class="nv">$3</span>, <span class="nv">$3</span>, 16
      or      <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
      st      <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>              // store year, month and day on 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      lbu     <span class="nv">$3</span>, 10<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             // <span class="nv">m</span> <span class="o">=</span> date1.month;
      sb      <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      lbu     <span class="nv">$3</span>, 14<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             // <span class="nv">s</span> <span class="o">=</span> date1.second;
      sb      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
      ret     <span class="nv">$lr</span>
      .set    macro
      .set    reorder
      .end    main
<span class="nv">$tmp2</span>:
      .size   main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
      .cfi_endproc

      .type   b,@object               <span class="c"># @b</span>
      .data
      .globl  b
b:
      .asciz   <span class="s2">&quot;abc&quot;</span>
      .size   b, 4

      .type   <span class="nv">$_ZZ4mainE5date1</span>,@object <span class="c"># @_ZZ4mainE5date1</span>
      .section        .rodata.cst8,<span class="s2">&quot;aM&quot;</span>,@progbits,8
      .align  1
<span class="nv">$_ZZ4mainE5date1</span>:
      .2byte  2012                    <span class="c"># 0x7dc</span>
      .byte   11                      <span class="c"># 0xb</span>
      .byte   25                      <span class="c"># 0x19</span>
      .byte   9                       <span class="c"># 0x9</span>
      .byte   40                      <span class="c"># 0x28</span>
      .byte   15                      <span class="c"># 0xf</span>
      .space  1
      .size   <span class="nv">$_ZZ4mainE5date1</span>, 8
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/CommandLine.html">http://llvm.org/docs/CommandLine.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id9" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html">http://llvm.org/docs/WritingAnLLVMBackend.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="genobj.html">Generating object files</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="ctrlflow.html">Control flow statements</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>