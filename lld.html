<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>LLD for Cpu0 &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Appendix A: Getting Started: Installing LLVM and the Cpu0 example code" href="install.html" />
    <link rel="prev" title="Backend Optimization" href="optimize.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>LLD for Cpu0</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="optimize.html">Backend Optimization</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 example code</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="lld-for-cpu0">
<span id="sec-lld"></span><h1>LLD for Cpu0<a class="headerlink" href="#lld-for-cpu0" title="Permalink to this headline">¶</a></h1>
<p>This chapter add Cpu0 backend in lld. With this lld Cpu0 for ELF linker support,
the program with global variables can be allocated in ELF file format layout.
Meaning the relocation records of global variables can be solved. In addition,
llvm-objdump driver is modified for support generate Hex file from ELF.
With these two tools supported, the program with global variables of existed in
section .data and .rodata can be accessed and transfered to Hex file which feed
to Verilog Cpu0 machine and run on your PC/Laptop.</p>
<p>LLD web site <a class="footnote-reference" href="#id15" id="id1">[1]</a>. LLD install requirement on Linux <a class="footnote-reference" href="#id16" id="id2">[2]</a>.
The gcc and clang 3.4 can build lld on Linux.
On iMac, clang can build successfully.
If you run with Virtual Machine (VM), please keep your phisical memory size
setting over 1GB to avoid insufficient memory link error.</p>
<div class="section" id="install-lld-and-build-with-cpu0-lld">
<h2>Install lld and build with Cpu0 lld<a class="headerlink" href="#install-lld-and-build-with-cpu0-lld" title="Permalink to this headline">¶</a></h2>
<p>LLD project is underdevelopment and can be compiled only with c++11 standard (C++
2011 year announced standard). For iMac, our software is OS X version 10.9.1 and
Xcode version 5.0.2. For old iMac software version, you can install VM (such as
Virtual Box) and build lld as Linux platform. Please download lld from llvm web
<a class="footnote-reference" href="#id17" id="id3">[3]</a> and put lld souce code on {llvm-src}/tools/lld like we download llvm and
clang as shown in Appendex A.</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:tools Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/tools
1-160-136-173:tools Jonathan<span class="nv">$ </span>ls
...
lld              llvm-config      llvm-extract    llvm-nm           llvm-stress   obj2yaml
</pre></div>
</div>
<p>Next, copy lld Cpu0 architecture ELF support as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:Cpu0 Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../../tools/lld/lib/ReaderWriter/ELF/
1-160-136-173:ELF Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/tools/lld/lib/ReaderWriter/ELF
1-160-136-173:ELF Jonathan<span class="nv">$ </span>cp -rf ~/test/lbd/docs/BackendTutorial/
lbdex/Cpu0_lld/Cpu0 .
1-160-136-173:ELF Jonathan<span class="nv">$ </span>cp -f ~/test/lbd/docs/BackendTutorial/
lbdex/Cpu0_lld/CMakeLists.txt .
1-160-136-173:ELF Jonathan<span class="nv">$ </span>cp -f ~/test/lbd/docs/BackendTutorial/
lbdex/Cpu0_lld/ELFLinkingContext.cpp .
1-160-136-173:ELF Jonathan<span class="nv">$ </span>cp -f ~/test/lbd/docs/BackendTutorial/
lbdex/Cpu0_lld/Targets.h .
1-160-136-173:ELF Jonathan<span class="nv">$ </span>cp -f ~/test/lbd/docs/BackendTutorial/
lbdex/Cpu0_lld/Resolver.cpp ../../Core/.
</pre></div>
</div>
<p>Finally, update llvm-objdump to support convert ELF file to Hex file as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:ELF Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../../../llvm-objdump/
1-160-136-173:llvm-objdump Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/tools/llvm-objdump
1-160-136-173:llvm-objdump Jonathan<span class="nv">$ </span>cp -rf ~/test/lbd/docs/BackendTutorial/
lbdex/llvm-objdump/* .
</pre></div>
</div>
<p>Now, build llvm/lld with Cpu0 support as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:cmake_debug_build Jonathan<span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>clang++ -
<span class="nv">DCMAKE_C_COMPILER</span><span class="o">=</span>clang -DCMAKE_CXX_FLAGS<span class="o">=</span>-std<span class="o">=</span>c++11 -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug
-G <span class="s2">&quot;Xcode&quot;</span> ../src
-- The C compiler identification is Clang 5.0.0
-- The CXX compiler identification is Clang 5.0.0
...
-- Targeting Cpu0
...
-- Configuring <span class="k">done</span>
-- Generating <span class="k">done</span>
-- Build files have been written to: /Users/Jonathan/llvm/test/cmake_debug_build
</pre></div>
</div>
<p>If use VM (guest machine is Linux) or Linux, build as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">[</span>Gamma@localhost cmake_debug_build<span class="o">]</span><span class="nv">$ </span>cmake -DCMAKE_CXX_COMPILER<span class="o">=</span>g++ -
<span class="nv">DCMAKE_C_COMPILER</span><span class="o">=</span>gcc -DCMAKE_CXX_FLAGS<span class="o">=</span>-std<span class="o">=</span>c++11 -DCMAKE_BUILD_TYPE<span class="o">=</span>Debug
-G <span class="s2">&quot;Unix Makefiles&quot;</span> ../src
-- The C compiler identification is Clang 3.4.0
-- The CXX compiler identification is Clang 3.4.0
...
-- Targeting Cpu0
...
-- Configuring <span class="k">done</span>
-- Generating <span class="k">done</span>
-- Build files have been written to: /usr/local/llvm/test/cmake_debug_build
</pre></div>
</div>
</div>
<div class="section" id="cpu0-lld-souce-code">
<h2>Cpu0 lld souce code<a class="headerlink" href="#cpu0-lld-souce-code" title="Permalink to this headline">¶</a></h2>
<p>The code added on lld to support Cpu0 ELF as follows,</p>
<p class="rubric">lbdex/Cpu0_lld/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">target_link_libraries</span><span class="p">(</span><span class="n">lldELF</span>
  <span class="p">...</span>
  <span class="n">lldCpu0ELFTarget</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint16_t</span> <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">getOutputMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">getTriple</span><span class="p">().</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Targets.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0/Cpu0Target.h&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Resolver.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Resolver</span><span class="o">::</span><span class="n">checkUndefines</span><span class="p">(</span><span class="kt">bool</span> <span class="n">final</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">_context</span><span class="p">.</span><span class="n">printRemainingUndefines</span><span class="p">())</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">undefAtom</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;_gp_disp&quot;</span><span class="p">)</span> <span class="p">{</span> <span class="c1">// cschen debug</span>
          <span class="n">foundUndefines</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="k">continue</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="p">...</span>
      <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_lld_library</span><span class="p">(</span><span class="n">lldCpu0ELFTarget</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0TargetHandler</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0RelocationHandler</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0RelocationPass</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>

<span class="n">target_link_libraries</span><span class="p">(</span><span class="n">lldCpu0ELFTarget</span>
  <span class="n">lldCore</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0LinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.h ---------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0_LINKING_CONTEXT_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0_LINKING_CONTEXT_H</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="cp">#include &quot;lld/ReaderWriter/ELFLinkingContext.h&quot;</span>

<span class="cp">#include &quot;llvm/Object/ELF.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ELF.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="c1">/// \brief cpu0 internal references.</span>
<span class="k">enum</span> <span class="p">{</span>
  <span class="c1">/// \brief The 32 bit index of the relocation in the got this reference refers</span>
  <span class="c1">/// to.</span>
  <span class="n">LLD_R_CPU0_GOTRELINDEX</span> <span class="o">=</span> <span class="mi">1024</span><span class="p">,</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span> <span class="n">LLVM_FINAL</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ELFLinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ELFLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandlerBase</span><span class="o">&gt;</span><span class="p">(</span>
                                  <span class="k">new</span> <span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)))</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isLittleEndian</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="p">);</span>

  <span class="c1">// Cpu0 run begin from address 0 while X86 from 0x400000</span>
  <span class="k">virtual</span> <span class="kt">uint64_t</span> <span class="n">getBaseAddress</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_baseAddress</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="mh">0x000000</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">_baseAddress</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isDynamicRelocation</span><span class="p">(</span><span class="k">const</span> <span class="n">DefinedAtom</span> <span class="o">&amp;</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span><span class="p">()){</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_GLOB_DAT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isPLTRelocation</span><span class="p">(</span><span class="k">const</span> <span class="n">DefinedAtom</span> <span class="o">&amp;</span><span class="p">,</span>
                               <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span><span class="p">()){</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_RELGOT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// \brief Cpu0 has two relative relocations</span>
  <span class="c1">/// a) for supporting IFUNC - R_CPU0_RELGOT</span>
  <span class="c1">/// b) for supporting relative relocs - R_CPU0_RELATIVE</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isRelativeReloc</span><span class="p">(</span><span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">r</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">r</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_RELGOT</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">/// \brief Create Internal files for Init/Fini</span>
  <span class="kt">bool</span> <span class="n">createInternalFiles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">Reference</span><span class="o">::</span><span class="n">Kind</span><span class="o">&gt;</span> <span class="n">relocKindFromString</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">str</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">stringFromRelocKind</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">isStaticExecutable</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">_isStaticExecutable</span><span class="p">;</span> <span class="p">}</span>

<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0LinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp -------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="cp">#include &quot;lld/Core/File.h&quot;</span>
<span class="cp">#include &quot;lld/Core/Instrumentation.h&quot;</span>

<span class="cp">#include &quot;llvm/ADT/ArrayRef.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringSwitch.h&quot;</span>

<span class="cp">#include &quot;Atoms.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationPass.h&quot;</span>


<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">cpu0InitFiniAtomContent</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="c1">// Cpu0_64InitFini Atom</span>
<span class="k">class</span> <span class="nc">Cpu0InitAtom</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InitFiniAtom</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0InitAtom</span><span class="p">(</span><span class="k">const</span> <span class="n">File</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">function</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">InitFiniAtom</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;.init_array&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef NDEBUG</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">&quot;__init_fn_&quot;</span><span class="p">;</span>
    <span class="n">_name</span> <span class="o">+=</span> <span class="n">function</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">rawContent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cpu0InitFiniAtomContent</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">Alignment</span> <span class="n">alignment</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Alignment</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0FiniAtom</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InitFiniAtom</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0FiniAtom</span><span class="p">(</span><span class="k">const</span> <span class="n">File</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">function</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">InitFiniAtom</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;.fini_array&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef NDEBUG</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">&quot;__fini_fn_&quot;</span><span class="p">;</span>
    <span class="n">_name</span> <span class="o">+=</span> <span class="n">function</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">rawContent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cpu0InitFiniAtomContent</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="n">Alignment</span> <span class="n">alignment</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Alignment</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0InitFiniFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0InitFiniFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="s">&quot;command line option -init/-fini&quot;</span><span class="p">),</span> <span class="n">_ordinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">addInitFunction</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Atom</span> <span class="o">*</span><span class="n">initFunctionAtom</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">SimpleUndefinedAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">Cpu0InitAtom</span> <span class="o">*</span><span class="n">initAtom</span> <span class="o">=</span>
           <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">Cpu0InitAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
    <span class="n">initAtom</span><span class="o">-&gt;</span><span class="n">addReference</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">initFunctionAtom</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">initAtom</span><span class="o">-&gt;</span><span class="n">setOrdinal</span><span class="p">(</span><span class="n">_ordinal</span><span class="o">++</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">initFunctionAtom</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">initAtom</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addFiniFunction</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Atom</span> <span class="o">*</span><span class="n">finiFunctionAtom</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">SimpleUndefinedAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">Cpu0FiniAtom</span> <span class="o">*</span><span class="n">finiAtom</span> <span class="o">=</span>
           <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">Cpu0FiniAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
    <span class="n">finiAtom</span><span class="o">-&gt;</span><span class="n">addReference</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">finiFunctionAtom</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">finiAtom</span><span class="o">-&gt;</span><span class="n">setOrdinal</span><span class="p">(</span><span class="n">_ordinal</span><span class="o">++</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">finiFunctionAtom</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">finiAtom</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_allocator</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">_ordinal</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end anon namespace</span>

<span class="kt">void</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">createInternalFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">createInternalFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0InitFiniFile</span><span class="o">&gt;</span> <span class="n">initFiniFile</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">Cpu0InitFiniFile</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ai</span> <span class="o">:</span> <span class="n">initFunctions</span><span class="p">())</span>
    <span class="n">initFiniFile</span><span class="o">-&gt;</span><span class="n">addInitFunction</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ai</span><span class="o">:</span><span class="n">finiFunctions</span><span class="p">())</span>
    <span class="n">initFiniFile</span><span class="o">-&gt;</span><span class="n">addFiniFunction</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">initFiniFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define LLD_CASE(name) .Case(#name, llvm::ELF::name)</span>

<span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">Reference</span><span class="o">::</span><span class="n">Kind</span><span class="o">&gt;</span>
<span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">relocKindFromString</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">str</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;LLD_R_CPU0_GOTRELINDEX&quot;</span><span class="p">,</span> <span class="n">LLD_R_CPU0_GOTRELINDEX</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">YamlReaderError</span><span class="o">::</span><span class="n">illegal_value</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef LLD_CASE</span>

<span class="cp">#define LLD_CASE(name) case llvm::ELF::name: return std::string(#name);</span>

<span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">stringFromRelocKind</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">LLD_R_CPU0_GOTRELINDEX</span>:
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;LLD_R_CPU0_GOTRELINDEX&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">YamlReaderError</span><span class="o">::</span><span class="n">illegal_value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.h</span>
<span class="c1">//------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0_RELOCATION_HANDLER_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0_RELOCATION_HANDLER_H</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">object</span><span class="o">::</span><span class="n">ELFType</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="n">big</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">Cpu0ELFType</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0TargetRelocationHandler</span> <span class="n">LLVM_FINAL</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">TargetRelocationHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0TargetRelocationHandler</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">_tlsSize</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">_context</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">virtual</span> <span class="n">error_code</span> <span class="n">applyRelocation</span><span class="p">(</span><span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="p">,</span>
                                        <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

  <span class="k">virtual</span> <span class="kt">int64_t</span> <span class="n">relocAddend</span><span class="p">(</span><span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="c1">// Cached size of the TLS segment.</span>
  <span class="k">mutable</span> <span class="kt">uint64_t</span> <span class="n">_tlsSize</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">_context</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationHandler.cpp ------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
<span class="cp">#include &quot;llvm/Object/ObjectFile.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/system_error.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elf</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">object</span><span class="p">;</span>

<span class="k">static</span> <span class="kt">bool</span> <span class="nf">error</span><span class="p">(</span><span class="n">error_code</span> <span class="n">ec</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ec</span><span class="p">)</span> <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Cpu0RelocationHandler.cpp : error reading file: &quot;</span> 
         <span class="o">&lt;&lt;</span> <span class="n">ec</span><span class="p">.</span><span class="n">message</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">().</span><span class="n">flush</span><span class="p">();</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// \brief R_CPU0_HI16 - word64: (S + A) &gt;&gt; 16</span>
<span class="kt">void</span> <span class="n">relocHI16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Don&#39;t know why A, ref.addend(), = 9</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">relocLO16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
 <span class="c1">// Don&#39;t know why A, ref.addend(), = 9</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&amp;</span> <span class="mh">0x0000ffff</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_GOT16 - word32: S</span>
<span class="kt">void</span> <span class="n">relocGOT16</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_PC24 - word32: S + A - P</span>
<span class="kt">void</span> <span class="n">relocPC24</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span>  <span class="o">-</span> <span class="n">P</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">machinecode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> 
                         <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">offset</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="p">(((</span><span class="n">result</span> <span class="o">+</span> <span class="n">offset</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">)</span> <span class="o">|</span> <span class="n">opcode</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_32 - word24:  S</span>
<span class="kt">void</span> <span class="n">reloc24</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span> <span class="o">&amp;</span> <span class="mh">0x00ffffff</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">machinecode</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> 
                         <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="kt">uint32_t</span> <span class="n">opcode</span> <span class="o">=</span> <span class="p">(</span><span class="n">machinecode</span> <span class="o">&amp;</span> <span class="mh">0xff000000</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="p">(</span><span class="n">opcode</span> <span class="o">|</span> <span class="n">addr</span><span class="p">);</span>
  <span class="c1">// TODO: Make sure that the result zero extends to the 64bit value.</span>
<span class="p">}</span>

<span class="c1">/// \brief R_CPU0_32 - word32:  S</span>
<span class="kt">void</span> <span class="n">reloc32</span><span class="p">(</span><span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">P</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">S</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">A</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">result</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)(</span><span class="n">S</span><span class="p">);</span>
  <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">)</span> <span class="o">=</span>
      <span class="n">result</span> <span class="o">|</span>
      <span class="p">(</span><span class="kt">uint32_t</span><span class="p">)</span> <span class="o">*</span> <span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span> <span class="o">*&gt;</span><span class="p">(</span><span class="n">location</span><span class="p">);</span>
  <span class="c1">// TODO: Make sure that the result zero extends to the 64bit value.</span>
<span class="p">}</span>
<span class="p">}</span> <span class="c1">// end anon namespace</span>

<span class="kt">int64_t</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">relocAddend</span><span class="p">(</span><span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_PC24</span>:
    <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#ifdef DLINKER</span>
<span class="k">class</span> <span class="nc">Cpu0SoPlt</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">uint32_t</span> <span class="n">funAddr</span><span class="p">[</span><span class="mi">100</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">funAddrSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="nf">createFunAddr</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> 
                     <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">);</span>
  <span class="c1">// Return function index, 1: 1st function appear on section .text of .so.</span>
  <span class="c1">//   2: 2nd function ...</span>
  <span class="c1">// For example: 3 functions _Z2laii, _Z3fooii and _Z3barv. 1: is _Z2laii </span>
  <span class="c1">//   2 is _Z3fooii, 3: is _Z3barv.</span>
  <span class="kt">int</span> <span class="nf">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">fAddr</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">void</span> <span class="n">Cpu0SoPlt</span><span class="o">::</span><span class="n">createFunAddr</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">,</span> 
                   <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">dynsymSection</span> <span class="o">=</span> <span class="n">context</span><span class="p">.</span><span class="n">getTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">targetLayout</span><span class="p">().</span>
                       <span class="n">findOutputSection</span><span class="p">(</span><span class="s">&quot;.dynsym&quot;</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">dynsymFileOffset</span><span class="p">,</span> <span class="n">dynsymSize</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">dynsymSection</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">dynsymFileOffset</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
    <span class="n">dynsymSize</span> <span class="o">=</span> <span class="n">dynsymSection</span><span class="o">-&gt;</span><span class="n">memSize</span><span class="p">();</span>
    <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">dynsymFileOffset</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">uint64_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">dynsymSize</span><span class="p">;</span> <span class="n">i</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">funAddr</span><span class="p">[</span><span class="n">funAddrSize</span><span class="p">]</span> <span class="o">=</span> 
        <span class="o">*</span><span class="k">reinterpret_cast</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="kt">ubig32_t</span><span class="o">*&gt;</span><span class="p">((</span><span class="kt">uint32_t</span><span class="o">*</span><span class="p">)</span>
        <span class="p">(</span><span class="n">atomContent</span> <span class="o">+</span> <span class="n">i</span><span class="p">));</span>
      <span class="n">funAddrSize</span><span class="o">++</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0SoPlt</span><span class="o">::</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">fAddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">funAddrSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Below statement fix the issue that both __tls_get_addr and first </span>
    <span class="c1">// function has the same file offset 0 issue.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="p">(</span><span class="n">funAddrSize</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">])</span>
      <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">fAddr</span> <span class="o">==</span> <span class="n">funAddr</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="p">{</span>
      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0SoPlt</span> <span class="n">cpu0SoPlt</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>

<span class="n">error_code</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">static</span> <span class="kt">bool</span> <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">soName</span><span class="p">(</span><span class="s">&quot;libfoobar.cpu0.so&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">firstTime</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">()</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">cpu0SoPlt</span><span class="p">.</span><span class="n">createFunAddr</span><span class="p">(</span><span class="n">_context</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">_context</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">()</span> <span class="o">==</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span> <span class="o">&amp;&amp;</span> 
             <span class="o">!</span><span class="n">_context</span><span class="p">.</span><span class="n">isStaticExecutable</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">cpu0SoPlt</span><span class="p">.</span><span class="n">createFunAddr</span><span class="p">(</span><span class="n">_context</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">firstTime</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">atom</span><span class="p">.</span><span class="n">_fileOffset</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">atomContent</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">targetVAddress</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="n">addressOfAtom</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
  <span class="kt">uint64_t</span> <span class="n">relocVAddress</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="n">_virtualAddr</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
<span class="cp">#if 1 </span><span class="c1">// For case R_CPU0_GOT16:</span>
<span class="c1">//  auto gotAtomIter = _context.getTargetHandler&lt;Cpu0ELFType&gt;().targetLayout().</span>
<span class="c1">//                     findAbsoluteAtom(&quot;_GLOBAL_OFFSET_TABLE_&quot;);</span>
<span class="c1">//  uint64_t globalOffsetTableAddress = writer.addressOfAtom(*gotAtomIter);</span>
<span class="c1">// .got.plt start from _GLOBAL_OFFSET_TABLE_</span>
  <span class="k">auto</span> <span class="n">gotpltSection</span> <span class="o">=</span> <span class="n">_context</span><span class="p">.</span><span class="n">getTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span><span class="p">().</span><span class="n">targetLayout</span><span class="p">().</span>
                       <span class="n">findOutputSection</span><span class="p">(</span><span class="s">&quot;.got.plt&quot;</span><span class="p">);</span>
  <span class="kt">uint64_t</span> <span class="n">gotPltFileOffset</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">gotpltSection</span><span class="p">)</span>
    <span class="n">gotPltFileOffset</span> <span class="o">=</span> <span class="n">gotpltSection</span><span class="o">-&gt;</span><span class="n">fileOffset</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="n">gotPltFileOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="cp">#endif</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#if 0</span><span class="c"> // Not support yet</span>
<span class="c">  case R_CPU0_GOT16:</span>
<span class="cp">#if 1</span>
<span class="c">    idx = cpu0SoPlt.getDynFunIndexByTargetAddr(targetVAddress);</span>
<span class="c">    relocGOT16(location, relocVAddress, idx, ref.addend());</span>
<span class="cp">#else</span>
<span class="c">    relocGOT16(location, relocVAddress, (targetVAddress - gotPltFileOffset), </span>
<span class="c">               ref.addend());</span>
<span class="cp">#endif</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">case</span> <span class="n">R_CPU0_PC24</span>:
    <span class="n">relocPC24</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">R_CPU0_CALL16</span>:
  <span class="c1">// offset at _GLOBAL_OFFSET_TABLE_ and $gp point to _GLOBAL_OFFSET_TABLE_.</span>
    <span class="n">idx</span> <span class="o">=</span> <span class="n">cpu0SoPlt</span><span class="p">.</span><span class="n">getDynFunIndexByTargetAddr</span><span class="p">(</span><span class="n">targetVAddress</span><span class="p">);</span>
    <span class="n">reloc32</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">idx</span><span class="o">*</span><span class="mh">0x04</span><span class="o">+</span><span class="mi">16</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">R_CPU0_24</span>:
    <span class="n">reloc24</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_32</span>:
    <span class="n">reloc32</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="c1">// Runtime only relocations. Ignore here.</span>
  <span class="k">case</span> <span class="n">R_CPU0_JUMP_SLOT</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">lld</span>:<span class="o">:</span><span class="n">Reference</span><span class="o">::</span><span class="n">kindLayoutAfter</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">lld</span>:<span class="o">:</span><span class="n">Reference</span><span class="o">::</span><span class="n">kindLayoutBefore</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">lld</span>:<span class="o">:</span><span class="n">Reference</span><span class="o">::</span><span class="n">kindInGroup</span><span class="o">:</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="nl">default:</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">raw_string_ostream</span> <span class="n">s</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>
    <span class="k">auto</span> <span class="n">name</span> <span class="o">=</span> <span class="n">_context</span><span class="p">.</span><span class="n">stringFromRelocKind</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">());</span>
    <span class="n">s</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Unhandled relocation: &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">atom</span><span class="p">.</span><span class="n">_atom</span><span class="o">-&gt;</span><span class="n">file</span><span class="p">().</span><span class="n">path</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:&quot;</span>
      <span class="o">&lt;&lt;</span> <span class="n">atom</span><span class="p">.</span><span class="n">_atom</span><span class="o">-&gt;</span><span class="n">name</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;@&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
      <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">name</span> <span class="o">?</span> <span class="o">*</span><span class="n">name</span> <span class="o">:</span> <span class="s">&quot;&lt;unknown&gt;&quot;</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; (&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">flush</span><span class="p">();</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="n">str</span><span class="p">.</span><span class="n">c_str</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationPass.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.h -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">///</span>
<span class="c1">/// \file</span>
<span class="c1">/// \brief Declares the relocation processing pass for cpu0. This includes</span>
<span class="c1">///   GOT and PLT entries, TLS, COPY, and ifunc.</span>
<span class="c1">///</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_CPU0_RELOCATION_PASS_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_CPU0_RELOCATION_PASS_H</span>

<span class="cp">#include &lt;memory&gt;</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Pass</span><span class="p">;</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="c1">/// \brief Create cpu0 relocation pass for the given linking context.</span>
<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><pre>//===- lib/ReaderWriter/ELF/Cpu0/Cpu0RelocationPass.cpp ---------------===//
//
//                             The LLVM Linker
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
///
/// \file
/// \brief Defines the relocation processing pass for Cpu0. This includes
///   GOT and PLT entries, TLS, and ifunc.
///
/// This also includes aditional behaivor that gnu-ld and gold implement but
/// which is not specified anywhere.
///
//===----------------------------------------------------------------------===//

#include "Cpu0RelocationPass.h"

#include "lld/ReaderWriter/Simple.h"

#include "llvm/ADT/DenseMap.h"

#include "Atoms.h"
#include "Cpu0LinkingContext.h"

using namespace lld;
using namespace lld::elf;
using namespace llvm::ELF;

namespace {

// .plt value (entry 0)
const uint8_t cpu0BootAtomContent[16] = {
  0x36, 0xff, 0xff, 0xfc, // jmp _start
  0x36, 0x00, 0x00, 0x04, // jmp 4
  0x36, 0x00, 0x00, 0x04, // jmp 4
  0x36, 0xff, 0xff, 0xfc // jmp -4
};

#ifdef DLINKER
// .got values
const uint8_t cpu0GotAtomContent[16] = { 0 };

// .plt value (entry 0)
const uint8_t cpu0Plt0AtomContent[16] = {
  0x02, 0xeb, 0x00, 0x04, // st $lr, $zero, reloc-index ($gp)
  0x02, 0xcb, 0x00, 0x08, // st $fp, $zero, reloc-index ($gp)
  0x02, 0xdb, 0x00, 0x0c, // st $sp, $zero, reloc-index ($gp)
  0x36, 0xff, 0xff, 0xfc  // jmp dynamic_linker
};

// .plt values (other entries)
const uint8_t cpu0PltAtomContent[16] = {
  0x01, 0x6b, 0x00, 0x10, // ld $t9, 0x10($gp) (0x10($gp) point to plt0
  0x3c, 0x60, 0x00, 0x00, // ret $t9 // jump to Cpu0.Stub
  0x00, 0x00, 0x00, 0x00, // nop
  0x00, 0x00, 0x00, 0x00  // nop
};
#endif // DLINKER

/// boot record
class Cpu0BootAtom : public PLT0Atom {
public:
  Cpu0BootAtom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = ".PLT0";
#endif
  }
  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    return ArrayRef&lt;uint8_t&gt;(cpu0BootAtomContent, 16);
  }
};

#ifdef DLINKER
/// \brief Atoms that are used by Cpu0 dynamic linking
class Cpu0GOTAtom : public GOTAtom {
public:
  Cpu0GOTAtom(const File &amp;f, StringRef secName) : GOTAtom(f, secName) {}

  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    return ArrayRef&lt;uint8_t&gt;(cpu0GotAtomContent, 16);
  }
};

class Cpu0PLT0Atom : public PLT0Atom {
public:
  Cpu0PLT0Atom(const File &amp;f) : PLT0Atom(f) {
#ifndef NDEBUG
    _name = ".PLT0";
#endif
  }
  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    return ArrayRef&lt;uint8_t&gt;(cpu0Plt0AtomContent, 16);
  }
};

class Cpu0PLTAtom : public PLTAtom {
public:
  Cpu0PLTAtom(const File &amp;f, StringRef secName) : PLTAtom(f, secName) {}

  virtual ArrayRef&lt;uint8_t&gt; rawContent() const {
    return ArrayRef&lt;uint8_t&gt;(cpu0PltAtomContent, 16);
  }
};
#endif // DLINKER

class ELFPassFile : public SimpleFile {
public:
  ELFPassFile(const ELFLinkingContext &amp;eti) : SimpleFile(eti, "ELFPassFile") {
    setOrdinal(eti.getNextOrdinalAndIncrement());
  }

  llvm::BumpPtrAllocator _alloc;
};

/// \brief CRTP base for handling relocations.
template &lt;class Derived&gt; class RelocationPass : public Pass {
  /// \brief Handle a specific reference.
  void handleReference(const DefinedAtom &amp;atom, const Reference &amp;ref) {
    switch (ref.kind()) {
    case R_CPU0_CALL16:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePLT32(ref);
      break;

    case R_CPU0_PC24:
      static_cast&lt;Derived *&gt;(this)-&gt;handlePlain(ref);
      break;
    }
  }

protected:
#ifdef DLINKER
  /// \brief get the PLT entry for a given IFUNC Atom.
  ///
  /// If the entry does not exist. Both the GOT and PLT entry is created.
  const PLTAtom *getIFUNCPLTEntry(const DefinedAtom *da) {
    auto plt = _pltMap.find(da);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
    ga-&gt;addReference(R_CPU0_RELGOT, 0, da, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, ".plt");
    pa-&gt;addReference(R_CPU0_PC24, 2, ga, -4);
#ifndef NDEBUG
    ga-&gt;_name = "__got_ifunc_";
    ga-&gt;_name += da-&gt;name();
    pa-&gt;_name = "__plt_ifunc_";
    pa-&gt;_name += da-&gt;name();
#endif
    _gotMap[da] = ga;
    _pltMap[da] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }
#endif // DLINKER

  /// \brief Redirect the call to the PLT stub for the target IFUNC.
  ///
  /// This create a PLT and GOT entry for the IFUNC if one does not exist. The
  /// GOT entry and a IRELATIVE relocation to the original target resolver.
  error_code handleIFUNC(const Reference &amp;ref) {
    auto target = dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target());
#ifdef DLINKER
    if (target &amp;&amp; target-&gt;contentType() == DefinedAtom::typeResolver)
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getIFUNCPLTEntry(target));
#endif // DLINKER
    return error_code::success();
  }

#ifdef DLINKER
  /// \brief Create a GOT entry for the TP offset of a TLS atom.
  const GOTAtom *getGOTTPOFF(const Atom *atom) {
    auto got = _gotMap.find(atom);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got");
      g-&gt;addReference(R_CPU0_TLS_TPREL32, 0, atom, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_tls_";
      g-&gt;_name += atom-&gt;name();
#endif
      _gotMap[atom] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  /// \brief Create a GOT entry containing 0.
  const GOTAtom *getNullGOT() {
    if (!_null) {
      _null = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
#ifndef NDEBUG
      _null-&gt;_name = "__got_null";
#endif
    }
    return _null;
  }

  const GOTAtom *getGOT(const DefinedAtom *da) {
    auto got = _gotMap.find(da);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got");
      g-&gt;addReference(R_CPU0_32, 0, da, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_";
      g-&gt;_name += da-&gt;name();
#endif
      _gotMap[da] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }
#endif // DLINKER

public:
  RelocationPass(const ELFLinkingContext &amp;ctx)
      : _file(ctx), _ctx(ctx), _null(nullptr), _PLT0(nullptr), _got0(nullptr), 
        _boot(new Cpu0BootAtom(_file)) {}

  /// \brief Do the pass.
  ///
  /// The goal here is to first process each reference individually. Each call
  /// to handleReference may modify the reference itself and/or create new
  /// atoms which must be stored in one of the maps below.
  ///
  /// After all references are handled, the atoms created during that are all
  /// added to mf.
  virtual void perform(std::unique_ptr&lt;MutableFile&gt; &amp;mf) {
    ScopedTask task(getDefaultDomain(), "Cpu0 GOT/PLT Pass");
    // Process all references.
    for (const auto &amp;atom : mf-&gt;defined())
      for (const auto &amp;ref : *atom)
        handleReference(*atom, *ref);

    // Add all created atoms to the link.
    uint64_t ordinal = 0;
    if (_ctx.getOutputELFType() == llvm::ELF::ET_EXEC) {
      MutableFile::DefinedAtomRange atomRange = mf-&gt;definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "_Z5startv") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "not found _Z5startv\n");
      _boot-&gt;addReference(R_CPU0_PC24, 0, *it, -3);
      _boot-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_boot);
    }
#ifdef DLINKER
    if (_PLT0) {
      MutableFile::DefinedAtomRange atomRange = mf-&gt;definedAtoms();
      auto it = atomRange.begin();
      bool find = false;
      for (it = atomRange.begin(); it &lt; atomRange.end(); it++) {
        if ((*it)-&gt;name() == "_Z14dynamic_linkerv") {
          find = true;
          break;
        }
      }
      assert(find &amp;&amp; "Cannot find _Z14dynamic_linkerv()");
      _PLT0-&gt;addReference(R_CPU0_PC24, 12, *it, -3);
      _PLT0-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_PLT0);
    }
    for (auto &amp;plt : _pltVector) {
      plt-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*plt);
    }
    if (_null) {
      _null-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_null);
    }
    if (_PLT0) {
      _got0-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*_got0);
    }
    for (auto &amp;got : _gotVector) {
      got-&gt;setOrdinal(ordinal++);
      mf-&gt;addAtom(*got);
    }
#endif // DLINKER
  }

protected:
  /// \brief Owner of all the Atoms created by this pass.
  ELFPassFile _file;
  const ELFLinkingContext &amp;_ctx;

  /// \brief Map Atoms to their GOT entries.
  llvm::DenseMap&lt;const Atom *, GOTAtom *&gt; _gotMap;

  /// \brief Map Atoms to their PLT entries.
  llvm::DenseMap&lt;const Atom *, PLTAtom *&gt; _pltMap;
  /// \brief the list of GOT/PLT atoms
  std::vector&lt;GOTAtom *&gt; _gotVector;
  std::vector&lt;PLTAtom *&gt; _pltVector;
  PLT0Atom *_boot;

  /// \brief GOT entry that is always 0. Used for undefined weaks.
  GOTAtom *_null;

  /// \brief The got and plt entries for .PLT0. This is used to call into the
  /// dynamic linker for symbol resolution.
  /// @{
  PLT0Atom *_PLT0;
  GOTAtom *_got0;
  /// @}
};

/// This implements the static relocation model. Meaning GOT and PLT entries are
/// not created for references that can be directly resolved. These are
/// converted to a direct relocation. For entries that do require a GOT or PLT
/// entry, that entry is statically bound.
///
/// TLS always assumes module 1 and attempts to remove indirection.
class StaticRelocationPass LLVM_FINAL
    : public RelocationPass&lt;StaticRelocationPass&gt; {
public:
  StaticRelocationPass(const elf::Cpu0LinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  error_code handlePlain(const Reference &amp;ref) { return handleIFUNC(ref); }

  error_code handlePLT32(const Reference &amp;ref) {
    // __tls_get_addr is handled elsewhere.
    if (ref.target() &amp;&amp; ref.target()-&gt;name() == "__tls_get_addr") {
      const_cast&lt;Reference &amp;&gt;(ref).setKind(R_CPU0_NONE);
      return error_code::success();
    } else
      // Static code doesn't need PLTs.
      const_cast&lt;Reference &amp;&gt;(ref).setKind(R_CPU0_PC24);
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    return error_code::success();
  }

  error_code handleGOT(const Reference &amp;ref) {
    if (isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    return error_code::success();
  }
};

#ifdef DLINKER
class DynamicRelocationPass LLVM_FINAL
    : public RelocationPass&lt;DynamicRelocationPass&gt; {
public:
  DynamicRelocationPass(const elf::Cpu0LinkingContext &amp;ctx)
      : RelocationPass(ctx) {}

  const PLT0Atom *getPLT0() {
    if (_PLT0)
      return _PLT0;
    // Fill in the null entry.
    getNullGOT();
    _PLT0 = new (_file._alloc) Cpu0PLT0Atom(_file);
    _got0 = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
#ifndef NDEBUG
    _got0-&gt;_name = "__got0";
#endif
    return _PLT0;
  }

  const PLTAtom *getPLTEntry(const Atom *a) {
    auto plt = _pltMap.find(a);
    if (plt != _pltMap.end())
      return plt-&gt;second;
    auto ga = new (_file._alloc) Cpu0GOTAtom(_file, ".got.plt");
    ga-&gt;addReference(R_CPU0_JUMP_SLOT, 0, a, 0);
    auto pa = new (_file._alloc) Cpu0PLTAtom(_file, ".plt");
    getPLT0();  // add _PLT0 and _got0
    // Set the starting address of the got entry to the second instruction in
    // the plt entry.
    ga-&gt;addReference(R_CPU0_32, 0, pa, 4);
#ifndef NDEBUG
    ga-&gt;_name = "__got_";
    ga-&gt;_name += a-&gt;name();
    pa-&gt;_name = "__plt_";
    pa-&gt;_name += a-&gt;name();
#endif
    _gotMap[a] = ga;
    _pltMap[a] = pa;
    _gotVector.push_back(ga);
    _pltVector.push_back(pa);
    return pa;
  }
  error_code handlePlain(const Reference &amp;ref) {
    if (!ref.target())
      return error_code::success();
    if (auto sla = dyn_cast&lt;SharedLibraryAtom&gt;(ref.target())) {
      if (sla-&gt;type() == SharedLibraryAtom::Type::Code) {
        const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(sla));
        // When caller of execution file call shared library function
        // Turn this into a PC24 to the PLT entry.
        const_cast&lt;Reference &amp;&gt;(ref).setKind(R_CPU0_PC24);
      }
    } else
      return handleIFUNC(ref);
    return error_code::success();
  }

  error_code handlePLT32(const Reference &amp;ref) {
    // Handle IFUNC.
    if (const DefinedAtom *da =
            dyn_cast_or_null&lt;const DefinedAtom&gt;(ref.target()))
      if (da-&gt;contentType() == DefinedAtom::typeResolver)
        return handleIFUNC(ref);
    if (isa&lt;const SharedLibraryAtom&gt;(ref.target())) {
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getPLTEntry(ref.target()));
      // Turn this into a PC24 to the PLT entry.
    #if 1
      const_cast&lt;Reference &amp;&gt;(ref).setKind(R_CPU0_PC24);
    #endif
    }
    return error_code::success();
  }

  const GOTAtom *getSharedGOT(const SharedLibraryAtom *sla) {
    auto got = _gotMap.find(sla);
    if (got == _gotMap.end()) {
      auto g = new (_file._alloc) Cpu0GOTAtom(_file, ".got.dyn");
      g-&gt;addReference(R_CPU0_GLOB_DAT, 0, sla, 0);
#ifndef NDEBUG
      g-&gt;_name = "__got_";
      g-&gt;_name += sla-&gt;name();
#endif
      _gotMap[sla] = g;
      _gotVector.push_back(g);
      return g;
    }
    return got-&gt;second;
  }

  error_code handleGOT(const Reference &amp;ref) {
    if (isa&lt;UndefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getNullGOT());
    else if (const DefinedAtom *da = dyn_cast&lt;const DefinedAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getGOT(da));
    else if (const auto sla = dyn_cast&lt;const SharedLibraryAtom&gt;(ref.target()))
      const_cast&lt;Reference &amp;&gt;(ref).setTarget(getSharedGOT(sla));
    return error_code::success();
  }
};
#endif // DLINKER
} // end anon namespace

std::unique_ptr&lt;Pass&gt;
lld::elf::createCpu0RelocationPass(const Cpu0LinkingContext &amp;ctx) {
  switch (ctx.getOutputELFType()) {
  case llvm::ELF::ET_EXEC:
  // when the output file is execution file: e.g. a.out
#ifdef DLINKER
    if (ctx.isDynamic())
    // when the a.out refer to shared object *.so
      return std::unique_ptr&lt;Pass&gt;(new DynamicRelocationPass(ctx));
    else
#endif // DLINKER
      return std::unique_ptr&lt;Pass&gt;(new StaticRelocationPass(ctx));
#ifdef DLINKER
  case llvm::ELF::ET_DYN:
  // when the output file is shared object: e.g. foobar.so
    return std::unique_ptr&lt;Pass&gt;(new DynamicRelocationPass(ctx));
#endif // DLINKER
  case llvm::ELF::ET_REL:
    return std::unique_ptr&lt;Pass&gt;();
  default:
    llvm_unreachable("Unhandled output file type");
  }
}
</pre>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0LinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0LinkingContext.cpp -------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="cp">#include &quot;lld/Core/File.h&quot;</span>
<span class="cp">#include &quot;lld/Core/Instrumentation.h&quot;</span>

<span class="cp">#include &quot;llvm/ADT/ArrayRef.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringSwitch.h&quot;</span>

<span class="cp">#include &quot;Atoms.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationPass.h&quot;</span>


<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="p">;</span>
<span class="k">const</span> <span class="kt">uint8_t</span> <span class="n">cpu0InitFiniAtomContent</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span> <span class="mi">0</span> <span class="p">};</span>

<span class="c1">// Cpu0_64InitFini Atom</span>
<span class="k">class</span> <span class="nc">Cpu0InitAtom</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InitFiniAtom</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0InitAtom</span><span class="p">(</span><span class="k">const</span> <span class="n">File</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">function</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">InitFiniAtom</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;.init_array&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef NDEBUG</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">&quot;__init_fn_&quot;</span><span class="p">;</span>
    <span class="n">_name</span> <span class="o">+=</span> <span class="n">function</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">rawContent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cpu0InitFiniAtomContent</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">Alignment</span> <span class="n">alignment</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Alignment</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0FiniAtom</span> <span class="o">:</span> <span class="k">public</span> <span class="n">InitFiniAtom</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0FiniAtom</span><span class="p">(</span><span class="k">const</span> <span class="n">File</span> <span class="o">&amp;</span><span class="n">f</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">function</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">InitFiniAtom</span><span class="p">(</span><span class="n">f</span><span class="p">,</span> <span class="s">&quot;.fini_array&quot;</span><span class="p">)</span> <span class="p">{</span>
<span class="cp">#ifndef NDEBUG</span>
    <span class="n">_name</span> <span class="o">=</span> <span class="s">&quot;__fini_fn_&quot;</span><span class="p">;</span>
    <span class="n">_name</span> <span class="o">+=</span> <span class="n">function</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span> <span class="n">rawContent</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">ArrayRef</span><span class="o">&lt;</span><span class="kt">uint8_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">cpu0InitFiniAtomContent</span><span class="p">,</span> <span class="mi">8</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="n">Alignment</span> <span class="n">alignment</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Alignment</span><span class="p">(</span><span class="mi">3</span><span class="p">);</span> <span class="p">}</span>
<span class="p">};</span>

<span class="k">class</span> <span class="nc">Cpu0InitFiniFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0InitFiniFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="n">context</span><span class="p">,</span> <span class="s">&quot;command line option -init/-fini&quot;</span><span class="p">),</span> <span class="n">_ordinal</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span> <span class="p">{}</span>

  <span class="kt">void</span> <span class="n">addInitFunction</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Atom</span> <span class="o">*</span><span class="n">initFunctionAtom</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">SimpleUndefinedAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">Cpu0InitAtom</span> <span class="o">*</span><span class="n">initAtom</span> <span class="o">=</span>
           <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">Cpu0InitAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
    <span class="n">initAtom</span><span class="o">-&gt;</span><span class="n">addReference</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">initFunctionAtom</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">initAtom</span><span class="o">-&gt;</span><span class="n">setOrdinal</span><span class="p">(</span><span class="n">_ordinal</span><span class="o">++</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">initFunctionAtom</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">initAtom</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addFiniFunction</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">name</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Atom</span> <span class="o">*</span><span class="n">finiFunctionAtom</span> <span class="o">=</span> <span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">SimpleUndefinedAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">);</span>
    <span class="n">Cpu0FiniAtom</span> <span class="o">*</span><span class="n">finiAtom</span> <span class="o">=</span>
           <span class="p">(</span><span class="k">new</span> <span class="p">(</span><span class="n">_allocator</span><span class="p">)</span> <span class="n">Cpu0FiniAtom</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>
    <span class="n">finiAtom</span><span class="o">-&gt;</span><span class="n">addReference</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_32</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">finiFunctionAtom</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">finiAtom</span><span class="o">-&gt;</span><span class="n">setOrdinal</span><span class="p">(</span><span class="n">_ordinal</span><span class="o">++</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">finiFunctionAtom</span><span class="p">);</span>
    <span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="n">finiAtom</span><span class="p">);</span>
  <span class="p">}</span>

<span class="nl">private:</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_allocator</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">_ordinal</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end anon namespace</span>

<span class="kt">void</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">PassManager</span> <span class="o">&amp;</span><span class="n">pm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">auto</span> <span class="n">pass</span> <span class="o">=</span> <span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">pass</span><span class="p">)</span>
    <span class="n">pm</span><span class="p">.</span><span class="n">add</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">pass</span><span class="p">));</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">addPasses</span><span class="p">(</span><span class="n">pm</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">createInternalFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">createInternalFiles</span><span class="p">(</span><span class="n">result</span><span class="p">);</span>
  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Cpu0InitFiniFile</span><span class="o">&gt;</span> <span class="n">initFiniFile</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">Cpu0InitFiniFile</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ai</span> <span class="o">:</span> <span class="n">initFunctions</span><span class="p">())</span>
    <span class="n">initFiniFile</span><span class="o">-&gt;</span><span class="n">addInitFunction</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="k">auto</span> <span class="n">ai</span><span class="o">:</span><span class="n">finiFunctions</span><span class="p">())</span>
    <span class="n">initFiniFile</span><span class="o">-&gt;</span><span class="n">addFiniFunction</span><span class="p">(</span><span class="n">ai</span><span class="p">);</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">initFiniFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#define LLD_CASE(name) .Case(#name, llvm::ELF::name)</span>

<span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">Reference</span><span class="o">::</span><span class="n">Kind</span><span class="o">&gt;</span>
<span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">relocKindFromString</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">str</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="kt">int32_t</span> <span class="n">ret</span> <span class="o">=</span> <span class="n">llvm</span><span class="o">::</span><span class="n">StringSwitch</span><span class="o">&lt;</span><span class="kt">int32_t</span><span class="o">&gt;</span><span class="p">(</span><span class="n">str</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;LLD_R_CPU0_GOTRELINDEX&quot;</span><span class="p">,</span> <span class="n">LLD_R_CPU0_GOTRELINDEX</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">ret</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">YamlReaderError</span><span class="o">::</span><span class="n">illegal_value</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#undef LLD_CASE</span>

<span class="cp">#define LLD_CASE(name) case llvm::ELF::name: return std::string(#name);</span>

<span class="n">ErrorOr</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span>
<span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="o">::</span><span class="n">stringFromRelocKind</span><span class="p">(</span><span class="n">Reference</span><span class="o">::</span><span class="n">Kind</span> <span class="n">kind</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_NONE</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_32</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_HI16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LO16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GPREL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_LITERAL</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_GOT16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_PC24</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_CALL16</span><span class="p">)</span>
  <span class="n">LLD_CASE</span><span class="p">(</span><span class="n">R_CPU0_JUMP_SLOT</span><span class="p">)</span>
  <span class="k">case</span> <span class="n">LLD_R_CPU0_GOTRELINDEX</span>:
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">&quot;LLD_R_CPU0_GOTRELINDEX&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">make_error_code</span><span class="p">(</span><span class="n">YamlReaderError</span><span class="o">::</span><span class="n">illegal_value</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0Target.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0Target.h -------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0TargetHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.h ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLD_READER_WRITER_ELF_Cpu0_TARGET_HANDLER_H</span>
<span class="cp">#define LLD_READER_WRITER_ELF_Cpu0_TARGET_HANDLER_H</span>

<span class="cp">#include &quot;DefaultTargetHandler.h&quot;</span>
<span class="cp">#include &quot;File.h&quot;</span>
<span class="cp">#include &quot;Cpu0RelocationHandler.h&quot;</span>
<span class="cp">#include &quot;TargetLayout.h&quot;</span>

<span class="cp">#include &quot;lld/ReaderWriter/Simple.h&quot;</span>

<span class="cp">#include &quot;lld/Core/Atom.h&quot;</span>

<span class="cp">#define DLINKER</span>

<span class="k">namespace</span> <span class="n">lld</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">elf</span> <span class="p">{</span>
<span class="k">typedef</span> <span class="n">llvm</span><span class="o">::</span><span class="n">object</span><span class="o">::</span><span class="n">ELFType</span><span class="o">&lt;</span><span class="n">llvm</span><span class="o">::</span><span class="n">support</span><span class="o">::</span><span class="n">big</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="nb">false</span><span class="o">&gt;</span> <span class="n">Cpu0ELFType</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Cpu0LinkingContext</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0TargetHandler</span> <span class="n">LLVM_FINAL</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">targetInfo</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">targetLayout</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_targetLayout</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetRelocationHandler</span> <span class="o">&amp;</span><span class="n">getRelocationHandler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_relocationHandler</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">createImplicitFiles</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="k">class</span> <span class="nc">GOTFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SimpleFile</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="n">GOTFile</span><span class="p">(</span><span class="k">const</span> <span class="n">ELFLinkingContext</span> <span class="o">&amp;</span><span class="n">eti</span><span class="p">)</span> <span class="o">:</span> <span class="n">SimpleFile</span><span class="p">(</span><span class="n">eti</span><span class="p">,</span> <span class="s">&quot;GOTFile&quot;</span><span class="p">)</span> <span class="p">{}</span>
    <span class="n">llvm</span><span class="o">::</span><span class="n">BumpPtrAllocator</span> <span class="n">_alloc</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">GOTFile</span><span class="o">&gt;</span> <span class="n">_gotFile</span><span class="p">;</span>

  <span class="n">Cpu0TargetRelocationHandler</span> <span class="n">_relocationHandler</span><span class="p">;</span>
  <span class="n">TargetLayout</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="n">_targetLayout</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace elf</span>
<span class="p">}</span> <span class="c1">// end namespace lld</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0TargetHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===- lib/ReaderWriter/ELF/Cpu0/Cpu0TargetHandler.cpp ----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                             The LLVM Linker</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Atoms.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetHandler.h&quot;</span>
<span class="cp">#include &quot;Cpu0LinkingContext.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">lld</span><span class="p">;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">elf</span><span class="p">;</span>

<span class="kt">uint64_t</span> <span class="n">textSectionAddr</span><span class="p">;</span>

<span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DefaultTargetHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_relocationHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_targetLayout</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">bool</span> <span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">createImplicitFiles</span><span class="p">(</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">File</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">result</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">GLOBAL_OFFSET_TABLEAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">TLSGETADDRAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">_context</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">addAtom</span><span class="p">(</span><span class="o">*</span><span class="k">new</span> <span class="p">(</span><span class="n">_gotFile</span><span class="o">-&gt;</span><span class="n">_alloc</span><span class="p">)</span> <span class="n">DYNAMICAtom</span><span class="p">(</span><span class="o">*</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="n">result</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">move</span><span class="p">(</span><span class="n">_gotFile</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Above code in Cpu0 lld support both the static and dynamic link.
The &#8220;#ifdef DLINKER&#8221; is for dynamic link support. There are only just over 1
thousand of code in it. Half of the code size is for the dynamic linker.</p>
</div>
<div class="section" id="elf-to-hex">
<h2>ELF to Hex<a class="headerlink" href="#elf-to-hex" title="Permalink to this headline">¶</a></h2>
<p>Add elf2hex.h and update llvm-objdump driver to support ELF to Hex for Cpu0
backend as follows,</p>
<p class="rubric">lbdex/llvm-objdump/elf2hex.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===---------------------------- elf2hex.cpp -----------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This program is a utility that works with llvm-objdump.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">ConvertElf2Hex</span><span class="p">(</span><span class="s">&quot;elf2hex&quot;</span><span class="p">,</span> 
<span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Display the hex content of verilog cpu0 needed sections&quot;</span><span class="p">));</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">DumpSo</span><span class="p">(</span><span class="s">&quot;cpu0dumpso&quot;</span><span class="p">,</span> 
<span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Dump shared library .so&quot;</span><span class="p">));</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span>
<span class="n">LinkSo</span><span class="p">(</span><span class="s">&quot;cpu0linkso&quot;</span><span class="p">,</span> 
<span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Link shared library .so&quot;</span><span class="p">));</span>

<span class="c1">// Modified from PrintSectionHeaders()</span>
<span class="k">static</span> <span class="kt">uint64_t</span> <span class="nf">GetSectionHeaderStartAddress</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> 
  <span class="n">StringRef</span> <span class="n">sectionName</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//  outs() &lt;&lt; &quot;Sections:\n&quot;</span>
<span class="c1">//            &quot;Idx Name          Size      Address          Type\n&quot;;</span>
  <span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">section_iterator</span> <span class="n">si</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">begin_sections</span><span class="p">(),</span> <span class="n">se</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">end_sections</span><span class="p">();</span>
                                                  <span class="n">si</span> <span class="o">!=</span> <span class="n">se</span><span class="p">;</span> <span class="n">si</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">Name</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">Name</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">Address</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">Address</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">Size</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(</span><span class="n">Size</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">Text</span><span class="p">,</span> <span class="n">Data</span><span class="p">,</span> <span class="n">BSS</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">isText</span><span class="p">(</span><span class="n">Text</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">isData</span><span class="p">(</span><span class="n">Data</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">isBSS</span><span class="p">(</span><span class="n">BSS</span><span class="p">)))</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="n">sectionName</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">Address</span><span class="p">;</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Modified from PrintSymbolTable()</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">GetSymbolTableStartAddress</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">sectionName</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;SYMBOL TABLE:</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">COFFObjectFile</span> <span class="o">*</span><span class="n">coff</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">COFFObjectFile</span><span class="o">&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">))</span>
    <span class="n">PrintCOFFSymbolTable</span><span class="p">(</span><span class="n">coff</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">symbol_iterator</span> <span class="n">si</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">begin_symbols</span><span class="p">(),</span>
                         <span class="n">se</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">end_symbols</span><span class="p">();</span> <span class="n">si</span> <span class="o">!=</span> <span class="n">se</span><span class="p">;</span> <span class="n">si</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
      <span class="n">StringRef</span> <span class="n">Name</span><span class="p">;</span>
      <span class="kt">uint64_t</span> <span class="n">Address</span><span class="p">;</span>
      <span class="n">SymbolRef</span><span class="o">::</span><span class="n">Type</span> <span class="n">Type</span><span class="p">;</span>
      <span class="kt">uint64_t</span> <span class="n">Size</span><span class="p">;</span>
      <span class="kt">uint32_t</span> <span class="n">Flags</span><span class="p">;</span>
      <span class="n">section_iterator</span> <span class="n">Section</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">end_sections</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">Name</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">Address</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getFlags</span><span class="p">(</span><span class="n">Flags</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getType</span><span class="p">(</span><span class="n">Type</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(</span><span class="n">Size</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getSection</span><span class="p">(</span><span class="n">Section</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>

      <span class="kt">bool</span> <span class="n">Global</span> <span class="o">=</span> <span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">SF_Global</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">Weak</span> <span class="o">=</span> <span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">SF_Weak</span><span class="p">;</span>
      <span class="kt">bool</span> <span class="n">Absolute</span> <span class="o">=</span> <span class="n">Flags</span> <span class="o">&amp;</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">SF_Absolute</span><span class="p">;</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">Address</span> <span class="o">==</span> <span class="n">UnknownAddressOrSize</span><span class="p">)</span>
        <span class="n">Address</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Size</span> <span class="o">==</span> <span class="n">UnknownAddressOrSize</span><span class="p">)</span>
        <span class="n">Size</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">char</span> <span class="n">GlobLoc</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">!=</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">ST_Unknown</span><span class="p">)</span>
        <span class="n">GlobLoc</span> <span class="o">=</span> <span class="n">Global</span> <span class="o">?</span> <span class="sc">&#39;g&#39;</span> <span class="o">:</span> <span class="sc">&#39;l&#39;</span><span class="p">;</span>
      <span class="kt">char</span> <span class="n">Debug</span> <span class="o">=</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">ST_Debug</span> <span class="o">||</span> <span class="n">Type</span> <span class="o">==</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">ST_File</span><span class="p">)</span>
                   <span class="o">?</span> <span class="sc">&#39;d&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
      <span class="kt">char</span> <span class="n">FileFunc</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">ST_File</span><span class="p">)</span>
        <span class="n">FileFunc</span> <span class="o">=</span> <span class="sc">&#39;f&#39;</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Type</span> <span class="o">==</span> <span class="n">SymbolRef</span><span class="o">::</span><span class="n">ST_Function</span><span class="p">)</span>
        <span class="n">FileFunc</span> <span class="o">=</span> <span class="sc">&#39;F&#39;</span><span class="p">;</span>

      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Fmt</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">getBytesInAddress</span><span class="p">()</span> <span class="o">&gt;</span> <span class="mi">4</span> <span class="o">?</span> <span class="s">&quot;%016&quot;</span> <span class="n">PRIx64</span> <span class="o">:</span>
                                                     <span class="s">&quot;%08&quot;</span> <span class="n">PRIx64</span><span class="p">;</span>

      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="n">Fmt</span><span class="p">,</span> <span class="n">Address</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span>
             <span class="o">&lt;&lt;</span> <span class="n">GlobLoc</span> <span class="c1">// Local -&gt; &#39;l&#39;, Global -&gt; &#39;g&#39;, Neither -&gt; &#39; &#39;</span>
             <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">Weak</span> <span class="o">?</span> <span class="sc">&#39;w&#39;</span> <span class="o">:</span> <span class="sc">&#39; &#39;</span><span class="p">)</span> <span class="c1">// Weak?</span>
             <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="c1">// Constructor. Not supported yet.</span>
             <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="c1">// Warning. Not supported yet.</span>
             <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span> <span class="c1">// Indirect reference to another symbol.</span>
             <span class="o">&lt;&lt;</span> <span class="n">Debug</span> <span class="c1">// Debugging (d) or dynamic (D) symbol.</span>
             <span class="o">&lt;&lt;</span> <span class="n">FileFunc</span> <span class="c1">// Name of function (F), file (f) or object (O).</span>
             <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Absolute</span><span class="p">)</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*ABS*&quot;</span><span class="p">;</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Section</span> <span class="o">==</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">end_sections</span><span class="p">())</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*UND*&quot;</span><span class="p">;</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MachOObjectFile</span> <span class="o">*</span><span class="n">MachO</span> <span class="o">=</span>
            <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MachOObjectFile</span><span class="o">&gt;</span><span class="p">(</span><span class="n">o</span><span class="p">))</span> <span class="p">{</span>
          <span class="n">DataRefImpl</span> <span class="n">DR</span> <span class="o">=</span> <span class="n">Section</span><span class="o">-&gt;</span><span class="n">getRawDataRefImpl</span><span class="p">();</span>
          <span class="n">StringRef</span> <span class="n">SegmentName</span> <span class="o">=</span> <span class="n">MachO</span><span class="o">-&gt;</span><span class="n">getSectionFinalSegmentName</span><span class="p">(</span><span class="n">DR</span><span class="p">);</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">SegmentName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">StringRef</span> <span class="n">SectionName</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">Section</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">SectionName</span><span class="p">)))</span>
          <span class="n">SectionName</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">SectionName</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\t&#39;</span>
             <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%08&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">Size</span><span class="p">)</span>
             <span class="o">&lt;&lt;</span> <span class="n">Name</span>
             <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">class</span> <span class="nc">Cpu0DynFunIndex</span> <span class="p">{</span>
<span class="nl">private:</span>
  <span class="kt">char</span> <span class="n">soStrtab</span><span class="p">[</span><span class="mi">20</span><span class="p">][</span><span class="mi">100</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">soStrtabSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">char</span> <span class="n">exePltName</span><span class="p">[</span><span class="mi">20</span><span class="p">][</span><span class="mi">100</span><span class="p">];</span>
  <span class="kt">int</span> <span class="n">exePltNameSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="kt">int</span> <span class="nf">findPltName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pltName</span><span class="p">);</span>
<span class="nl">public:</span>
  <span class="kt">void</span> <span class="nf">createPltName</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">createStrtab</span><span class="p">();</span>
  <span class="kt">uint16_t</span> <span class="nf">correctDynFunIndex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pltName</span><span class="p">);</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">Cpu0DynFunIndex</span><span class="o">::</span><span class="n">findPltName</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pltName</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">exePltNameSize</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">pltName</span><span class="p">,</span> <span class="n">exePltName</span><span class="p">[</span><span class="n">i</span><span class="p">])</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="k">return</span> <span class="n">i</span><span class="p">;</span>
  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0DynFunIndex</span><span class="o">::</span><span class="n">createPltName</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Error</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">section_iterator</span> <span class="n">si</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">begin_sections</span><span class="p">(),</span>
                        <span class="n">se</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">end_sections</span><span class="p">();</span>
                        <span class="n">si</span> <span class="o">!=</span> <span class="n">se</span><span class="p">;</span> <span class="n">si</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">Name</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">Contents</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">BaseAddr</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">BSS</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">Name</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getContents</span><span class="p">(</span><span class="n">Contents</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">BaseAddr</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">isBSS</span><span class="p">(</span><span class="n">BSS</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.strtab&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int</span> <span class="n">num_dyn_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="kt">FILE</span> <span class="o">*</span><span class="n">fd_num_dyn_entry</span><span class="p">;</span>
      <span class="n">fd_num_dyn_entry</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;num_dyn_entry&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">fd_num_dyn_entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">fscanf</span><span class="p">(</span><span class="n">fd_num_dyn_entry</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_dyn_entry</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="n">fclose</span><span class="p">(</span><span class="n">fd_num_dyn_entry</span><span class="p">);</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">2</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;.PLT0&quot;</span><span class="p">),</span> <span class="n">end</span> <span class="o">=</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> 
           <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Contents</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="n">addr</span><span class="p">,</span> <span class="n">strlen</span><span class="p">(</span><span class="s">&quot;__plt_&quot;</span><span class="p">))</span> <span class="o">!=</span> <span class="s">&quot;__plt_&quot;</span><span class="p">)</span>
          <span class="k">break</span><span class="p">;</span>
        <span class="n">strcpy</span><span class="p">(</span><span class="n">exePltName</span><span class="p">[</span><span class="n">exePltNameSize</span><span class="p">],</span> <span class="n">Contents</span><span class="p">.</span><span class="n">data</span><span class="p">()</span><span class="o">+</span><span class="n">addr</span><span class="p">);</span>
        <span class="n">addr</span> <span class="o">=</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">strlen</span><span class="p">(</span><span class="n">exePltName</span><span class="p">[</span><span class="n">exePltNameSize</span><span class="p">])</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
        <span class="n">exePltNameSize</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0DynFunIndex</span><span class="o">::</span><span class="n">createStrtab</span><span class="p">()</span> <span class="p">{</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fd_dynstrAscii</span><span class="p">;</span>

  <span class="n">fd_dynstrAscii</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;dynstrAscii&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">fd_dynstrAscii</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fd_dynstrAscii</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">fd_dynstrAscii</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;fd_dynstr == NULL&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// function                  result on EOF or error                    </span>
  <span class="c1">// --------                  ----------------------</span>
  <span class="c1">// fgets()                   NULL</span>
  <span class="c1">// fscanf()                  number of succesful conversions</span>
  <span class="c1">//                             less than expected</span>
  <span class="c1">// fgetc()                   EOF</span>
  <span class="c1">// fread()                   number of elements read</span>
  <span class="c1">//                             less than expected</span>
  <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="mi">1</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">j</span><span class="o">=</span><span class="n">fscanf</span><span class="p">(</span><span class="n">fd_dynstrAscii</span><span class="p">,</span> <span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">soStrtab</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">!=</span> <span class="mi">1</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">soStrtabSize</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>
  <span class="n">fclose</span><span class="p">(</span><span class="n">fd_dynstrAscii</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">uint16_t</span> <span class="n">Cpu0DynFunIndex</span><span class="o">::</span><span class="n">correctDynFunIndex</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span> <span class="n">pltName</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">findPltName</span><span class="p">(</span><span class="n">pltName</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">int</span> <span class="n">j</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">j</span> <span class="o">&lt;</span> <span class="n">soStrtabSize</span><span class="p">;</span> <span class="n">j</span><span class="o">++</span><span class="p">)</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">strcmp</span><span class="p">(</span><span class="n">soStrtab</span><span class="p">[</span><span class="n">j</span><span class="p">],</span> <span class="p">(</span><span class="k">const</span> <span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">exePltName</span><span class="p">[</span><span class="n">i</span><span class="p">]</span><span class="o">+</span><span class="n">strlen</span><span class="p">(</span><span class="s">&quot;__plt_&quot;</span><span class="p">))</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">j</span> <span class="o">==</span> <span class="n">soStrtabSize</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;cannot find &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">exePltName</span><span class="p">[</span><span class="n">i</span><span class="p">]</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="n">exit</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">j</span><span class="o">++</span><span class="p">;</span>
    <span class="k">return</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)(</span><span class="n">j</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="p">(</span><span class="kt">uint16_t</span><span class="p">)</span><span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0DynFunIndex</span> <span class="n">cpu0DynFunIndex</span><span class="p">;</span>

<span class="c1">// Modified from DisassembleObject()</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">DisassembleObjectInHexFormat</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">Obj</span>
<span class="cm">/*, bool InlineRelocs*/</span>  <span class="p">,</span> <span class="kt">uint64_t</span><span class="o">&amp;</span> <span class="n">lastDumpAddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Error</span><span class="p">;</span>
  <span class="kt">uint64_t</span> <span class="n">soLastPrintAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">FILE</span> <span class="o">*</span><span class="n">fd_so_func_offset</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">num_dyn_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">fd_so_func_offset</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;so_func_offset&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd_so_func_offset</span> <span class="o">==</span> <span class="nb">NULL</span><span class="p">)</span>
      <span class="n">fclose</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">fd_so_func_offset</span> <span class="o">!=</span> <span class="nb">NULL</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;fd_so_func_offset == NULL&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LinkSo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cpu0DynFunIndex</span><span class="p">.</span><span class="n">createStrtab</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">Target</span> <span class="o">*</span><span class="n">TheTarget</span> <span class="o">=</span> <span class="n">getTarget</span><span class="p">(</span><span class="n">Obj</span><span class="p">);</span>
  <span class="c1">// getTarget() will have already issued a diagnostic if necessary, so</span>
  <span class="c1">// just bail here if it failed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">TheTarget</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Package up features to be passed to target/subtarget</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">FeaturesStr</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MAttrs</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SubtargetFeatures</span> <span class="n">Features</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">MAttrs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="n">Features</span><span class="p">.</span><span class="n">AddFeature</span><span class="p">(</span><span class="n">MAttrs</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
    <span class="n">FeaturesStr</span> <span class="o">=</span> <span class="n">Features</span><span class="p">.</span><span class="n">getString</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCRegisterInfo</span><span class="o">&gt;</span> <span class="n">MRI</span><span class="p">(</span><span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCRegInfo</span><span class="p">(</span><span class="n">TripleName</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MRI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error: no register info for target &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TripleName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Set up disassembler.</span>
  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCAsmInfo</span><span class="o">&gt;</span> <span class="n">AsmInfo</span><span class="p">(</span>
    <span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCAsmInfo</span><span class="p">(</span><span class="o">*</span><span class="n">MRI</span><span class="p">,</span> <span class="n">TripleName</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">AsmInfo</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error: no assembly info for target &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TripleName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCSubtargetInfo</span><span class="o">&gt;</span> <span class="n">STI</span><span class="p">(</span>
    <span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCSubtargetInfo</span><span class="p">(</span><span class="n">TripleName</span><span class="p">,</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="n">FeaturesStr</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error: no subtarget info for target &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TripleName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCInstrInfo</span><span class="o">&gt;</span> <span class="n">MII</span><span class="p">(</span><span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCInstrInfo</span><span class="p">());</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MII</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error: no instruction info for target &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TripleName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCDisassembler</span><span class="o">&gt;</span> <span class="n">DisAsm</span><span class="p">(</span><span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCDisassembler</span><span class="p">(</span><span class="o">*</span><span class="n">STI</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DisAsm</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error: no disassembler for target &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TripleName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCObjectFileInfo</span><span class="o">&gt;</span> <span class="n">MOFI</span><span class="p">;</span>
  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCContext</span><span class="o">&gt;</span> <span class="n">Ctx</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Symbolize</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MOFI</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">MCObjectFileInfo</span><span class="p">);</span>
    <span class="n">Ctx</span><span class="p">.</span><span class="n">reset</span><span class="p">(</span><span class="k">new</span> <span class="n">MCContext</span><span class="p">(</span><span class="n">AsmInfo</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">MRI</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">MOFI</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
    <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCRelocationInfo</span><span class="o">&gt;</span> <span class="n">RelInfo</span><span class="p">(</span>
      <span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCRelocationInfo</span><span class="p">(</span><span class="n">TripleName</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">RelInfo</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCSymbolizer</span><span class="o">&gt;</span> <span class="n">Symzer</span><span class="p">(</span>
        <span class="n">MCObjectSymbolizer</span><span class="o">::</span><span class="n">createObjectSymbolizer</span><span class="p">(</span><span class="o">*</span><span class="n">Ctx</span><span class="p">.</span><span class="n">get</span><span class="p">(),</span> <span class="n">RelInfo</span><span class="p">,</span> <span class="n">Obj</span><span class="p">));</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Symzer</span><span class="p">)</span>
        <span class="n">DisAsm</span><span class="o">-&gt;</span><span class="n">setSymbolizer</span><span class="p">(</span><span class="n">Symzer</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MCInstrAnalysis</span><span class="o">&gt;</span>
    <span class="n">MIA</span><span class="p">(</span><span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCInstrAnalysis</span><span class="p">(</span><span class="n">MII</span><span class="p">.</span><span class="n">get</span><span class="p">()));</span>

  <span class="kt">int</span> <span class="n">AsmPrinterVariant</span> <span class="o">=</span> <span class="n">AsmInfo</span><span class="o">-&gt;</span><span class="n">getAssemblerDialect</span><span class="p">();</span>
  <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCInstPrinter</span><span class="o">&gt;</span> <span class="n">IP</span><span class="p">(</span><span class="n">TheTarget</span><span class="o">-&gt;</span><span class="n">createMCInstPrinter</span><span class="p">(</span>
      <span class="n">AsmPrinterVariant</span><span class="p">,</span> <span class="o">*</span><span class="n">AsmInfo</span><span class="p">,</span> <span class="o">*</span><span class="n">MII</span><span class="p">,</span> <span class="o">*</span><span class="n">MRI</span><span class="p">,</span> <span class="o">*</span><span class="n">STI</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IP</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;error: no instruction printer for target &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">TripleName</span>
      <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CFG</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCObjectDisassembler</span><span class="o">&gt;</span> <span class="n">OD</span><span class="p">(</span>
      <span class="k">new</span> <span class="n">MCObjectDisassembler</span><span class="p">(</span><span class="o">*</span><span class="n">Obj</span><span class="p">,</span> <span class="o">*</span><span class="n">DisAsm</span><span class="p">,</span> <span class="o">*</span><span class="n">MIA</span><span class="p">));</span>
    <span class="n">OwningPtr</span><span class="o">&lt;</span><span class="n">MCModule</span><span class="o">&gt;</span> <span class="n">Mod</span><span class="p">(</span><span class="n">OD</span><span class="o">-&gt;</span><span class="n">buildModule</span><span class="p">(</span><span class="cm">/* withCFG */</span> <span class="nb">true</span><span class="p">));</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MCModule</span><span class="o">::</span><span class="n">const_atom_iterator</span> <span class="n">AI</span> <span class="o">=</span> <span class="n">Mod</span><span class="o">-&gt;</span><span class="n">atom_begin</span><span class="p">(),</span>
                                       <span class="n">AE</span> <span class="o">=</span> <span class="n">Mod</span><span class="o">-&gt;</span><span class="n">atom_end</span><span class="p">();</span>
                                       <span class="n">AI</span> <span class="o">!=</span> <span class="n">AE</span><span class="p">;</span> <span class="o">++</span><span class="n">AI</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Atom &quot;</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="o">*</span><span class="n">AI</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: </span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCTextAtom</span> <span class="o">*</span><span class="n">TA</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCTextAtom</span><span class="o">&gt;</span><span class="p">(</span><span class="o">*</span><span class="n">AI</span><span class="p">))</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">MCTextAtom</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">II</span> <span class="o">=</span> <span class="n">TA</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">IE</span> <span class="o">=</span> <span class="n">TA</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">();</span>
             <span class="n">II</span> <span class="o">!=</span> <span class="n">IE</span><span class="p">;</span>
             <span class="o">++</span><span class="n">II</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">IP</span><span class="o">-&gt;</span><span class="n">printInst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">II</span><span class="o">-&gt;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">outs</span><span class="p">(),</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">MCModule</span><span class="o">::</span><span class="n">const_func_iterator</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">Mod</span><span class="o">-&gt;</span><span class="n">func_begin</span><span class="p">(),</span>
                                       <span class="n">FE</span> <span class="o">=</span> <span class="n">Mod</span><span class="o">-&gt;</span><span class="n">func_end</span><span class="p">();</span>
                                       <span class="n">FI</span> <span class="o">!=</span> <span class="n">FE</span><span class="p">;</span> <span class="o">++</span><span class="n">FI</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">static</span> <span class="kt">int</span> <span class="n">filenum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="n">emitDOTFile</span><span class="p">((</span><span class="n">Twine</span><span class="p">((</span><span class="o">*</span><span class="n">FI</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">())</span> <span class="o">+</span> <span class="s">&quot;_&quot;</span> <span class="o">+</span>
                   <span class="n">utostr</span><span class="p">(</span><span class="n">filenum</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;.dot&quot;</span><span class="p">).</span><span class="n">str</span><span class="p">().</span><span class="n">c_str</span><span class="p">(),</span>
                    <span class="o">**</span><span class="n">FI</span><span class="p">,</span> <span class="n">IP</span><span class="p">.</span><span class="n">get</span><span class="p">());</span>
      <span class="o">++</span><span class="n">filenum</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>


  <span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">section_iterator</span> <span class="n">i</span> <span class="o">=</span> <span class="n">Obj</span><span class="o">-&gt;</span><span class="n">begin_sections</span><span class="p">(),</span>
                        <span class="n">e</span> <span class="o">=</span> <span class="n">Obj</span><span class="o">-&gt;</span><span class="n">end_sections</span><span class="p">();</span>
                        <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="n">i</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="k">break</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">text</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">isText</span><span class="p">(</span><span class="n">text</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">text</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>

    <span class="kt">uint64_t</span> <span class="n">SectionAddr</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">SectionAddr</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>

    <span class="c1">// Make a list of all the symbols in this section.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">StringRef</span><span class="o">&gt;</span> <span class="o">&gt;</span> <span class="n">Symbols</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">symbol_iterator</span> <span class="n">si</span> <span class="o">=</span> <span class="n">Obj</span><span class="o">-&gt;</span><span class="n">begin_symbols</span><span class="p">(),</span>
                         <span class="n">se</span> <span class="o">=</span> <span class="n">Obj</span><span class="o">-&gt;</span><span class="n">end_symbols</span><span class="p">();</span>
                         <span class="n">si</span> <span class="o">!=</span> <span class="n">se</span><span class="p">;</span> <span class="n">si</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">contains</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">error</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">containsSymbol</span><span class="p">(</span><span class="o">*</span><span class="n">si</span><span class="p">,</span> <span class="n">contains</span><span class="p">))</span> <span class="o">&amp;&amp;</span> <span class="n">contains</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">Address</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">Address</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">Address</span> <span class="o">==</span> <span class="n">UnknownAddressOrSize</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
        <span class="n">Address</span> <span class="o">-=</span> <span class="n">SectionAddr</span><span class="p">;</span>

        <span class="n">StringRef</span> <span class="n">Name</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">Name</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>
        <span class="n">Symbols</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">Address</span><span class="p">,</span> <span class="n">Name</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>

    <span class="c1">// Sort the symbols by address, just in case they didn&#39;t come in that way.</span>
    <span class="n">array_pod_sort</span><span class="p">(</span><span class="n">Symbols</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Symbols</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>

    <span class="c1">// Make a list of all the relocations for this section.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RelocationRef</span><span class="o">&gt;</span> <span class="n">Rels</span><span class="p">;</span>
<span class="cm">/*    if (InlineRelocs) {</span>
<span class="cm">      for (relocation_iterator ri = i-&gt;begin_relocations(),</span>
<span class="cm">                               re = i-&gt;end_relocations();</span>
<span class="cm">                               ri != re; ri.increment(ec)) {</span>
<span class="cm">        if (error(ec)) break;</span>
<span class="cm">        Rels.push_back(*ri);</span>
<span class="cm">      }</span>
<span class="cm">    }*/</span>

    <span class="c1">// Sort relocations by address.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">sort</span><span class="p">(</span><span class="n">Rels</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">Rels</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">RelocAddressLess</span><span class="p">);</span>

    <span class="n">StringRef</span> <span class="n">SegmentName</span> <span class="o">=</span> <span class="s">&quot;&quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MachOObjectFile</span> <span class="o">*</span><span class="n">MachO</span> <span class="o">=</span>
        <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">MachOObjectFile</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Obj</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">DataRefImpl</span> <span class="n">DR</span> <span class="o">=</span> <span class="n">i</span><span class="o">-&gt;</span><span class="n">getRawDataRefImpl</span><span class="p">();</span>
      <span class="n">SegmentName</span> <span class="o">=</span> <span class="n">MachO</span><span class="o">-&gt;</span><span class="n">getSectionFinalSegmentName</span><span class="p">(</span><span class="n">DR</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">StringRef</span> <span class="n">name</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span> <span class="o">&amp;&amp;</span> <span class="n">name</span> <span class="o">==</span> <span class="s">&quot;.plt&quot;</span><span class="p">)</span> <span class="k">continue</span><span class="p">;</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Disassembly of section &quot;</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">SegmentName</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">SegmentName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;,&quot;</span><span class="p">;</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">name</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;:&#39;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*/&quot;</span><span class="p">;</span>

    <span class="c1">// If the section has no symbols just insert a dummy one and disassemble</span>
    <span class="c1">// the whole section.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Symbols</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">Symbols</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">name</span><span class="p">));</span>

    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">40</span><span class="o">&gt;</span> <span class="n">Comments</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="n">CommentStream</span><span class="p">(</span><span class="n">Comments</span><span class="p">);</span>

    <span class="n">StringRef</span> <span class="n">Bytes</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">getContents</span><span class="p">(</span><span class="n">Bytes</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>
    <span class="n">StringRefMemoryObject</span> <span class="n">memoryObject</span><span class="p">(</span><span class="n">Bytes</span><span class="p">,</span> <span class="n">SectionAddr</span><span class="p">);</span>
    <span class="kt">uint64_t</span> <span class="n">Size</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">Index</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">SectSize</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">i</span><span class="o">-&gt;</span><span class="n">getSize</span><span class="p">(</span><span class="n">SectSize</span><span class="p">)))</span> <span class="k">break</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RelocationRef</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">rel_cur</span> <span class="o">=</span> <span class="n">Rels</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">RelocationRef</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">rel_end</span> <span class="o">=</span> <span class="n">Rels</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
    <span class="c1">// Disassemble symbol by symbol.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">si</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">se</span> <span class="o">=</span> <span class="n">Symbols</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">si</span> <span class="o">!=</span> <span class="n">se</span><span class="p">;</span> <span class="o">++</span><span class="n">si</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">uint64_t</span> <span class="n">Start</span> <span class="o">=</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
      <span class="kt">uint64_t</span> <span class="n">End</span><span class="p">;</span>
      <span class="c1">// The end is either the size of the section or the beginning of the next</span>
      <span class="c1">// symbol.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">si</span> <span class="o">==</span> <span class="n">se</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span>
        <span class="n">End</span> <span class="o">=</span> <span class="n">SectSize</span><span class="p">;</span>
      <span class="c1">// Make sure this symbol takes up space.</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">first</span> <span class="o">!=</span> <span class="n">Start</span><span class="p">)</span>
        <span class="n">End</span> <span class="o">=</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span> <span class="o">+</span> <span class="mi">1</span><span class="p">].</span><span class="n">first</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="c1">// This symbol has the same address as the next symbol. Skip it.</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="cm">/* &amp;&amp; Symbols[si].second != &quot;__tls_get_addr&quot;*/</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> 
                  <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">));</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> 
                  <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> 
                  <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x    &quot;</span><span class="p">,</span> 
                  <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
          <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">strSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">strSize</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">strSize</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%c%c &quot;</span><span class="p">,</span> 
                    <span class="n">hexdigit</span><span class="p">((</span><span class="n">str</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
                    <span class="n">hexdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">));</span>
          <span class="p">}</span>
          <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">strSize</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
            <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
          <span class="p">}</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;/* %s */</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
          <span class="n">num_dyn_entry</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>

        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:*/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">soLastPrintAddr</span> <span class="o">=</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span><span class="p">;</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">));</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> 
                <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> 
                <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x    &quot;</span><span class="p">,</span> 
                <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
        <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">strSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">strSize</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">strSize</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%c%c &quot;</span><span class="p">,</span> 
                  <span class="n">hexdigit</span><span class="p">((</span><span class="n">str</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span> 
                  <span class="n">hexdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">));</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">strSize</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;/* %s */</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
        <span class="n">num_dyn_entry</span><span class="o">++</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:*/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="kt">uint16_t</span> <span class="n">funIndex</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">LinkSo</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// correctDynFunIndex</span>
        <span class="n">funIndex</span> <span class="o">=</span> <span class="n">cpu0DynFunIndex</span><span class="p">.</span><span class="n">correctDynFunIndex</span><span class="p">(</span><span class="n">Symbols</span><span class="p">[</span><span class="n">si</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">data</span><span class="p">());</span>
      <span class="p">}</span>

<span class="cp">#ifndef NDEBUG</span>
        <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">DebugOut</span> <span class="o">=</span> <span class="n">DebugFlag</span> <span class="o">?</span> <span class="n">dbgs</span><span class="p">()</span> <span class="o">:</span> <span class="n">nulls</span><span class="p">();</span>
<span class="cp">#else</span>
        <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">DebugOut</span> <span class="o">=</span> <span class="n">nulls</span><span class="p">();</span>
<span class="cp">#endif</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">Index</span> <span class="o">=</span> <span class="n">Start</span><span class="p">;</span> <span class="n">Index</span> <span class="o">&lt;</span> <span class="n">End</span><span class="p">;</span> <span class="n">Index</span> <span class="o">+=</span> <span class="n">Size</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="n">LinkSo</span> <span class="o">&amp;&amp;</span> <span class="n">funIndex</span> <span class="o">&amp;&amp;</span> <span class="n">Index</span> <span class="o">==</span> <span class="n">Start</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%8&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;:*/</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">,</span> <span class="cm">/*SectionAddr + */</span><span class="n">lastDumpAddr</span><span class="o">+</span><span class="n">Index</span><span class="p">);</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;01 6b &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span><span class="p">,</span> <span class="p">(</span><span class="n">funIndex</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xff00</span><span class="p">)</span>
                  <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot; %02&quot;</span> <span class="n">PRIx64</span><span class="p">,</span> <span class="p">(</span><span class="n">funIndex</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0x00ff</span><span class="p">);</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;                                  /* ld</span><span class="se">\t</span><span class="s">$t9, &quot;</span> 
                 <span class="o">&lt;&lt;</span> <span class="n">funIndex</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="mi">16</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;($gp)</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">else</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">DisAsm</span><span class="o">-&gt;</span><span class="n">getInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">memoryObject</span><span class="p">,</span>
                                     <span class="n">SectionAddr</span> <span class="o">+</span> <span class="n">Index</span><span class="p">,</span>
                                     <span class="n">DebugOut</span><span class="p">,</span> <span class="n">CommentStream</span><span class="p">))</span> <span class="p">{</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%8&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;:*/&quot;</span><span class="p">,</span> <span class="cm">/*SectionAddr + */</span><span class="n">lastDumpAddr</span><span class="o">+</span><span class="n">Index</span><span class="p">);</span>
            <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">NoShowRawInsn</span><span class="p">)</span> <span class="p">{</span>
              <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
              <span class="n">DumpBytes</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="n">Bytes</span><span class="p">.</span><span class="n">data</span><span class="p">()</span> <span class="o">+</span> <span class="n">Index</span><span class="p">,</span> <span class="n">Size</span><span class="p">));</span>
            <span class="p">}</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span><span class="p">;</span>
            <span class="n">IP</span><span class="o">-&gt;</span><span class="n">printInst</span><span class="p">(</span><span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">outs</span><span class="p">(),</span> <span class="s">&quot;&quot;</span><span class="p">);</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">CommentStream</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*/&quot;</span><span class="p">;</span>
            <span class="n">Comments</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
          <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
            <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">ToolName</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;: warning: invalid instruction encoding</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
            <span class="k">if</span> <span class="p">(</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
              <span class="n">Size</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span> <span class="c1">// skip illegible bytes</span>
          <span class="p">}</span>
        <span class="p">}</span>

        <span class="c1">//  outs() &lt;&lt; &quot;Size = &quot; &lt;&lt; Size &lt;&lt;  &quot;Index = &quot; &lt;&lt; Index &lt;&lt; &quot;lastDumpAddr = &quot;</span>
        <span class="c1">//         &lt;&lt; lastDumpAddr &lt;&lt; &quot;\n&quot;; // debug</span>
        <span class="c1">// Print relocation for instruction.</span>
        <span class="k">while</span> <span class="p">(</span><span class="n">rel_cur</span> <span class="o">!=</span> <span class="n">rel_end</span><span class="p">)</span> <span class="p">{</span>
          <span class="kt">bool</span> <span class="n">hidden</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
          <span class="kt">uint64_t</span> <span class="n">addr</span><span class="p">;</span>
          <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">name</span><span class="p">;</span>
          <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span> <span class="n">val</span><span class="p">;</span>

          <span class="c1">// If this relocation is hidden, skip it.</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">rel_cur</span><span class="o">-&gt;</span><span class="n">getHidden</span><span class="p">(</span><span class="n">hidden</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">skip_print_rel</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">hidden</span><span class="p">)</span> <span class="k">goto</span> <span class="n">skip_print_rel</span><span class="p">;</span>

          <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">rel_cur</span><span class="o">-&gt;</span><span class="n">getOffset</span><span class="p">(</span><span class="n">addr</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">skip_print_rel</span><span class="p">;</span>
          <span class="c1">// Stop when rel_cur&#39;s address is past the current instruction.</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">&gt;=</span> <span class="n">Index</span> <span class="o">+</span> <span class="n">Size</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">rel_cur</span><span class="o">-&gt;</span><span class="n">getTypeName</span><span class="p">(</span><span class="n">name</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">skip_print_rel</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">rel_cur</span><span class="o">-&gt;</span><span class="n">getValueString</span><span class="p">(</span><span class="n">val</span><span class="p">)))</span> <span class="k">goto</span> <span class="n">skip_print_rel</span><span class="p">;</span>

          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t\t\t</span><span class="s">/*%8&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;: &quot;</span><span class="p">,</span> <span class="n">SectionAddr</span> <span class="o">+</span> <span class="n">addr</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">name</span>
                 <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">val</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>

        <span class="nl">skip_print_rel:</span>
          <span class="o">++</span><span class="n">rel_cur</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="p">)</span>
        <span class="n">soLastPrintAddr</span> <span class="o">=</span> <span class="n">End</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">lastDumpAddr</span> <span class="o">+=</span> <span class="n">Index</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">// Fix the issue that __tls_get_addr appear as file offset 0.</span>
<span class="c1">// Old lld version the __tls_get_addr appear at the last function name.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">uint64_t</span><span class="p">,</span> <span class="n">StringRef</span><span class="o">&gt;</span> <span class="n">dummy</span><span class="p">(</span><span class="n">soLastPrintAddr</span><span class="p">,</span> <span class="s">&quot;dummy&quot;</span><span class="p">);</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)(</span><span class="n">dummy</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">dummy</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">dummy</span><span class="p">.</span><span class="n">first</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x    &quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">uint8_t</span><span class="p">)((</span><span class="n">dummy</span><span class="p">.</span><span class="n">first</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">));</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span> <span class="o">=</span> <span class="n">dummy</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">strSize</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">strSize</span> <span class="o">=</span> <span class="n">str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="n">strSize</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%c%c &quot;</span><span class="p">,</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">str</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
              <span class="p">,</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">str</span><span class="p">[</span><span class="n">idx</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">));</span>
    <span class="p">}</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">idx</span> <span class="o">=</span> <span class="n">strSize</span><span class="p">;</span> <span class="n">idx</span> <span class="o">&lt;</span> <span class="mi">48</span><span class="p">;</span> <span class="n">idx</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;%02x &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_so_func_offset</span><span class="p">,</span> <span class="s">&quot;/* %s */</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dummy</span><span class="p">.</span><span class="n">second</span><span class="p">.</span><span class="n">begin</span><span class="p">());</span>
    <span class="n">num_dyn_entry</span><span class="o">++</span><span class="p">;</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">dummy</span><span class="p">.</span><span class="n">second</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:*/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">FILE</span> <span class="o">*</span><span class="n">fd_num_dyn_entry</span><span class="p">;</span>
    <span class="n">fd_num_dyn_entry</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;num_dyn_entry&quot;</span><span class="p">,</span> <span class="s">&quot;w&quot;</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">fd_num_dyn_entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">fprintf</span><span class="p">(</span><span class="n">fd_num_dyn_entry</span><span class="p">,</span> <span class="s">&quot;%d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">num_dyn_entry</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">fclose</span><span class="p">(</span><span class="n">fd_num_dyn_entry</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="cp">#define DYNSYM_LIB_OFFSET 9</span>

<span class="c1">// Modified from PrintSectionContents()</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">PrintDataSections</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">lastDumpAddr</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">error_code</span> <span class="n">ec</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">addr</span><span class="p">,</span> <span class="n">end</span><span class="p">;</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Error</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">section_iterator</span> <span class="n">si</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">begin_sections</span><span class="p">(),</span>
                        <span class="n">se</span> <span class="o">=</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">end_sections</span><span class="p">();</span>
                        <span class="n">si</span> <span class="o">!=</span> <span class="n">se</span><span class="p">;</span> <span class="n">si</span><span class="p">.</span><span class="n">increment</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">ec</span><span class="p">))</span> <span class="k">return</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">Name</span><span class="p">;</span>
    <span class="n">StringRef</span> <span class="n">Contents</span><span class="p">;</span>
    <span class="kt">uint64_t</span> <span class="n">BaseAddr</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">BSS</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">(</span><span class="n">Name</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getContents</span><span class="p">(</span><span class="n">Contents</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">BaseAddr</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">isBSS</span><span class="p">(</span><span class="n">BSS</span><span class="p">)))</span> <span class="k">continue</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.rodata&quot;</span> <span class="o">||</span> <span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.rodata1&quot;</span> <span class="o">||</span> <span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.data&quot;</span> <span class="o">||</span> 
      <span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.data1&quot;</span> <span class="o">||</span> <span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.sdata&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Fill /*address*/ 00 00 00 00 between lastDumpAddr( = the address of last</span>
      <span class="c1">// end section + 1) and BaseAddr</span>
      <span class="kt">uint64_t</span> <span class="n">cellingLastAddr4</span> <span class="o">=</span> <span class="p">((</span><span class="n">lastDumpAddr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
      <span class="n">assert</span><span class="p">((</span><span class="n">lastDumpAddr</span> <span class="o">&lt;=</span> <span class="n">BaseAddr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;lastDumpAddr must &lt;= BaseAddr&quot;</span><span class="p">);</span>
      <span class="c1">// Fill /*address*/ bytes is odd for 4 by 00 </span>
      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%04&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; */&quot;</span><span class="p">,</span> <span class="n">lastDumpAddr</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cellingLastAddr4</span> <span class="o">&gt;</span> <span class="n">BaseAddr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastDumpAddr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BaseAddr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;00 &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="n">BaseAddr</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastDumpAddr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cellingLastAddr4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;00 &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="n">cellingLastAddr4</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Fill /*address*/ 00 00 00 00 for 4 bytes (1 Cpu0 word size)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">lastDumpAddr</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">BaseAddr</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%04&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; */&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> \
        <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*Contents of section &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:*/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="c1">// Dump out the content as hex and printable ascii characters.</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%04&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; */&quot;</span><span class="p">,</span> <span class="n">BaseAddr</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
        <span class="c1">// Dump line of hex.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
                   <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="c1">// Print ascii.</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;  &quot;</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span> <span class="o">&amp;&amp;</span> <span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">isprint</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span> <span class="kt">char</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">])</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">))</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">Contents</span><span class="p">[</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span><span class="p">];</span>
          <span class="k">else</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;.&quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*/&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// save the end address of this section to lastDumpAddr</span>
      <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="n">BaseAddr</span> <span class="o">+</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.bss&quot;</span> <span class="o">||</span> <span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.sbss&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Fill /*address*/ 00 00 00 00 between lastDumpAddr( = the address of last</span>
      <span class="c1">// end section + 1) and BaseAddr</span>
      <span class="kt">uint64_t</span> <span class="n">cellingLastAddr4</span> <span class="o">=</span> <span class="p">((</span><span class="n">lastDumpAddr</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">)</span> <span class="o">*</span> <span class="mi">4</span><span class="p">;</span>
      <span class="n">assert</span><span class="p">((</span><span class="n">lastDumpAddr</span> <span class="o">&lt;=</span> <span class="n">BaseAddr</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;lastDumpAddr must &lt;= BaseAddr&quot;</span><span class="p">);</span>
      <span class="c1">// Fill /*address*/ bytes is odd for 4 by 00 </span>
      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%04&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; */&quot;</span><span class="p">,</span> <span class="n">lastDumpAddr</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">cellingLastAddr4</span> <span class="o">&gt;</span> <span class="n">BaseAddr</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastDumpAddr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">BaseAddr</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;00 &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="n">BaseAddr</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="p">{</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="n">lastDumpAddr</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">cellingLastAddr4</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;00 &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="n">cellingLastAddr4</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// Fill /*address*/ 00 00 00 00 for 4 bytes (1 Cpu0 word size)</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">addr</span> <span class="o">=</span> <span class="n">lastDumpAddr</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">BaseAddr</span><span class="p">;</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="mi">4</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%04&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; */&quot;</span><span class="p">,</span> <span class="n">addr</span><span class="p">);</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> \
        <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*Contents of section &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Name</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;:*/</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="c1">// Dump out the content as hex and printable ascii characters.</span>
      <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;/*%04&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; */&quot;</span><span class="p">,</span> <span class="n">BaseAddr</span> <span class="o">+</span> <span class="n">addr</span><span class="p">);</span>
        <span class="c1">// Dump line of hex.</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">!=</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">%</span> <span class="mi">4</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">+</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">)</span>
            <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;00 &quot;</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="c1">// save the end address of this section to lastDumpAddr</span>
      <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="n">BaseAddr</span> <span class="o">+</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">DumpSo</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.dynsym&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">int</span> <span class="n">num_dyn_entry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="kt">FILE</span> <span class="o">*</span><span class="n">fd_num_dyn_entry</span><span class="p">;</span>
        <span class="n">fd_num_dyn_entry</span> <span class="o">=</span> <span class="n">fopen</span><span class="p">(</span><span class="s">&quot;num_dyn_entry&quot;</span><span class="p">,</span> <span class="s">&quot;r&quot;</span><span class="p">);</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">fd_num_dyn_entry</span> <span class="o">!=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fscanf</span><span class="p">(</span><span class="n">fd_num_dyn_entry</span><span class="p">,</span> <span class="s">&quot;%d&quot;</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">num_dyn_entry</span><span class="p">);</span>
        <span class="p">}</span>
        <span class="n">fclose</span><span class="p">(</span><span class="n">fd_num_dyn_entry</span><span class="p">);</span>
        <span class="n">raw_fd_ostream</span> <span class="n">fd_dynsym</span><span class="p">(</span><span class="s">&quot;dynsym&quot;</span><span class="p">,</span> <span class="n">Error</span><span class="p">);</span>
        <span class="kt">int</span> <span class="n">count</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span> <span class="o">+=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fd_dynsym</span> <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
                     <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
          <span class="n">fd_dynsym</span> <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
                     <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="o">+</span><span class="mi">1</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
          <span class="n">fd_dynsym</span> <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
                     <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="o">+</span><span class="mi">2</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
          <span class="n">fd_dynsym</span> <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
                     <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="o">+</span><span class="mi">3</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
          <span class="n">count</span><span class="o">++</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">count</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">num_dyn_entry</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fd_dynsym</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;00 00 00 00 &quot;</span><span class="p">;</span>
        <span class="p">}</span>
      <span class="p">}</span>
      <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.dynstr&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">raw_fd_ostream</span> <span class="n">fd_dynstr</span><span class="p">(</span><span class="s">&quot;dynstr&quot;</span><span class="p">,</span> <span class="n">Error</span><span class="p">);</span>
        <span class="n">raw_fd_ostream</span> <span class="n">fd_dynstrAscii</span><span class="p">(</span><span class="s">&quot;dynstrAscii&quot;</span><span class="p">,</span> <span class="n">Error</span><span class="p">);</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="kt">size_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">end</span> <span class="o">=</span> <span class="n">Contents</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">addr</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">addr</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
          <span class="n">fd_dynstr</span> <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">((</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&gt;&gt;</span> <span class="mi">4</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span>
                     <span class="o">&lt;&lt;</span> <span class="n">hexdigit</span><span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">&amp;</span> <span class="mh">0xF</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="o">&lt;&lt;</span> <span class="s">&quot; &quot;</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">addr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
            <span class="k">continue</span><span class="p">;</span>
          <span class="k">if</span> <span class="p">(</span><span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="p">]</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span>
            <span class="n">fd_dynstrAscii</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
          <span class="k">else</span>
            <span class="n">fd_dynstrAscii</span> <span class="o">&lt;&lt;</span> <span class="n">Contents</span><span class="p">[</span><span class="n">addr</span><span class="p">];</span>
        <span class="p">}</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DumpSo</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Name</span> <span class="o">==</span> <span class="s">&quot;.got.plt&quot;</span><span class="p">)</span> <span class="p">{</span>
        <span class="kt">uint64_t</span> <span class="n">BaseAddr</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">error</span><span class="p">(</span><span class="n">si</span><span class="o">-&gt;</span><span class="n">getAddress</span><span class="p">(</span><span class="n">BaseAddr</span><span class="p">)))</span> 
          <span class="n">assert</span><span class="p">(</span><span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Cannot get BaseAddr of section .got.plt&quot;</span><span class="p">);</span>
        <span class="n">raw_fd_ostream</span> <span class="n">fd_global_offset</span><span class="p">(</span><span class="s">&quot;global_offset&quot;</span><span class="p">,</span> <span class="n">Error</span><span class="p">);</span>
        <span class="n">fd_global_offset</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="n">BaseAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">24</span><span class="p">);</span>
        <span class="n">fd_global_offset</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
        <span class="n">fd_global_offset</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot; &quot;</span><span class="p">,</span> <span class="p">(</span><span class="n">BaseAddr</span> <span class="o">&gt;&gt;</span> <span class="mi">8</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
        <span class="n">fd_global_offset</span> <span class="o">&lt;&lt;</span> <span class="n">format</span><span class="p">(</span><span class="s">&quot;%02&quot;</span> <span class="n">PRIx64</span> <span class="s">&quot;    &quot;</span><span class="p">,</span> <span class="n">BaseAddr</span> <span class="o">&amp;</span> <span class="mh">0xFF</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">Elf2Hex</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">startAddr</span> <span class="o">=</span> <span class="n">GetSectionHeaderStartAddress</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="s">&quot;_start&quot;</span><span class="p">);</span>
<span class="c1">//  outs() &lt;&lt; format(&quot;_start address:%08&quot; PRIx64 &quot;\n&quot;, startAddr);</span>
  <span class="kt">uint64_t</span> <span class="n">lastDumpAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LinkSo</span><span class="p">)</span>
    <span class="n">cpu0DynFunIndex</span><span class="p">.</span><span class="n">createPltName</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="n">DisassembleObjectInHexFormat</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">lastDumpAddr</span><span class="p">);</span>
<span class="c1">//  outs() &lt;&lt; format(&quot;lastDumpAddr:%08&quot; PRIx64 &quot;\n&quot;, lastDumpAddr);</span>
  <span class="n">PrintDataSections</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">lastDumpAddr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/llvm-objdump/llvm-objdump.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;elf2hex.h&quot;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">DumpObject</span><span class="p">(</span><span class="k">const</span> <span class="n">ObjectFile</span> <span class="o">*</span><span class="n">o</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConvertElf2Hex</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;/*&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">getFileName</span><span class="p">()</span>
         <span class="o">&lt;&lt;</span> <span class="s">&quot;:</span><span class="se">\t</span><span class="s">file format &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">o</span><span class="o">-&gt;</span><span class="n">getFileFormatName</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConvertElf2Hex</span><span class="p">)</span>
    <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;*/&quot;</span><span class="p">;</span>
  <span class="n">outs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n\n</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Disassemble</span><span class="p">)</span>
    <span class="n">DisassembleObject</span><span class="p">(</span><span class="n">o</span><span class="p">,</span> <span class="n">Relocations</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Relocations</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Disassemble</span><span class="p">)</span>
    <span class="n">PrintRelocations</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SectionHeaders</span><span class="p">)</span>
    <span class="n">PrintSectionHeaders</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SectionContents</span><span class="p">)</span>
    <span class="n">PrintSectionContents</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ConvertElf2Hex</span><span class="p">)</span>
    <span class="n">Elf2Hex</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SymbolTable</span><span class="p">)</span>
    <span class="n">PrintSymbolTable</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">UnwindInfo</span><span class="p">)</span>
    <span class="n">PrintUnwindInfo</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">PrivateHeaders</span><span class="p">)</span>
    <span class="n">printPrivateFileHeader</span><span class="p">(</span><span class="n">o</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">int</span> <span class="n">argc</span><span class="p">,</span> <span class="kt">char</span> <span class="o">**</span><span class="n">argv</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Print a stack trace if we signal out.</span>
  <span class="n">sys</span><span class="o">::</span><span class="n">PrintStackTraceOnErrorSignal</span><span class="p">();</span>
  <span class="n">PrettyStackTraceProgram</span> <span class="n">X</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">);</span>
  <span class="n">llvm_shutdown_obj</span> <span class="n">Y</span><span class="p">;</span>  <span class="c1">// Call llvm_shutdown() on exit.</span>

  <span class="c1">// Initialize targets and assembly printers/parsers.</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllTargetInfos</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllTargetMCs</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllAsmParsers</span><span class="p">();</span>
  <span class="n">llvm</span><span class="o">::</span><span class="n">InitializeAllDisassemblers</span><span class="p">();</span>

  <span class="c1">// Register the target printer for --version.</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">AddExtraVersionPrinter</span><span class="p">(</span><span class="n">TargetRegistry</span><span class="o">::</span><span class="n">printRegisteredTargetsForVersion</span><span class="p">);</span>

  <span class="n">cl</span><span class="o">::</span><span class="n">ParseCommandLineOptions</span><span class="p">(</span><span class="n">argc</span><span class="p">,</span> <span class="n">argv</span><span class="p">,</span> <span class="s">&quot;llvm object file dumper</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">TripleName</span> <span class="o">=</span> <span class="n">Triple</span><span class="o">::</span><span class="n">normalize</span><span class="p">(</span><span class="n">TripleName</span><span class="p">);</span>

  <span class="n">ToolName</span> <span class="o">=</span> <span class="n">argv</span><span class="p">[</span><span class="mi">0</span><span class="p">];</span>

  <span class="c1">// Defaults to a.out if no filenames specified.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">InputFilenames</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">InputFilenames</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="s">&quot;a.out&quot;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Disassemble</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Relocations</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SectionHeaders</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SectionContents</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">ConvertElf2Hex</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">SymbolTable</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">UnwindInfo</span>
      <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">PrivateHeaders</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">cl</span><span class="o">::</span><span class="n">PrintHelpMessage</span><span class="p">();</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">std</span><span class="o">::</span><span class="n">for_each</span><span class="p">(</span><span class="n">InputFilenames</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">InputFilenames</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span>
                <span class="n">DumpInput</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The code included &#8220;if (DumpSo)&#8221; and &#8220;if (LinkSo)&#8221; are for dynamic linker support.
Others are used in both static and dynamic link execution file dump.</p>
</div>
<div class="section" id="lld-introduction">
<h2>LLD introduction<a class="headerlink" href="#lld-introduction" title="Permalink to this headline">¶</a></h2>
<p>In general, linker do the Relocation Records Resolve as Chapter ELF support
depicted and optimization for those cannot finish in compiler stage. One of
the optimization opportunity in linker is Dead Code Stripping which will
explained in this section. List the LLD project status as follows,</p>
<ul class="simple">
<li>The lld project aims to to be the built-in linker for clang/llvm.
Currently, clang must invoke the system linker to produce executables.</li>
<li>web site <a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></li>
<li>Current Status<ul>
<li>lld is in its early stages of development.</li>
<li>It can currently self host on Linux x86-64 with -static.</li>
</ul>
</li>
<li>How to build<ul>
<li>cmake -DCMAKE_CXX_COMPILER=g++ -DCMAKE_C_COMPILER=gcc -DCMAKE_CXX_FLAGS=-std
=c++11 -DCMAKE_BUILD_TYPE=Debug -G &#8220;Unix Makefiles&#8221; ../src/</li>
</ul>
</li>
</ul>
<p>This whole book focus on backend design, and this chapter is same.
To help readers
understand the lld document, first we list the linking steps from lld web.
After that, explain each step with the class of source code which came from
lld source and more with what kind of Cpu0 lld backend implementation needed
in each step.
Please read the lld design web document first, <a class="reference external" href="http://lld.llvm.org/design.html">http://lld.llvm.org/design.html</a>,
then reading the following to
ensure you agree to our understanding from lld design document.
Because some of the following came from our understanding.</p>
<div class="section" id="how-lld-do-the-linker-job">
<h3>How LLD do the linker job<a class="headerlink" href="#how-lld-do-the-linker-job" title="Permalink to this headline">¶</a></h3>
<ul>
<li><p class="first">LLD structure</p>
<ul class="simple">
<li>Internal structure Atom<ul>
<li>Like llvm IR, lld operating and optimize in Atom.</li>
</ul>
</li>
<li>ELF reader/writer, Mach-O reader/writer, COFF<ul>
<li>Connect to any specific linker format by implement the concrete Read/Writer.</li>
<li>e.g. Implement Microsoft link format Reader/Writer
=&gt; extend lld to support Microsoft link format.</li>
</ul>
</li>
</ul>
</li>
<li><p class="first">Atom</p>
<ul class="simple">
<li>An atom is an indivisible chunk of code or data.</li>
<li>Typically each user written function or global variable is an atom.</li>
<li>In addition, the compiler may emit other atoms, such as for literal c-strings
or floating point constants, or for runtime data structures like dwarf unwind
info or pointers to initializers.</li>
</ul>
</li>
<li><p class="first">Atoms classified:</p>
<ul class="simple">
<li>The following Hello World code can be classified with these different kinds of
Atoms as follows,</li>
</ul>
<p class="rubric">Atom example code</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<ul class="simple">
<li>DefinedAtom<ul>
<li>95% of all atoms. This is a chunk of code or data</li>
</ul>
</li>
<li>UndefinedAtom<ul>
<li>printf in this example.</li>
</ul>
</li>
<li>SharedLibraryAtom<ul>
<li>Symbols defined in shared library (file *.so).</li>
</ul>
</li>
<li>AbsoluteAtom<ul>
<li>This is for embedded support where some stuff is implemented in ROM at some
fixed address.</li>
</ul>
</li>
</ul>
</li>
</ul>
<div class="figure align-center" id="lld-atom">
<a class="reference internal image-reference" href="_images/atom.png"><img alt="_images/atom.png" src="_images/atom.png" /></a>
<p class="caption">Figure 1: Atom classified (from lld web)</p>
</div>
</div>
<div class="section" id="linking-steps">
<h3>Linking Steps<a class="headerlink" href="#linking-steps" title="Permalink to this headline">¶</a></h3>
<ul class="simple">
<li>Command line processing<ul>
<li>lld -flavor gnu -target cpu0-unknown-linux-gnu hello.o printf-stdarg.o -o a.out</li>
</ul>
</li>
<li>Parsing input files<ul>
<li>ELF reader =&gt; create lld:File</li>
</ul>
</li>
<li>Resolving<ul>
<li>dead code stripping</li>
</ul>
</li>
<li>Passes/Optimizations<ul>
<li>Like llvm passes, give the backend chance to do something like optimization.</li>
</ul>
</li>
<li>Generate output file<ul>
<li>Resolving Relocation Records – I guess in this step</li>
</ul>
</li>
</ul>
<div class="section" id="command-line-processing">
<h4>Command line processing<a class="headerlink" href="#command-line-processing" title="Permalink to this headline">¶</a></h4>
<p>To support a new backend, the following code added for Command line processing.</p>
<p class="rubric">lld/lib/ReaderWriter/ELF/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">uint16_t</span> <span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">getOutputMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">getTriple</span><span class="p">().</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">llvm</span><span class="o">::</span><span class="n">ELF</span><span class="o">::</span><span class="n">EM_CPU0</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unhandled arch&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">triple</span><span class="p">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">));</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="parsing-input-files">
<h4>Parsing input files<a class="headerlink" href="#parsing-input-files" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">Input Files</p>
<ul class="simple">
<li>A goal of lld is to be file format independent.</li>
<li>The lld::Reader is the base class for all object file readers</li>
<li>Every Reader subclass defines its own “options” class (for instance the
mach-o Reader defines the class ReaderOptionsMachO). This options class is
the one-and-only way to control how the Reader operates when parsing an input
file into an Atom graph</li>
</ul>
</li>
<li><p class="first">Reader</p>
<ul>
<li><p class="first">The base class lld::reader and the elf specific file format reader as follows,</p>
<p class="rubric">lld/lib/ReaderWriter/Reader.cpp</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter$ cat Reader.cpp
...
#include "lld/ReaderWriter/Reader.h"

#include "llvm/ADT/OwningPtr.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/Support/MemoryBuffer.h"
#include "llvm/Support/system_error.h"

namespace lld {
Reader::~Reader() {
}
} // end namespace lld</pre>
</div>
<p class="rubric">lld/lib/ReaderWriter/ELF/Reader.cpp</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter/ELF$ cat Reader.cpp
namespace lld {
namespace elf {
...
class ELFReader : public Reader {
public:
  ELFReader(const ELFLinkingContext &amp;ctx)
      : lld::Reader(ctx), _elfLinkingContext(ctx) {}

  error_code parseFile(std::unique_ptr&lt;MemoryBuffer&gt; &amp;mb,
                       std::vector&lt;std::unique_ptr&lt;File&gt; &gt; &amp;result) const {
…
private:
  const ELFLinkingContext &amp;_elfLinkingContext;
};
} // end namespace elf

std::unique_ptr&lt;Reader&gt; createReaderELF(const ELFLinkingContext &amp;context) {
  return std::unique_ptr&lt;Reader&gt;(new elf::ELFReader(context));
}
} // end namespace lld</pre>
</div>
</li>
</ul>
</li>
<li><p class="first">lld::File representations</p>
<ul class="simple">
<li>In memory, abstract C++ classes (lld::Atom, lld::Reference, and lld::File).<ul>
<li>Data structure keeped in memory to be fast</li>
</ul>
</li>
<li>textual (in YAML)<ul>
<li>target-triple:   x86_64-apple-darwin11</li>
<li>atoms:<ul>
<li>name:    _main</li>
<li>scope:   global</li>
<li>type:    code</li>
<li>content: [ 55, 48, 89, e5, 48, 8d, 3d, 00, 00, 00, 00, 30, c0, e8, 00, 00,
00, 00, 31, c0, 5d, c3 ]</li>
</ul>
</li>
</ul>
</li>
<li>binary format (“native”)<ul>
<li>With this model for the native file format, files can be read and turned
into the in-memory graph of lld::Atoms with just a few memory allocations.
And the format can easily adapt over time to new features.</li>
</ul>
</li>
</ul>
</li>
</ul>
</div>
<div class="section" id="resolving">
<h4>Resolving<a class="headerlink" href="#resolving" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Dead code stripping (if requested) is done at the end of resolving.</li>
<li>The linker does a simple mark-and-sweep. It starts with “root” atoms (like
“main” in a main executable) and follows each references and marks each Atom
that it visits as “live”.</li>
<li>When done, all atoms not marked “live” are removed.</li>
</ul>
<p class="rubric">Dead code stripping - example (modified from llvm lto document web)</p>
<p class="rubric">a.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo1</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo4</span><span class="p">(</span><span class="kt">void</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">a.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;a.h&quot;</span>

<span class="k">static</span> <span class="kt">signed</span> <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="kt">void</span> <span class="nf">foo2</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">i</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">foo3</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="p">(</span><span class="mi">10</span><span class="o">+</span><span class="n">foo4</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo1</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">data</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">data</span> <span class="o">=</span> <span class="n">foo3</span><span class="p">();</span>

  <span class="n">data</span> <span class="o">=</span> <span class="n">data</span> <span class="o">+</span> <span class="mi">42</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">data</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">ch13_1.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;a.h&quot;</span>

<span class="kt">int</span> <span class="nf">foo4</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">foo1</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Above code can be reduced to <a class="pageref" href="#lld-deadcodestripping">Figure  2</a> to perform
mark and swip in graph for Dead Code Stripping.</p>
<div class="figure align-center" id="lld-deadcodestripping">
<a class="reference internal image-reference" href="_images/deadcodestripping.png"><img alt="_images/deadcodestripping.png" src="_images/deadcodestripping.png" /></a>
<p class="caption">Figure 2: Atom classified (from lld web)</p>
</div>
<p>As above example, the foo2() is an isolated node without any reference. It&#8217;s
dead code and can be removed in linker optimization. We test this example by
build-ch13_1.sh and find foo2() cannot be removed.
There are two possibilities. One is we did trigger lld dead code stripping
optimization in command (the default is not do it). The other is lld didn&#8217;t
implement it at this point. It&#8217;s reasonable since the
lld is in its early stages of development. We didn&#8217;t dig it more, since the
Cpu0 backend tutorial just need a linker to finish Relocation Records Resolve
and see how it run on PC.</p>
<p>Remind, llvm-linker is the linker works on IR level linker optimization.
Sometime when you got the obj file only (if you have a.o in this case),
the native linker (such as lld) have the opportunity to do Dead Code Stripping
while the IR linker hasn&#8217;t.</p>
</div>
<div class="section" id="passes-optimizations">
<h4>Passes/Optimizations<a class="headerlink" href="#passes-optimizations" title="Permalink to this headline">¶</a></h4>
<ul class="simple">
<li>Passes<ul>
<li>stub (PLT) generation</li>
<li>GOT instantiation</li>
<li>order_file optimization</li>
<li>branch island generation</li>
<li>branch shim generation</li>
<li>Objective-C optimizations (Darwin specific)</li>
<li>TLV instantiation (Darwin specific)</li>
<li>DTrace probe processing (Darwin specific)</li>
<li>compact unwind encoding (Darwin specific)</li>
</ul>
</li>
</ul>
<p>The Cpu0RelocationPass.cpp and Cpu0RelocationPass.h are example code for lld
backend Passes. The Relocation Pass structure shown as <a class="pageref" href="#lld-f3">Figure  3</a>.
The Cpu0 backend has two Releocation Pass and both of them are children of
RelocationPass. The StaticRelocationPass is for static linker and
DynamicRelocationPass is for dynamic linker. We will see how to register
relocation pass according the staic or dynamic linker you like to do in
next section.</p>
<div class="figure align-center" id="lld-f3">
<a class="reference internal image-reference" href="_images/33.png"><img alt="_images/33.png" src="_images/33.png" /></a>
<p class="caption">Figure 3: Cpu0 lld RelocationPass</p>
</div>
<p>All lld backends which like to handle the Relocation
Records Resolve need to register a pass when the lld backend code is up.
After register the pass, LLD will do last two
steps, Passes/Optimization and Generate Output file, interactivly just like the
&#8220;Parsing and Generating code&#8221; in compiler.
LLD will do Passes/Optimization and call your
lld backend hook function &#8220;applyRelocation()&#8221; (define in
Cpu0TargetRelocationHandler.cpp) to finish the address binding in linker stage.
Based on this understanding, we believe the &#8220;applyRelocation()&#8221; is at the step
of Generate output file rather than Passes/Optimization even LLD web document
didn&#8217;t indicate this.</p>
<p>The following code will register a pass when the lld backend code is up.</p>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span><span class="o">:</span>
  <span class="c1">// when the output file is execution file: e.g. a.out</span>
<span class="cp">#ifdef DLINKER</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="c1">// when the a.out refer to shared object *.so</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
    <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">StaticRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="o">:</span>
  <span class="c1">// when the output file is shared object: e.g. foobar.so</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_REL</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unhandled output file type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="generate-output-file">
<h4>Generate Output File<a class="headerlink" href="#generate-output-file" title="Permalink to this headline">¶</a></h4>
<ul>
<li><p class="first">All concrete writers (e.g. ELF, mach-o, etc) are subclasses of the lld::Writer
class.</p>
</li>
<li><p class="first">Every Writer subclass defines its own “options” class (for instance the mach-o
Writer defines the class WriterOptionsMachO). This options class is the
one-and-only way to control how the Writer operates when producing an output
file from an Atom graph.</p>
</li>
<li><p class="first">Writer</p>
<p class="rubric">lld/lib/ReaderWriter</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter$ cat Writer.cpp
...
#include "lld/Core/File.h"
#include "lld/ReaderWriter/Writer.h"

namespace lld {
Writer::Writer() {
}

Writer::~Writer() {
}

bool Writer::createImplicitFiles(std::vector&lt;std::unique_ptr&lt;File&gt; &gt; &amp;) {
  return true;
}
} // end namespace lld</pre>
</div>
<p class="rubric">lld/lib/ReaderWriter</p>
<div class="highlight-c++"><pre>~/llvm/test/src/tools/lld/lib/ReaderWriter/ELF$ cat Writer.cpp
namespace lld {

std::unique_ptr&lt;Writer&gt; createWriterELF(const ELFLinkingContext &amp;info) {
  using llvm::object::ELFType;
  ...
  switch (info.getOutputELFType()) {
  case llvm::ELF::ET_EXEC:
    if (info.is64Bits()) {
      if (info.isLittleEndian())
        return std::unique_ptr&lt;Writer&gt;(new
            elf::ExecutableWriter&lt;ELFType&lt;support::little, 8, true&gt;&gt;(info));
      else
        return std::unique_ptr&lt;Writer&gt;(new
                elf::ExecutableWriter&lt;ELFType&lt;support::big, 8, true&gt;&gt;(info));
...

} // namespace lld</pre>
</div>
</li>
</ul>
<p>After register a relocation pass, lld backend hook function &#8220;applyRelocation()&#8221;
will be called by lld driver to finish the address binding in linker stage.</p>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">atomContent</span> <span class="o">=</span> <span class="n">buf</span><span class="p">.</span><span class="n">getBufferStart</span><span class="p">()</span> <span class="o">+</span> <span class="n">atom</span><span class="p">.</span><span class="n">_fileOffset</span><span class="p">;</span>
  <span class="kt">uint8_t</span> <span class="o">*</span><span class="n">location</span> <span class="o">=</span> <span class="n">atomContent</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">targetVAddress</span> <span class="o">=</span> <span class="n">writer</span><span class="p">.</span><span class="n">addressOfAtom</span><span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">target</span><span class="p">());</span>
  <span class="kt">uint64_t</span> <span class="n">relocVAddress</span> <span class="o">=</span> <span class="n">atom</span><span class="p">.</span><span class="n">_virtualAddr</span> <span class="o">+</span> <span class="n">ref</span><span class="p">.</span><span class="n">offsetInAtom</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">R_CPU0_PC24</span>:
    <span class="n">relocPC24</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch_hello.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>

  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/build-hello.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash
#TOOLDIR=/home/Gamma/test/lld/cmake_debug_build/bin
TOOLDIR=/home/cschen/test/lld/cmake_debug_build/bin

cpu=cpu032I

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm -o
printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c ch_hello.c -emit-llvm -o ch_hello.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
ch_hello.bc -o ch_hello.cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu start.cpu0.o
printf-stdarg.cpu0.o ch_hello.cpu0.o -o a.out
${TOOLDIR}/llvm-objdump -elf2hex a.out &gt; ../cpu0_verilog/cpu0.hex</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/Cpu0.hex</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="cm">/*printf:*/</span>
<span class="cm">/*      b4:*/</span> <span class="mi">09</span> <span class="n">dd</span> <span class="n">ff</span> <span class="n">e0</span>                                  <span class="cm">/* addiu   $sp, $sp, -32*/</span>
<span class="p">...</span>
<span class="cm">/*main:*/</span>
<span class="cm">/*     9e0:*/</span> <span class="mi">09</span> <span class="n">dd</span> <span class="n">ff</span> <span class="n">e8</span>                                  <span class="cm">/* addiu   $sp, $sp, -24*/</span>
<span class="p">...</span>
<span class="cm">/*     9f0:*/</span> <span class="mf">0f</span> <span class="mi">20</span> <span class="mo">00</span> <span class="mo">00</span>                                  <span class="cm">/* lui     $2, 0*/</span>
<span class="cm">/*     9f4:*/</span> <span class="mi">09</span> <span class="mi">22</span> <span class="mi">0</span><span class="n">b</span> <span class="mf">9f</span>                                  <span class="cm">/* addiu   $2, $2, 2975*/</span>
<span class="p">...</span>
<span class="cm">/*     a0c:*/</span> <span class="mi">3</span><span class="n">b</span> <span class="n">ff</span> <span class="n">f6</span> <span class="n">a4</span>                                  <span class="cm">/* jsub    16774820*/</span>
<span class="p">...</span>
<span class="cm">/*Contents of section .rodata:*/</span>
<span class="cm">/*0b98 */</span><span class="mi">28</span> <span class="mi">6</span><span class="n">e</span> <span class="mi">75</span> <span class="mi">6</span><span class="n">c</span>  <span class="mi">6</span><span class="n">c</span> <span class="mi">29</span> <span class="mo">00</span> <span class="mi">48</span>  <span class="mi">65</span> <span class="mi">6</span><span class="n">c</span> <span class="mi">6</span><span class="n">c</span> <span class="mf">6f</span>  <span class="mi">20</span> <span class="mi">77</span> <span class="mf">6f</span> <span class="mi">72</span> <span class="cm">/*  (null).Hello wor*/</span>
<span class="cm">/*0ba8 */</span><span class="mi">6</span><span class="n">c</span> <span class="mi">64</span> <span class="mi">21</span> <span class="mo">00</span>  <span class="mi">25</span> <span class="mi">73</span> <span class="mi">0</span><span class="n">a</span> <span class="mo">00</span>   <span class="cm">/*  ld!.\%s..*/</span>
</pre></div>
</div>
<p>As you can see, applyRelocation() get four values for the Relocation Records
Solving. When meet R_CPU0_LO16, targetVAddress is the only one value needed for
this Relocation Solving in these four values. For this ch_hello.c example code,
the lld set the &#8220;Hello world!&#8221; string begin at 0x0b98+7=0x0b9f.
So, targetVAddress is 0x0b9f.
The instructions
&#8220;lui&#8221; and &#8220;addiu&#8221; at address 0x9f0 and 0x9f4 loading the address of
&#8220;Hello world!&#8221; string to register $2. The &#8220;lui&#8221; got the HI 16 bits while the
&#8220;addiu&#8221; got the LO 16 bits of address of &#8220;Hello world!&#8221; string. This &#8220;lui&#8221;
Relocation Record, R_CPU0_HI16, is 0 since the HI 16 bits of 0xb9f is 0 while
the &#8220;addiu&#8221; Relocation Record, R_CPU0_LO16, is 0xb9f.
The instruction &#8220;jsub&#8221; at 0xa0c is an instruction jump to printf().
This instruction is a PC relative address Relocation Record, R_CPU0_PC24,
while the R_CPU0_LO16 is an absolute address Relocation Record.
To solve this Relocation Record, it need &#8220;location&#8221; in addition to
targetVAddress. In this case, the targetVAddress is 0xb4 where is the printf
subroutine start address and the location is 0xa0c since the
instruction &#8220;jsub&#8221; sit at this address.
The R_CPU0_PC24 is solved by (0xb4 - (0xa0c + 4) = 0xf6a4 for 16 bits with sign
extension) since after this &#8220;jsub&#8221; instruction executed the PC counter is
(0xa0c+4).
To +4 at current instruction because PC counter increased at instruction fetch
stage in Verilog design.</p>
<p>Remind, we explain the Relocation Records Solving according file cpu0.hex list
as above because the the Cpu0 machine boot at memory address 0x0 while the elf
text section or plt section as follows start at 0x140. The 0x0 is the header of
machine architecture information. The elf2hex code must keeps the address
relative distance between text and plt sections just like the Cpu0 elf2hex.h did.
The .rodata and other data sections are binding with absolute address, Cpu0
elf2hex must keeps them as the same address of elf.</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>bash build-hello.sh
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llvm-objdump -s a.out
...                .
Contents of section .plt:
 0140 3600000c 36000004 36000004 36fffffc  6...6...6...6...
Contents of section .text:
 0150 09ddfff8 02ed0004 02cd0000 11cd0000  ................
...
Contents of section .rodata:
 0b98 286e756c 6c290048 656c6c6f 20776f72  <span class="o">(</span>null<span class="o">)</span>.Hello wor
 0ba8 6c642100 25730a00                    ld!.%s..
</pre></div>
</div>
<p>Next section will show you how to design your lld backend and register a pass
for Relocation Records Solve in details through the Cpu0 lld backend code
explantation.</p>
</div>
</div>
</div>
<div class="section" id="static-linker">
<h2>Static linker<a class="headerlink" href="#static-linker" title="Permalink to this headline">¶</a></h2>
<p>Let&#8217;s run the static linker first and explain it next.</p>
<div class="section" id="run">
<h3>Run<a class="headerlink" href="#run" title="Permalink to this headline">¶</a></h3>
<p>File printf-stdarg.c came from internet download which is GPL2 license. GPL2
is more restricted than LLVM license. File printf-stdarg-2.cpp is modified from
main() function of printf-stdarg.c and add some test function for
/demo/verification/debugpurpose on Cpu0 backend.
File printf-stdarg-1.c is the file for testing the printf()
function implemented on PC OS platform. Let&#8217;s run printf-stdarg-2.cpp on Cpu0 and
compare with the result of printf() function which implemented by PC OS as
below.</p>
<p class="rubric">lbdex/InputFiles/printf-stdarg-1.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  Copyright 2001, 2002 Georges Menie (www.menie.org)</span>
<span class="cm">  stdarg version contributed by Christian Ettinger</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU Lesser General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  putchar is the only external dependency for this file,</span>
<span class="cm">  if you have a working putchar, leave it commented out.</span>
<span class="cm">  If not, uncomment the define below and</span>
<span class="cm">  replace outbyte(c) by your own function call.</span>

<span class="cm">#define putchar(c) outbyte(c)</span>
<span class="cm">*/</span>

<span class="c1">// gcc printf-stdarg-1.c</span>
<span class="c1">// ./a.out</span>

<span class="cp">#include &lt;stdio.h&gt;</span>

<span class="cp">#define TEST_PRINTF</span>

<span class="cp">#ifdef TEST_PRINTF</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

  <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;printf test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s is null pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = - max int</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;char %c = &#39;a&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %x = ff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %02x = 00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signed %d = unsigned %u = hex %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s)%&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s) with %%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%-10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;right&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * if you compile this file with</span>
<span class="cm"> *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c</span>
<span class="cm"> * you will get a normal warning:</span>
<span class="cm"> *   printf.c:214: warning: spurious trailing `%&#39; in format</span>
<span class="cm"> * this line is testing an invalid % at the end of the format string.</span>
<span class="cm"> *</span>
<span class="cm"> * this should display (on 32bit int machine) :</span>
<span class="cm"> *</span>
<span class="cm"> * Hello world!</span>
<span class="cm"> * printf test</span>
<span class="cm"> * (null) is null pointer</span>
<span class="cm"> * 5 = 5</span>
<span class="cm"> * -2147483647 = - max int</span>
<span class="cm"> * char a = &#39;a&#39;</span>
<span class="cm"> * hex ff = ff</span>
<span class="cm"> * hex 00 = 00</span>
<span class="cm"> * signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="cm"> * 0 message(s)</span>
<span class="cm"> * 0 message(s) with %</span>
<span class="cm"> * justif: &quot;left      &quot;</span>
<span class="cm"> * justif: &quot;     right&quot;</span>
<span class="cm"> *  3: 0003 zero padded</span>
<span class="cm"> *  3: 3    left justif.</span>
<span class="cm"> *  3:    3 right justif.</span>
<span class="cm"> * -3: -003 zero padded</span>
<span class="cm"> * -3: -3   left justif.</span>
<span class="cm"> * -3:   -3 right justif.</span>
<span class="cm"> */</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/printf-stdarg-2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;print.h&quot;</span>

<span class="cp">#define PRINT_TEST</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="cp">#include &quot;ch6_1.cpp&quot;</span>
<span class="cp">#include &quot;ch9_2_1.cpp&quot;</span>
<span class="cp">#include &quot;ch9_2_2.cpp&quot;</span>
<span class="cp">#include &quot;ch9_3_2.cpp&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">a</span> <span class="o">=</span> <span class="n">test_global</span><span class="p">();</span>  <span class="c1">// gI = 100</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;global variable gI = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_func_arg_struct</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_contructor</span><span class="p">();</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_template</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;test_template() = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span> <span class="c1">// a = 15</span>

  <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;printf test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s is null pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = - max int</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;char %c = &#39;a&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %x = ff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %02x = 00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signed %d = unsigned %u = hex %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s)%&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s) with %%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%-10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;right&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/printf-stdarg.c</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cm">/*</span>
<span class="cm">  Copyright 2001, 2002 Georges Menie (www.menie.org)</span>
<span class="cm">  stdarg version contributed by Christian Ettinger</span>

<span class="cm">    This program is free software; you can redistribute it and/or modify</span>
<span class="cm">    it under the terms of the GNU Lesser General Public License as published by</span>
<span class="cm">    the Free Software Foundation; either version 2 of the License, or</span>
<span class="cm">    (at your option) any later version.</span>

<span class="cm">    This program is distributed in the hope that it will be useful,</span>
<span class="cm">    but WITHOUT ANY WARRANTY; without even the implied warranty of</span>
<span class="cm">    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the</span>
<span class="cm">    GNU Lesser General Public License for more details.</span>

<span class="cm">    You should have received a copy of the GNU Lesser General Public License</span>
<span class="cm">    along with this program; if not, write to the Free Software</span>
<span class="cm">    Foundation, Inc., 59 Temple Place, Suite 330, Boston, MA  02111-1307  USA</span>
<span class="cm">*/</span>

<span class="cm">/*</span>
<span class="cm">  putchar is the only external dependency for this file,</span>
<span class="cm">  if you have a working putchar, leave it commented out.</span>
<span class="cm">  If not, uncomment the define below and</span>
<span class="cm">  replace outbyte(c) by your own function call.</span>

<span class="cm">#define putchar(c) outbyte(c)</span>
<span class="cm">*/</span>

<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="k">static</span> <span class="kt">void</span> <span class="nf">printchar</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">extern</span> <span class="kt">int</span> <span class="n">putchar</span><span class="p">(</span><span class="kt">int</span> <span class="n">c</span><span class="p">);</span>
  
  <span class="k">if</span> <span class="p">(</span><span class="n">str</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">**</span><span class="n">str</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>
    <span class="o">++</span><span class="p">(</span><span class="o">*</span><span class="n">str</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="p">(</span><span class="kt">void</span><span class="p">)</span><span class="n">putchar</span><span class="p">(</span><span class="n">c</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define PAD_RIGHT 1</span>
<span class="cp">#define PAD_ZERO 2</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">prints</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">string</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">padchar</span> <span class="o">=</span> <span class="sc">&#39; &#39;</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">register</span> <span class="kt">int</span> <span class="n">len</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">register</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span>
    <span class="k">for</span> <span class="p">(</span><span class="n">ptr</span> <span class="o">=</span> <span class="n">string</span><span class="p">;</span> <span class="o">*</span><span class="n">ptr</span><span class="p">;</span> <span class="o">++</span><span class="n">ptr</span><span class="p">)</span> <span class="o">++</span><span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">len</span> <span class="o">&gt;=</span> <span class="n">width</span><span class="p">)</span> <span class="n">width</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="k">else</span> <span class="n">width</span> <span class="o">-=</span> <span class="n">len</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="n">PAD_ZERO</span><span class="p">)</span> <span class="n">padchar</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="n">PAD_RIGHT</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">padchar</span><span class="p">);</span>
      <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">string</span> <span class="p">;</span> <span class="o">++</span><span class="n">string</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">string</span><span class="p">);</span>
    <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="n">width</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">;</span> <span class="o">--</span><span class="n">width</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">padchar</span><span class="p">);</span>
    <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/* the following should be enough for 32 bit int */</span>
<span class="cp">#define PRINT_BUF_LEN 12</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">printi</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="kt">int</span> <span class="n">i</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">sg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="kt">int</span> <span class="n">pad</span><span class="p">,</span> <span class="kt">int</span> <span class="n">letbase</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">print_buf</span><span class="p">[</span><span class="n">PRINT_BUF_LEN</span><span class="p">];</span>
  <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">t</span><span class="p">,</span> <span class="n">neg</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">u</span> <span class="o">=</span> <span class="n">i</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">i</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">print_buf</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">print_buf</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">print_buf</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">sg</span> <span class="o">&amp;&amp;</span> <span class="n">b</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">neg</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
    <span class="n">u</span> <span class="o">=</span> <span class="o">-</span><span class="n">i</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">s</span> <span class="o">=</span> <span class="n">print_buf</span> <span class="o">+</span> <span class="n">PRINT_BUF_LEN</span><span class="o">-</span><span class="mi">1</span><span class="p">;</span>
  <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>

  <span class="k">while</span> <span class="p">(</span><span class="n">u</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">t</span> <span class="o">=</span> <span class="n">u</span> <span class="o">%</span> <span class="n">b</span><span class="p">;</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">t</span> <span class="o">&gt;=</span> <span class="mi">10</span> <span class="p">)</span>
      <span class="n">t</span> <span class="o">+=</span> <span class="n">letbase</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span> <span class="o">-</span> <span class="mi">10</span><span class="p">;</span>
    <span class="o">*--</span><span class="n">s</span> <span class="o">=</span> <span class="n">t</span> <span class="o">+</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
    <span class="n">u</span> <span class="o">/=</span> <span class="n">b</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">neg</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span><span class="p">(</span> <span class="n">width</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">pad</span> <span class="o">&amp;</span> <span class="n">PAD_ZERO</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="sc">&#39;-&#39;</span><span class="p">);</span>
      <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
      <span class="o">--</span><span class="n">width</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="o">*--</span><span class="n">s</span> <span class="o">=</span> <span class="sc">&#39;-&#39;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">pc</span> <span class="o">+</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">s</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">int</span> <span class="nf">print</span><span class="p">(</span><span class="kt">char</span> <span class="o">**</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="kt">va_list</span> <span class="n">args</span> <span class="p">)</span>
<span class="p">{</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">;</span>
  <span class="k">register</span> <span class="kt">int</span> <span class="n">pc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">scr</span><span class="p">[</span><span class="mi">2</span><span class="p">];</span>

  <span class="k">for</span> <span class="p">(;</span> <span class="o">*</span><span class="n">format</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">;</span> <span class="o">++</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="p">{</span>
      <span class="o">++</span><span class="n">format</span><span class="p">;</span>
      <span class="n">width</span> <span class="o">=</span> <span class="n">pad</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;\0&#39;</span><span class="p">)</span> <span class="k">break</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;%&#39;</span><span class="p">)</span> <span class="k">goto</span> <span class="n">out</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;-&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">format</span><span class="p">;</span>
        <span class="n">pad</span> <span class="o">=</span> <span class="n">PAD_RIGHT</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">while</span> <span class="p">(</span><span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;0&#39;</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">format</span><span class="p">;</span>
        <span class="n">pad</span> <span class="o">|=</span> <span class="n">PAD_ZERO</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">for</span> <span class="p">(</span> <span class="p">;</span> <span class="o">*</span><span class="n">format</span> <span class="o">&gt;=</span> <span class="sc">&#39;0&#39;</span> <span class="o">&amp;&amp;</span> <span class="o">*</span><span class="n">format</span> <span class="o">&lt;=</span> <span class="sc">&#39;9&#39;</span><span class="p">;</span> <span class="o">++</span><span class="n">format</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">width</span> <span class="o">*=</span> <span class="mi">10</span><span class="p">;</span>
        <span class="n">width</span> <span class="o">+=</span> <span class="o">*</span><span class="n">format</span> <span class="o">-</span> <span class="sc">&#39;0&#39;</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;s&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="k">register</span> <span class="kt">char</span> <span class="o">*</span><span class="n">s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span><span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">s</span><span class="o">?</span><span class="n">s</span><span class="o">:</span><span class="s">&quot;(null)&quot;</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;d&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;x&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;X&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">16</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;A&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;u&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">printi</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">),</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
      <span class="k">if</span><span class="p">(</span> <span class="o">*</span><span class="n">format</span> <span class="o">==</span> <span class="sc">&#39;c&#39;</span> <span class="p">)</span> <span class="p">{</span>
        <span class="cm">/* char are converted to int then pushed on the stack */</span>
        <span class="n">scr</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="p">)</span><span class="n">va_arg</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="kt">int</span> <span class="p">);</span>
        <span class="n">scr</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
        <span class="n">pc</span> <span class="o">+=</span> <span class="n">prints</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="n">scr</span><span class="p">,</span> <span class="n">width</span><span class="p">,</span> <span class="n">pad</span><span class="p">);</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span>
    <span class="k">else</span> <span class="p">{</span>
    <span class="nl">out:</span>
      <span class="n">printchar</span> <span class="p">(</span><span class="n">out</span><span class="p">,</span> <span class="o">*</span><span class="n">format</span><span class="p">);</span>
      <span class="o">++</span><span class="n">pc</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">out</span><span class="p">)</span> <span class="o">**</span><span class="n">out</span> <span class="o">=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span>
  <span class="n">va_end</span><span class="p">(</span> <span class="n">args</span> <span class="p">);</span>
  <span class="k">return</span> <span class="n">pc</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
        <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
        
        <span class="n">va_start</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">print</span><span class="p">(</span> <span class="mi">0</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">args</span> <span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">sprintf</span><span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="n">out</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
        <span class="kt">va_list</span> <span class="n">args</span><span class="p">;</span>
        
        <span class="n">va_start</span><span class="p">(</span> <span class="n">args</span><span class="p">,</span> <span class="n">format</span> <span class="p">);</span>
        <span class="k">return</span> <span class="n">print</span><span class="p">(</span> <span class="o">&amp;</span><span class="n">out</span><span class="p">,</span> <span class="n">format</span><span class="p">,</span> <span class="n">args</span> <span class="p">);</span>
<span class="p">}</span>

<span class="cp">#ifdef TEST_PRINTF</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">(</span><span class="kt">void</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">ptr</span> <span class="o">=</span> <span class="s">&quot;Hello world!&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">np</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">bs</span> <span class="o">=</span> <span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="o">*</span><span class="mi">8</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">mi</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">buf</span><span class="p">[</span><span class="mi">80</span><span class="p">];</span>

  <span class="n">mi</span> <span class="o">=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">bs</span><span class="o">-</span><span class="mi">1</span><span class="p">))</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">ptr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;printf test</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s is null pointer</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">np</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = 5</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">i</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d = - max int</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">mi</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;char %c = &#39;a&#39;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="sc">&#39;a&#39;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %x = ff</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mh">0xff</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;hex %02x = 00</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;signed %d = unsigned %u = hex %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s)%&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%d %s(s) with %%</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="s">&quot;message&quot;</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%-10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;left&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;justif: </span><span class="se">\&quot;</span><span class="s">%10s</span><span class="se">\&quot;\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="s">&quot;right&quot;</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot; 3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %04d zero padded</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %-4d left justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>
  <span class="n">sprintf</span><span class="p">(</span><span class="n">buf</span><span class="p">,</span> <span class="s">&quot;-3: %4d right justif.</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="o">-</span><span class="mi">3</span><span class="p">);</span> <span class="n">printf</span><span class="p">(</span><span class="s">&quot;%s&quot;</span><span class="p">,</span> <span class="n">buf</span><span class="p">);</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cm">/*</span>
<span class="cm"> * if you compile this file with</span>
<span class="cm"> *   gcc -Wall $(YOUR_C_OPTIONS) -DTEST_PRINTF -c printf.c</span>
<span class="cm"> * you will get a normal warning:</span>
<span class="cm"> *   printf.c:214: warning: spurious trailing `%&#39; in format</span>
<span class="cm"> * this line is testing an invalid % at the end of the format string.</span>
<span class="cm"> *</span>
<span class="cm"> * this should display (on 32bit int machine) :</span>
<span class="cm"> *</span>
<span class="cm"> * Hello world!</span>
<span class="cm"> * printf test</span>
<span class="cm"> * (null) is null pointer</span>
<span class="cm"> * 5 = 5</span>
<span class="cm"> * -2147483647 = - max int</span>
<span class="cm"> * char a = &#39;a&#39;</span>
<span class="cm"> * hex ff = ff</span>
<span class="cm"> * hex 00 = 00</span>
<span class="cm"> * signed -3 = unsigned 4294967293 = hex fffffffd</span>
<span class="cm"> * 0 message(s)</span>
<span class="cm"> * 0 message(s) with %</span>
<span class="cm"> * justif: &quot;left      &quot;</span>
<span class="cm"> * justif: &quot;     right&quot;</span>
<span class="cm"> *  3: 0003 zero padded</span>
<span class="cm"> *  3: 3    left justif.</span>
<span class="cm"> *  3:    3 right justif.</span>
<span class="cm"> * -3: -003 zero padded</span>
<span class="cm"> * -3: -3   left justif.</span>
<span class="cm"> * -3:   -3 right justif.</span>
<span class="cm"> */</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/start.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;print.h&quot;</span>
<span class="cp">#include &quot;dynamic_linker.h&quot;</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">main</span><span class="p">();</span>

<span class="cp">#define initRegs() \</span>
<span class="cp">  asm(&quot;addiu $1,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $2,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $3,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $4,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $5,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $6,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $7,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $8,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $9,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $10,	$ZERO, 0&quot;); \</span>
<span class="cp">  asm(&quot;addiu $fp, $ZERO, 0&quot;);</span>

<span class="kt">void</span> <span class="nf">start</span><span class="p">()</span> <span class="p">{</span>
<span class="c1">//  asm(&quot;boot:&quot;);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui   $1,  0x7&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori   $1,  $1, 0xfff0&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld    $gp, 0($1)&quot;</span><span class="p">);</span> <span class="c1">// load $gp($11) value from 0x7fff0</span>
  <span class="n">initRegs</span><span class="p">();</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $sp, $zero, 0x6ffc&quot;</span><span class="p">);</span>
  <span class="n">main</span><span class="p">();</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $lr, $ZERO, -1&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// For memory IO</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">putchar</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">OUT_MEM</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/build-printf-stdarg-2.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash
TOOLDIR=/usr/local/llvm/test/cmake_debug_build/bin
#TOOLDIR=~/test/llvm/cmake_debug_build/bin/Debug

cpu=cpu032I

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm -o
printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg-2.cpp -emit-llvm -o
printf-stdarg-2.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
start.bc -o start.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
printf-stdarg-2.bc -o printf-stdarg-2.cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu start.cpu0.o
printf-stdarg.cpu0.o printf-stdarg-2.cpu0.o -o a.out
${TOOLDIR}/llvm-objdump -elf2hex a.out &gt; ../cpu0_verilog/cpu0.hex</pre>
</div>
<p>The cpu0_verilog/cpu0Is.v support cmp instruction and static linker as follows,</p>
<p class="rubric">lbdex/cpu0_verilog/cpu0Is.v</p>
<div class="highlight-c++"><pre>// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>The cpu0_verilog/cpu0IIs.v support slt instruction and static linker as follows,</p>
<p class="rubric">lbdex/cpu0_verilog/cpu0IIs.v</p>
<div class="highlight-c++"><pre>`define CPU0II
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>The build-printf-stdarg-2.sh is for my PC setting. Please change this script to
the directory of your lld installed to. After that run static linker example
code as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbd/docs/BackendTutorial/source_ExampleCode/cpu0_verilog
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>bash clean.sh
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../InputFiles/
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>bash build-printf-stdarg-2.sh
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>bash build-printf-stdarg-2.sh
In file included from <span class="nb">printf</span>-stdarg-2.cpp:12:
./ch9_2_1.cpp:62:78: warning: backslash and newline separated by space
<span class="o">[</span>-Wbackslash-newline-escape<span class="o">]</span>
  <span class="nb">printf</span><span class="o">(</span><span class="s2">&quot;date2 = %d %d %d %d %d %d\n&quot;</span>, date2.year, date2.month, date2.day, <span class="se">\</span>
                                                                             ^
<span class="nb">printf</span>-stdarg-2.cpp:18:15: warning: conversion from string literal to <span class="s1">&#39;char *&#39;</span>
is deprecated <span class="o">[</span>-Wdeprecated-writable-strings<span class="o">]</span>
  char *ptr <span class="o">=</span> <span class="s2">&quot;Hello world!&quot;</span>;
              ^
<span class="nb">printf</span>-stdarg-2.cpp:44:19: warning: incomplete format specifier <span class="o">[</span>-Wformat<span class="o">]</span>
  <span class="nb">printf</span><span class="o">(</span><span class="s2">&quot;%d %s(s)%&quot;</span>, 0, <span class="s2">&quot;message&quot;</span><span class="o">)</span>;
                  ^
3 warnings generated.

1-160-136-173:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbd/docs/BackendTutorial/source_ExampleCode/cpu0_verilog
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0IIs cpu0IIs.v
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>ls
clean.sh  cpu0Id.v  cpu0IId.v  cpu0IIs  cpu0IIs.v  cpu0Is.v  cpu0.v  dynlinker.v
flashio.v
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>./cpu0IIs
WARNING: cpu0.v:365: <span class="nv">$readmemh</span><span class="o">(</span>cpu0s.hex<span class="o">)</span>: Not enough words in the file <span class="k">for</span>
the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
global variable <span class="nv">gI</span> <span class="o">=</span> 100
<span class="nv">date1</span> <span class="o">=</span> 2012 10 12 1 2 3
<span class="nv">date2</span> <span class="o">=</span> 2012 10 12 1 2 3
<span class="nv">time2</span> <span class="o">=</span> 1 10 12
<span class="nv">time3</span> <span class="o">=</span> 1 10 12
<span class="nv">date1</span> <span class="o">=</span> 2013 1 26 12 21 10
<span class="nv">date2</span> <span class="o">=</span> 2013 1 26 12 21 10
test_template<span class="o">()</span> <span class="o">=</span> 15
Hello world!
<span class="nb">printf test</span>
<span class="o">(</span>null<span class="o">)</span> is null pointer
<span class="nv">5</span> <span class="o">=</span> 5
-2147483647 <span class="o">=</span> - max int
char <span class="nv">a</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
hex <span class="nv">ff</span> <span class="o">=</span> ff
hex <span class="nv">00</span> <span class="o">=</span> 00
signed -3 <span class="o">=</span> unsigned <span class="nv">4294967293</span> <span class="o">=</span> hex fffffffd
0 message<span class="o">(</span>s<span class="o">)</span>
0 message<span class="o">(</span>s<span class="o">)</span> with <span class="se">\%</span>
justif: <span class="s2">&quot;left      &quot;</span>
justif: <span class="s2">&quot;     right&quot;</span>
 3: 0003 zero padded
 3: 3    left justif.
 3:    3 right justif.
-3: -003 zero padded
</pre></div>
</div>
<p>Let&#8217;s check the result with PC program printf-stdarg-1.c output as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>clang <span class="nb">printf</span>-stdarg-1.c
<span class="nb">printf</span>-stdarg-1.c:58:19: warning: incomplete format specifier <span class="o">[</span>-Wformat<span class="o">]</span>
  <span class="nb">printf</span><span class="o">(</span><span class="s2">&quot;%d %s(s)%&quot;</span>, 0, <span class="s2">&quot;message&quot;</span><span class="o">)</span>;
                  ^
1 warning generated.
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>./a.out
Hello world!
<span class="nb">printf test</span>
<span class="o">(</span>null<span class="o">)</span> is null pointer
<span class="nv">5</span> <span class="o">=</span> 5
-2147483647 <span class="o">=</span> - max int
char <span class="nv">a</span> <span class="o">=</span> <span class="s1">&#39;a&#39;</span>
hex <span class="nv">ff</span> <span class="o">=</span> ff
hex <span class="nv">00</span> <span class="o">=</span> 00
signed -3 <span class="o">=</span> unsigned <span class="nv">4294967293</span> <span class="o">=</span> hex fffffffd
0 message<span class="o">(</span>s<span class="o">)</span>
0 message<span class="o">(</span>s<span class="o">)</span> with <span class="se">\%</span>
justif: <span class="s2">&quot;left      &quot;</span>
justif: <span class="s2">&quot;     right&quot;</span>
 3: 0003 zero padded
 3: 3    left justif.
 3:    3 right justif.
-3: -003 zero padded
-3: -3   left justif.
-3:   -3 right justif.
</pre></div>
</div>
<p>They are same after the &#8220;Hello world!&#8221; of printf() function support.
The cpu0I use cmp instruction. Before the &#8220;Hello world!&#8221; are for test cases
which needed the linker, such as global variable, C++ template, ... .
You can verify the slt
instructions is work fine too by change cpu to cpu032II as follows,</p>
<p class="rubric">lbdex/InputFiles/build-printf-stdarg-2.sh</p>
<div class="highlight-bash"><div class="highlight"><pre>...
<span class="nv">cpu</span><span class="o">=</span>cpu032II
...
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbd/docs/BackendTutorial/source_ExampleCode/cpu0_verilog
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>bash clean.sh
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../InputFil
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>bash build-printf-stdarg-2.sh
...
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>./cpu0IIs
</pre></div>
</div>
<p>The verilog machine cpu0IIs include all instructions (cmp, jeq, ...
are included also) of cpu032I and add Chapter12_2 slt, beq, ..., instructions.
Run build-printf-stdarg-2.sh with cpu=cpu032II will generate slt, beq and bne
instructions instead of cmp, jeq, ... instructions. Since cpu0IIs include both
slt, cmp, ... instructions, the slt and cmp both code generated can be run on
it without any problem.</p>
</div>
<div class="section" id="cpu0-lld-structure">
<h3>Cpu0 lld structure<a class="headerlink" href="#cpu0-lld-structure" title="Permalink to this headline">¶</a></h3>
<div class="figure align-center" id="lld-f1">
<a class="reference internal image-reference" href="_images/16.png"><img alt="_images/16.png" src="_images/16.png" /></a>
<p class="caption">Figure 4: Cpu0 lld class relationship</p>
</div>
<div class="figure align-center" id="lld-f2">
<a class="reference internal image-reference" href="_images/24.png"><img alt="_images/24.png" src="_images/24.png" /></a>
<p class="caption">Figure 5: Cpu0 lld ELFLinkingContext and DefaultLayout member functions</p>
</div>
<p>The Cpu0LinkingContext include the context information for those input obj
files and output elf file you want to link.
When do linking, the following code will create Cpu0LinkingContext.</p>
<p class="rubric">lbdex/Cpu0_lld/ELFLinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">ELFLinkingContext</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="p">...</span>
  <span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span> <span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/ELFLinkingContext.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span>
<span class="n">ELFLinkingContext</span><span class="o">::</span><span class="n">create</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">triple</span><span class="p">.</span><span class="n">getArch</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">ELFLinkingContext</span><span class="o">&gt;</span><span class="p">(</span>
        <span class="k">new</span> <span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">));</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">nullptr</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>While Cpu0LinkingContext is created by lld ELF driver as above, the following
code in Cpu0LinkingContext constructor will create Cpu0TargetHandler and passing
the Cpu0LinkingContext object pointer to Cpu0TargeHandler.</p>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0LinkingContext.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0LinkingContext</span> <span class="n">LLVM_FINAL</span> <span class="o">:</span> <span class="k">public</span> <span class="n">ELFLinkingContext</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0LinkingContext</span><span class="p">(</span><span class="n">llvm</span><span class="o">::</span><span class="n">Triple</span> <span class="n">triple</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">ELFLinkingContext</span><span class="p">(</span><span class="n">triple</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">TargetHandlerBase</span><span class="o">&gt;</span><span class="p">(</span>
                                  <span class="k">new</span> <span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)))</span> <span class="p">{}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, the Cpu0TargeHandler constructor will create other related objects
and set up the relation reference object pointers as <a class="pageref" href="#lld-f1">Figure  4</a>
depicted by the following code.</p>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0TargetHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetHandler</span><span class="o">::</span><span class="n">Cpu0TargetHandler</span><span class="p">(</span><span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">context</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">DefaultTargetHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_gotFile</span><span class="p">(</span><span class="k">new</span> <span class="n">GOTFile</span><span class="p">(</span><span class="n">context</span><span class="p">)),</span>
      <span class="n">_relocationHandler</span><span class="p">(</span><span class="n">context</span><span class="p">),</span> <span class="n">_targetLayout</span><span class="p">(</span><span class="n">context</span><span class="p">)</span> <span class="p">{}</span>
</pre></div>
</div>
<p>According chapter ELF, the linker stands for resolve the relocation records.
The following code give the chance to let lld system call our relocation
function at proper time.</p>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationPass.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span>
<span class="n">lld</span><span class="o">::</span><span class="n">elf</span><span class="o">::</span><span class="n">createCpu0RelocationPass</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0LinkingContext</span> <span class="o">&amp;</span><span class="n">ctx</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">getOutputELFType</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_EXEC</span><span class="o">:</span>
  <span class="c1">// when the output file is execution file: e.g. a.out</span>
<span class="cp">#ifdef DLINKER</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ctx</span><span class="p">.</span><span class="n">isDynamic</span><span class="p">())</span>
    <span class="c1">// when the a.out refer to shared object *.so</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
    <span class="k">else</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
      <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">StaticRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#ifdef DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_DYN</span><span class="o">:</span>
  <span class="c1">// when the output file is shared object: e.g. foobar.so</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">(</span><span class="k">new</span> <span class="n">DynamicRelocationPass</span><span class="p">(</span><span class="n">ctx</span><span class="p">));</span>
<span class="cp">#endif </span><span class="c1">// DLINKER</span>
  <span class="k">case</span> <span class="n">llvm</span>:<span class="o">:</span><span class="n">ELF</span><span class="o">::</span><span class="n">ET_REL</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">std</span><span class="o">::</span><span class="n">unique_ptr</span><span class="o">&lt;</span><span class="n">Pass</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="nl">default:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unhandled output file type&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The &#8220;#ifdef DLINKER&#8221; part is for dynamic linker which will be used in next
section.
For static linker, a StaticRelocationPass object is created and return.</p>
<p>Now the following code of Cpu0TargetRelocationHandler::applyRelocation()
will be called through
Cpu0TargetHandler by lld ELF driver when it meets each relocation record.</p>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0RelocationHandler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">ErrorOr</span><span class="o">&lt;</span><span class="kt">void</span><span class="o">&gt;</span> <span class="n">Cpu0TargetRelocationHandler</span><span class="o">::</span><span class="n">applyRelocation</span><span class="p">(</span>
    <span class="n">ELFWriter</span> <span class="o">&amp;</span><span class="n">writer</span><span class="p">,</span> <span class="n">llvm</span><span class="o">::</span><span class="n">FileOutputBuffer</span> <span class="o">&amp;</span><span class="n">buf</span><span class="p">,</span> <span class="k">const</span> <span class="n">lld</span><span class="o">::</span><span class="n">AtomLayout</span> <span class="o">&amp;</span><span class="n">atom</span><span class="p">,</span>
    <span class="k">const</span> <span class="n">Reference</span> <span class="o">&amp;</span><span class="n">ref</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">ref</span><span class="p">.</span><span class="n">kind</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">R_CPU0_NONE</span>:
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_HI16</span>:
    <span class="n">relocHI16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">R_CPU0_LO16</span>:
    <span class="n">relocLO16</span><span class="p">(</span><span class="n">location</span><span class="p">,</span> <span class="n">relocVAddress</span><span class="p">,</span> <span class="n">targetVAddress</span><span class="p">,</span> <span class="n">ref</span><span class="p">.</span><span class="n">addend</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">error_code</span><span class="o">::</span><span class="n">success</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Cpu0_lld/Cpu0/Cpu0TargetHandler.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0TargetHandler</span> <span class="n">LLVM_FINAL</span>
    <span class="o">:</span> <span class="k">public</span> <span class="n">DefaultTargetHandler</span><span class="o">&lt;</span><span class="n">Cpu0ELFType</span><span class="o">&gt;</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="p">..</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetRelocationHandler</span> <span class="o">&amp;</span><span class="n">getRelocationHandler</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">_relocationHandler</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<p>Summary as <a class="pageref" href="#lld-f4">Figure  6</a>.</p>
<div class="figure align-center" id="lld-f4">
<a class="reference internal image-reference" href="_images/44.png"><img alt="_images/44.png" src="_images/44.png" /></a>
<p class="caption">Figure 6: Cpu0 lld related objects created sequence</p>
</div>
<p>Remind, static std::unique_ptr&lt;ELFLinkingContext&gt;
ELFLinkingContext::create(llvm::Triple) is called without an object of
class ELFLinkingContext instance (because the static keyword).
The Cpu0LinkingContext constructor will create it&#8217;s ELFLinkingContext part.
The std::unique_ptr came from c++11 standard.
The unique_ptr objects automatically delete the object they manage (using a
deleter) as soon as themselves are destroyed. Just like the Singlelten
pattern in Design Pattern book or Smart Pointers in Effective C++ book. <a class="footnote-reference" href="#id18" id="id4">[4]</a></p>
<div class="figure align-center" id="lld-f5">
<a class="reference internal image-reference" href="_images/54.png"><img alt="_images/54.png" src="_images/54.png" /></a>
<p class="caption">Figure 7: Cpu0LinkingContext get Cpu0TargetHandler through &amp;getTargetHandler()</p>
</div>
<p>As <a class="pageref" href="#lld-f1">Figure  4</a> depicted, the Cpu0TargetHandler include the members or
pointers which can access to other object. The way to access Cpu0TargetHandler
object from Cpu0LinkingContext or Cpu0RelocationHandler rely on
LinkingContext::getTargetHandler() function. As <a class="pageref" href="#lld-f5">Figure  7</a> depicted,
the unique_ptr point to Cpu0TargetHandler will be saved in LinkingContext
contructor function.</p>
<p>List the c++11 unique_ptr::get() and move() which used in <a class="pageref" href="#lld-f5">Figure  7</a>
as follows.</p>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>std::unique_ptr::get() <a class="footnote-reference" href="#id19" id="id5">[5]</a></p>
<p>pointer get() const noexcept;</p>
<p class="last">Get pointer
Returns the stored pointer.</p>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>std::move() <a class="footnote-reference" href="#id20" id="id6">[6]</a></p>
<dl class="last docutils">
<dt>for example:</dt>
<dd><p class="first">std::string bar = &#8220;bar-string&#8221;;
std::move(bar);</p>
<p class="last">bar is null after std::move(bar);</p>
</dd>
</dl>
</div>
</div>
</div>
<div class="section" id="dynamic-linker">
<h2>Dynamic linker<a class="headerlink" href="#dynamic-linker" title="Permalink to this headline">¶</a></h2>
<p>In addition to the lld code with #ifdef DLINKER. The following code in Verilog
exists to support dynamic linker.</p>
<p class="rubric">lbdex/cpu0_verilog/dynlinker.v</p>
<div class="highlight-c++"><pre>`define DLINKER_INFO_ADDR  'h70000
`define GPADDR    'h7FFF0

`ifdef DLINKER
  task setDynLinkerInfo; begin
// below code set memory as follows,
//                                                            (4 bytes) 
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR ----------&gt;                        | numDynEntry                         |
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR+4 --------&gt;                        | index of dynsym (0st row)           |
//   above is the 1st word of section .dynsym of libfoobar.cpu0.so. 
// DLINKER_INFO_ADDR+8 --------&gt;                        | index of dynsym (1st row)           |
//                                                      | ...                                 |
// DLINKER_INFO_ADDR+(numDynEntry-1)*4 ---------------&gt; | index of dynsym (the last row)      |
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR+numDynEntry*4 -------------------&gt; | 1st function (la()) offset in lib   |
// DLINKER_INFO_ADDR+numDynEntry*4+4 -----------------&gt; | 1st function (la()) name (48 bytes) |
//                                                      | ...                                 |
// DLINKER_INFO_ADDR+numDynEntry+(numDynEntry-1)*4 ---&gt; | last function (bar()) offset in lib |
// DLINKER_INFO_ADDR+numDynEntry+(numDynEntry-1)*4+4 -&gt; | last function (bar()) name          |
//                                                      ---------------------------------------
// DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52 --&gt; | .dynstr of lib                      |
//                                                      |   ...                               |
//                                                      ---------------------------------------
  // caculate number of dynamic entries
    numDynEntry = 0;
    j = 0;
    for (i=0; i &lt; 384 &amp;&amp; j == 0; i=i+52) begin
       if (so_func_offset[i] == `MEMEMPTY &amp;&amp; so_func_offset[i+1] == `MEMEMPTY &amp;&amp; 
           so_func_offset[i+2] == `MEMEMPTY &amp;&amp; so_func_offset[i+3] == `MEMEMPTY) begin
         numDynEntry = i/52;
         j = 1;
       `ifdef DEBUG_DLINKER
         $display("numDynEntry = %8x", numDynEntry);
       `endif
       end
    end
  // save number of dynamic entries to memory address `DLINKER_INFO_ADDR
    m[`DLINKER_INFO_ADDR] = numDynEntry[31:24];
    m[`DLINKER_INFO_ADDR+1] = numDynEntry[23:16];
    m[`DLINKER_INFO_ADDR+2] = numDynEntry[15:8];
    m[`DLINKER_INFO_ADDR+3] = numDynEntry[7:0];
  // copy section .dynsym of ELF to memory address `DLINKER_INFO_ADDR+4
    i = `DLINKER_INFO_ADDR+4;
    for (j=0; j &lt; (4*numDynEntry); j=j+4) begin
      m[i] = dsym[j];
      m[i+1] = dsym[j+1];
      m[i+2] = dsym[j+2];
      m[i+3] = dsym[j+3];
      i = i + 4;
    end
  // copy the offset values of section .text of shared library .so of ELF to 
  // memory address `DLINKER_INFO_ADDR+4+numDynEntry*4
    i = `DLINKER_INFO_ADDR+4+numDynEntry*4;
    l = 0;
    for (j=0; j &lt; numDynEntry; j=j+1) begin
      for (k=0; k &lt; 52; k=k+1) begin
        m[i] = so_func_offset[l];
        i = i + 1;
        l = l + 1;
      end
    end
  `ifdef DEBUG_DLINKER
    i = `DLINKER_INFO_ADDR+4+numDynEntry*4;
    for (j=0; j &lt; (8*numDynEntry); j=j+8) begin
       $display("%8x: %8x", i, {m[i], m[i+1], m[i+2], m[i+3]});
      i = i + 8;
    end
  `endif
  // copy section .dynstr of ELF to memory address 
  // `DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52
    i=`DLINKER_INFO_ADDR+4+numDynEntry*4+numDynEntry*52;
    for (j=0; dstr[j] != `MEMEMPTY; j=j+1) begin
      m[i] = dstr[j];
      i = i + 1;
    end
  `ifdef DEBUG_DLINKER
    $display("In setDynLinkerInfo()");
    for (i=`DLINKER_INFO_ADDR; i &lt; `MEMSIZE; i=i+4) begin
       if (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || 
         m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY)
         $display("%8x: %8x", i, {m[i], m[i+1], m[i+2], m[i+3]});
    end
    $display("global address %8x", {m[`GPADDR], m[`GPADDR+1], 
             m[`GPADDR+2], m[`GPADDR+3]});
    $display("gp = %8x", gp);
  `endif
// below code set memory as follows,
//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                          |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address      | (4 bytes)
//                                    | ...                        |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8'h10 ----------------&gt; | 32'h10: pointer to plt0         |
// gpPlt+16+1*8'h10 ----------------&gt; | 1st plt entry                   |
// gpPlt+16+2*8'h10 ----------------&gt; | 2nd plt entry                   |
//                                    | ...                             |
// gpPlt+16+(numDynEntry-1)*8'h10 --&gt; | the last plt entry              |
//                                    -----------------------------------
// note: gp point to the _GLOBAL_OFFSET_TABLE_, 
//       numDynEntry = actual number of functions + 1.
//   gp+1*4..gp+numDynEntry*4 set to 8'h10 plt0 which will jump to dynamic 
//   linker.
//   After dynamic linker load function to memory, it will set gp+index*4 to 
//   function memory address. For example, if the function index is 2, then the 
//   gp+2*4 is set to the memory address of this loaded function. 
//   Then the the caller call 
//   "ld $t9, 2*4($gp)" and "ret $t9" will jump to this loaded function directly.

    gpPlt = gp+16+numDynEntry*4;
    // set (gpPlt-16..gpPlt-1) to 0
    for (j=16; j &gt;= 1; j=j-1)
      m[gpPlt+j] = 8'h00;
    // put plt in (gpPlt..gpPlt+numDynEntry*8'h10+1)
    for (i=1; i &lt; numDynEntry; i=i+1) begin
      // (gp+'8h10..gp+numDynEntry*'8h10+15) set to plt entry
      // addiu	$t9, $zero, dynsym_idx
      m[gpPlt+i*8'h10] = 8'h09;
      m[gpPlt+i*8'h10+1] = 8'h60;
      m[gpPlt+i*8'h10+2] = i[15:8];
      m[gpPlt+i*8'h10+3] = i[7:0];
      // st	$t9, 0($gp)
      m[gpPlt+i*8'h10+4] = 8'h02;
      m[gpPlt+i*8'h10+5] = 8'h6b;
      m[gpPlt+i*8'h10+6] = 0;
      m[gpPlt+i*8'h10+7] = 0;
      // ld	$t9, ('16h0010)($gp)
      m[gpPlt+i*8'h10+8] = 8'h01;
      m[gpPlt+i*8'h10+9] = 8'h6b;
      m[gpPlt+i*8'h10+10] = 0;
      m[gpPlt+i*8'h10+11] = 8'h10;
      // ret	$t9
      m[gpPlt+i*8'h10+12] = 8'h3c;
      m[gpPlt+i*8'h10+13] = 8'h60;
      m[gpPlt+i*8'h10+14] = 0;
      m[gpPlt+i*8'h10+15] = 0;
    end

  // .got.plt offset(0x00.0x03) has been set to 0 in elf already.
  // Set .got.plt offset(8'h10..numDynEntry*'8h10) point to plt entry as above.
  `ifdef DEBUG_DLINKER
         $display("numDynEntry = %8x", numDynEntry);
  `endif
//      j32=32'h1fc0; // m[32'h1fc]="something" will hang. Very tricky
    m[gp+16] = 8'h0;
    m[gp+16+1] = 8'h0;
    m[gp+16+2] = 8'h0;
    m[gp+16+3] = 8'h10;
    j32=gpPlt+16;
    for (i=1; i &lt; numDynEntry; i=i+1) begin
      m[gp+16+i*4] = j32[31:24];
      m[gp+16+i*4+1] = j32[23:16];
      m[gp+16+i*4+2] = j32[15:8];
      m[gp+16+i*4+3] = j32[7:0];
      j32=j32+16;
    end
  `ifdef DEBUG_DLINKER
    // show (gp..gp+numDynEntry*4-1)
    for (i=0; i &lt; numDynEntry; i=i+1) begin
      $display("%8x: %8x", gp+16+i*4, {m[gp+16+i*4], m[gp+16+i*4+1], 
               m[gp+16+i*4+2], m[gp+16+i*4+3]});
    end
    // show (gpPlt..gpPlt+(numDynEntry+1)*8'h10-1)
    for (i=0; i &lt; numDynEntry; i=i+1) begin
      for (j=0; j &lt; 16; j=j+4)
        $display("%8x: %8x", gpPlt+i*8'h10+j, 
                 {m[gpPlt+i*8'h10+j], 
                  m[gpPlt+i*8'h10+j+1], 
                  m[gpPlt+i*8'h10+j+2], 
                  m[gpPlt+i*8'h10+j+3]});
    end
  `endif
  end endtask
`endif

`ifdef DLINKER
  task loadToFlash; begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       flash[i] = `MEMEMPTY;
    end
    $readmemh("libso.hex", flash);
  `ifdef DEBUG_DLINKER
    for (i=0; i &lt; `MEMSIZE &amp;&amp; (flash[i] != `MEMEMPTY || 
         flash[i+1] != `MEMEMPTY || flash[i+2] != `MEMEMPTY || 
         flash[i+3] != `MEMEMPTY); i=i+4) begin
       $display("%8x: %8x", i, {flash[i], flash[i+1], flash[i+2], flash[i+3]});
    end
  `endif
  end endtask
`endif

`ifdef DLINKER
  task createDynInfo; begin
    $readmemh("global_offset", globalAddr);
    m[`GPADDR]   = globalAddr[0];
    m[`GPADDR+1] = globalAddr[1];
    m[`GPADDR+2] = globalAddr[2];
    m[`GPADDR+3] = globalAddr[3];
    gp[31:24] = globalAddr[0];
    gp[23:16] = globalAddr[1];
    gp[15:8] = globalAddr[2];
    gp[7:0] = globalAddr[3];
  `ifdef DEBUG_DLINKER
    $display("global address %8x", {m[`GPADDR], m[`GPADDR+1], 
             m[`GPADDR+2], m[`GPADDR+3]});
    $display("gp = %8x", gp);
  `endif
`endif
`ifdef DLINKER
    for (i=0; i &lt; 192; i=i+1) begin
       dsym[i] = `MEMEMPTY;
    end
    for (i=0; i &lt; 96; i=i+1) begin
       dstr[i] = `MEMEMPTY;
    end
    for (i=0; i &lt;384; i=i+1) begin
       so_func_offset[i] = `MEMEMPTY;
    end
    $readmemh("dynsym", dsym);
    $readmemh("dynstr", dstr);
    $readmemh("so_func_offset", so_func_offset);
    setDynLinkerInfo();
  end endtask
`endif

</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/flashio.v</p>
<div class="highlight-c++"><pre>`define FLASHADDR 'hA0000

`ifdef DLINKER
    end else if (abus &gt;= `FLASHADDR &amp;&amp; abus &lt;= `FLASHADDR+`MEMSIZE-4) begin
      fabus = abus-`FLASHADDR;
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        case (m_size)
        `BYTE:  {flash[fabus]} = dbus_in[7:0];
        `INT16: {flash[fabus], flash[fabus+1] } = dbus_in[15:0];
        `INT24: {flash[fabus], flash[fabus+1], flash[fabus+2]} = dbus_in[24:0];
        `INT32: {flash[fabus], flash[fabus+1], flash[fabus+2], flash[fabus+3]} 
                = dbus_in;
        endcase
      end else if (en == 1 &amp;&amp; rw == 1) begin// r_w==1:read
        case (m_size)
        `BYTE:  data = {8'h00  , 8'h00,   8'h00,   flash[fabus]};
        `INT16: data = {8'h00  , 8'h00,   flash[fabus], flash[fabus+1]};
        `INT24: data = {8'h00  , flash[fabus], flash[fabus+1], flash[fabus+2]};
        `INT32: data = {flash[fabus], flash[fabus+1], flash[fabus+2], 
                       flash[fabus+3]};
        endcase
      end else
        data = 32'hZZZZZZZZ;
`endif

</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/cpu0Id.v</p>
<div class="highlight-c++"><pre>`define DLINKER  // Dynamic Linker Support
//`define DEBUG_DLINKER   // Dynamic Linker Debug
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/cpu0IId.v</p>
<div class="highlight-c++"><pre>`define CPU0II
`define DLINKER  // Dynamic Linker Support
//`define DEBUG_DLINKER   // Dynamic Linker Debug
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>The following code ch_dynamiclinker.cpp and foobar.cpp is the example for
dynamic linker demostration. File dynamic_linker.cpp is what our implementaion
to execute the dynamic linker function on Cpu0 Verilog machine.</p>
<p class="rubric">lbdex/InputFiles/debug.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef _DEBUG_H_</span>
<span class="cp">#define _DEBUG_H_</span>

<span class="cp">#define STOP \</span>
<span class="cp">  asm(&quot;lui $t9, 0xffff&quot;); \</span>
<span class="cp">  asm(&quot;addiu $t9, $zero, 0xffff&quot;); \</span>
<span class="cp">  asm(&quot;ret $t9&quot;);</span>

<span class="cp">#define ENABLE_TRACE \</span>
<span class="cp">  asm(&quot;mfsw $at&quot;); \</span>
<span class="cp">  asm(&quot;ori $at, $at, 0x0020&quot;); \</span>
<span class="cp">  asm(&quot;mtsw $at&quot;);</span>

<span class="cp">#define DISABLE_TRACE \</span>
<span class="cp">  asm(&quot;mfsw $at&quot;); \</span>
<span class="cp">  asm(&quot;andi $at, $at, 0xffdf&quot;); \</span>
<span class="cp">  asm(&quot;mtsw $at&quot;);</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/dynamic_linker.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef _DYNAMIC_LINKER_H_</span>
<span class="cp">#define _DYNAMIC_LINKER_H_</span>

<span class="cp">#define DYNLINKER_INFO_ADDR  0x70000</span>
<span class="cp">#define DYNENT_SIZE          4</span>
<span class="cp">#define DYNPROGSTART         0x40000</span>
<span class="cp">#define FLASHADDR            0xA0000</span>
<span class="cp">#define GPADDR               0x7FFF0</span>

<span class="cp">#include &quot;debug.h&quot;</span>

<span class="k">struct</span> <span class="n">ProgAddr</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">memAddr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">size</span><span class="p">;</span>
<span class="p">};</span>

<span class="k">extern</span> <span class="kt">void</span> <span class="nf">dynamic_linker_init</span><span class="p">();</span>
<span class="k">extern</span> <span class="kt">void</span> <span class="nf">dynamic_linker</span><span class="p">();</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/dynamic_linker.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>

<span class="c1">//#define DEBUG_DLINKER</span>
<span class="cp">#define PLT0ADDR 0x10</span>
<span class="cp">#define REGADDR  0x7ff00</span>

<span class="cp">#define SAVE_REGISTERS          \</span>
<span class="cp">  asm(&quot;lui $at, 7&quot;);            \</span>
<span class="cp">  asm(&quot;ori $at, $at, 0xff00&quot;);  \</span>
<span class="cp">  asm(&quot;st $2, 0($at)&quot;);         \</span>
<span class="cp">  asm(&quot;st $3, 4($at)&quot;);         \</span>
<span class="cp">  asm(&quot;st $4, 8($at)&quot;);         \</span>
<span class="cp">  asm(&quot;st $5, 12($at)&quot;);        \</span>
<span class="cp">  asm(&quot;st $6, 16($at)&quot;);        \</span>
<span class="cp">  asm(&quot;st $7, 20($at)&quot;);        \</span>
<span class="cp">  asm(&quot;st $8, 24($at)&quot;);        \</span>
<span class="cp">  asm(&quot;st $9, 28($at)&quot;);        \</span>
<span class="cp">  asm(&quot;st $10, 32($at)&quot;);       \</span>
<span class="cp">  asm(&quot;st $11, 36($at)&quot;);</span>

<span class="cp">#define RESTORE_REGISTERS       \</span>
<span class="cp">  asm(&quot;lui $at, 7&quot;);            \</span>
<span class="cp">  asm(&quot;ori $at, $at, 0xff00&quot;);  \</span>
<span class="cp">  asm(&quot;ld $2, 0($at)&quot;);         \</span>
<span class="cp">  asm(&quot;ld $3, 4($at)&quot;);         \</span>
<span class="cp">  asm(&quot;ld $4, 8($at)&quot;);         \</span>
<span class="cp">  asm(&quot;ld $5, 12($at)&quot;);        \</span>
<span class="cp">  asm(&quot;ld $6, 16($at)&quot;);        \</span>
<span class="cp">  asm(&quot;ld $7, 20($at)&quot;);        \</span>
<span class="cp">  asm(&quot;ld $8, 24($at)&quot;);        \</span>
<span class="cp">  asm(&quot;ld $9, 28($at)&quot;);        \</span>
<span class="cp">  asm(&quot;ld $10, 32($at)&quot;);       \</span>
<span class="cp">  asm(&quot;ld $11, 36($at)&quot;);</span>


<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="kt">int</span> <span class="n">got_plt_fill</span><span class="p">[</span><span class="mh">0x80</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">1</span>
<span class="p">};</span>

<span class="kt">int</span> <span class="n">progCounter</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// program counter, init to 0 in main()</span>

<span class="n">ProgAddr</span> <span class="n">prog</span><span class="p">[</span><span class="mi">10</span><span class="p">];</span>

<span class="kt">void</span> <span class="nf">dynamic_linker</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">SAVE_REGISTERS</span><span class="p">;</span>
<span class="c1">//  static ProgAddr prog[10]; // has side effect (ProgAddr cannot be written in </span>
<span class="c1">// Virtual Box on iMac).</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nextFreeAddr</span><span class="p">;</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">src</span><span class="p">,</span> <span class="o">*</span><span class="n">dest</span><span class="p">,</span> <span class="o">*</span><span class="n">end</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">numDynEntry</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">dynsym_idx</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">dynsym</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">dynstr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">libOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">nextFunLibOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">volatile</span> <span class="kt">int</span> <span class="n">memAddr</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">numDynEntry</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="p">));</span>
  <span class="kt">int</span> <span class="n">gp</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">GPADDR</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;gp = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">gp</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="n">dynsym_idx</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">gp</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;numDynEntry = %d, dynsym_idx = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">numDynEntry</span><span class="p">,</span> <span class="n">dynsym_idx</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="n">dynsym</span> <span class="o">=</span> <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)((</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="p">)</span><span class="o">+</span><span class="p">(</span><span class="n">dynsym_idx</span><span class="o">*</span><span class="n">DYNENT_SIZE</span><span class="p">));</span>
  <span class="n">dynstr</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">52</span><span class="o">+</span><span class="n">dynsym</span><span class="p">);</span>
  <span class="n">libOffset</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="p">(</span><span class="n">dynsym_idx</span><span class="o">-</span><span class="mi">1</span><span class="p">)</span><span class="o">*</span><span class="mi">52</span><span class="p">));</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="n">dynsym_idx</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">numDynEntry</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">nextFunLibOffset</span> <span class="o">=</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">DYNLINKER_INFO_ADDR</span><span class="o">+</span><span class="mi">4</span><span class="o">+</span><span class="n">numDynEntry</span><span class="o">*</span><span class="mi">4</span><span class="o">+</span><span class="n">i</span><span class="o">*</span><span class="mi">52</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">libOffset</span> <span class="o">!=</span> <span class="n">nextFunLibOffset</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;address of dstr = %x, dynsym = %d, dstr = %s</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">dynstr</span><span class="p">,</span> <span class="n">dynsym</span><span class="p">,</span> <span class="n">dynstr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;libOffset = %d, nextFunLibOffset = %d, progCounter = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="n">libOffset</span><span class="p">,</span> <span class="n">nextFunLibOffset</span><span class="p">,</span> <span class="n">progCounter</span><span class="p">);</span>
<span class="cp">#endif</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">progCounter</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
     <span class="n">nextFreeAddr</span> <span class="o">=</span> <span class="n">DYNPROGSTART</span><span class="p">;</span>
  <span class="k">else</span>
     <span class="n">nextFreeAddr</span> <span class="o">=</span> <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="o">+</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">size</span><span class="p">;</span>
  <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">memAddr</span> <span class="o">=</span> <span class="n">nextFreeAddr</span><span class="p">;</span>
  <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">size</span> <span class="o">=</span> <span class="p">(</span><span class="n">nextFunLibOffset</span> <span class="o">-</span> <span class="n">libOffset</span><span class="p">);</span>

<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;prog[progCounter].memAddr = %d, prog[progCounter].size = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">memAddr</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">size</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="c1">// Load program from (FLASHADDR+libOffset..FLASHADDR+nextFunLibOffset-1) to</span>
  <span class="c1">// (nextFreeAddr..nextFreeAddr+prog[progCounter].size-1)</span>
  <span class="n">src</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">FLASHADDR</span><span class="o">+</span><span class="n">libOffset</span><span class="p">);</span>
  <span class="n">end</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">src</span><span class="o">+</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">size</span><span class="o">/</span><span class="mi">4</span><span class="p">);</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;end = %x, src = %x, nextFreeAddr = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">end</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">src</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)</span><span class="n">nextFreeAddr</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*src = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">src</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;loading %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dynstr</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">dest</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="p">].</span><span class="n">memAddr</span><span class="p">);</span> <span class="n">src</span> <span class="o">&lt;</span> <span class="n">end</span><span class="p">;</span> <span class="n">src</span><span class="o">++</span><span class="p">,</span> <span class="n">dest</span><span class="o">++</span><span class="p">)</span> <span class="p">{</span>
    <span class="o">*</span><span class="n">dest</span> <span class="o">=</span> <span class="o">*</span><span class="n">src</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*dest = %08x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="n">dest</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="p">}</span>
  <span class="n">progCounter</span><span class="o">++</span><span class="p">;</span>

<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;progCounter-1 = %x, prog[progCounter-1].memAddr = %x, \</span>
<span class="s">         *prog[progCounter-1].memAddr = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">),</span> 
         <span class="o">*</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">));</span>
<span class="cp">#endif</span>
  <span class="c1">// Change .got.plt for &quot;ld	$t9, idx($gp)&quot;</span>
  <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x10</span><span class="o">+</span><span class="n">dynsym_idx</span><span class="o">*</span><span class="mh">0x04</span><span class="p">))</span> <span class="o">=</span> <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">;</span>
  <span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x7FFE0</span><span class="p">)</span> <span class="o">=</span> <span class="n">prog</span><span class="p">[</span><span class="n">progCounter</span><span class="o">-</span><span class="mi">1</span><span class="p">].</span><span class="n">memAddr</span><span class="p">;</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*((int*)(gp+0x10+dynsym_idx*0x10)) = %x, *(int*)(0x7FFE0) = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x10</span><span class="o">+</span><span class="n">dynsym_idx</span><span class="o">*</span><span class="mh">0x10</span><span class="p">)),</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span><span class="p">)(</span><span class="o">*</span><span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="mh">0x7FFE0</span><span class="p">)));</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;*((int*)(gp+0x04)) = %x, *((int*)(gp+0x08)) = %x, *((int*)(gp+0x0c)) = %x</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> 
         <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x04</span><span class="p">)),</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x08</span><span class="p">)),</span> <span class="o">*</span><span class="p">((</span><span class="kt">int</span><span class="o">*</span><span class="p">)(</span><span class="n">gp</span><span class="o">+</span><span class="mh">0x0c</span><span class="p">)));</span>
<span class="cp">#endif</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;run %s...</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">dynstr</span><span class="p">);</span>
  <span class="n">RESTORE_REGISTERS</span><span class="p">;</span>

  <span class="c1">// restore $lr. The next instruction of foo() of main.cpp for the main.cpp</span>
  <span class="c1">// call foo() first time example.</span>
  <span class="c1">// The $lr, $fp and $sp saved in cpu0Plt0AtomContent of Cpu0LinkingContext.cpp.</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $lr, 4($gp)&quot;</span><span class="p">);</span> <span class="c1">// restore $lr</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">ENABLE_TRACE</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $fp, 8($gp)&quot;</span><span class="p">);</span> <span class="c1">// restore $fp</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $sp, 12($gp)&quot;</span><span class="p">);</span> <span class="c1">// restore $sp</span>
<span class="cp">#ifdef DEBUG_DLINKER</span>
  <span class="n">DISABLE_TRACE</span><span class="p">;</span>
<span class="cp">#endif</span>
  <span class="c1">// jmp to the dynamic linked function. It&#39;s foo() for the </span>
  <span class="c1">// caller, ch_dynamic_linker.cpp, call foo() </span>
  <span class="c1">// first time example.</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;lui $t9, 0x7&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ori $t9, $t9, 0xFFE0&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $t9, 0($t9)&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ret $t9&quot;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch_dynamiclinker.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>
<span class="cp">#include &quot;print.h&quot;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">extern</span> <span class="kt">int</span> <span class="nf">la</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">);</span>
<span class="k">extern</span> <span class="kt">int</span> <span class="nf">bar</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
<span class="c1">//  ENABLE_TRACE;</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

<span class="cp">#if 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;foo(1, 2) = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">bar</span><span class="p">();</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;bar() = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>
<span class="cp">#endif</span>
<span class="cp">#if 0</span><span class="c"></span>
<span class="c">  a = foo(1, 2);</span>
<span class="c">  printf(&quot;foo(1, 2) = %d\n&quot;, a);</span>
<span class="cp">#endif</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/foobar.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;dynamic_linker.h&quot;</span>

<span class="kt">int</span> <span class="nf">la</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">foo</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">int factorial(int x)</span>
<span class="c">{</span>
<span class="c">  if (x &gt; 0)</span>
<span class="c">    return x*factorial(x-1);</span>
<span class="c">  else</span>
<span class="c">    return 1;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="kt">int</span> <span class="nf">bar</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span><span class="p">;</span>
<span class="c1">//  ENABLE_TRACE;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">foo</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">+=</span> <span class="n">la</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">);</span> <span class="c1">// 4+7=11</span>
<span class="c1">//  a += factorial(4); // 11+24=35</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/build-dlinker.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash
TOOLDIR=/usr/local/llvm/test/cmake_debug_build/bin
#TOOLDIR=~/test/llvm/cmake_debug_build/bin/Debug

cpu=cpu032I

clang -target mips-unknown-linux-gnu -c start.cpp -emit-llvm -o start.bc
clang -target mips-unknown-linux-gnu -c dynamic_linker.cpp -emit-llvm -o
dynamic_linker.cpu0.bc
clang -target mips-unknown-linux-gnu -c printf-stdarg.c -emit-llvm -o
printf-stdarg.bc
clang -target mips-unknown-linux-gnu -c foobar.cpp -emit-llvm -o foobar.cpu0.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
-cpu0-reserve-gp=true dynamic_linker.cpu0.bc -o dynamic_linker.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
-cpu0-reserve-gp=true printf-stdarg.bc -o printf-stdarg.cpu0.o
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=pic -filetype=obj
-cpu0-reserve-gp=true -cpu0-no-cpload=true foobar.cpu0.bc -o foobar.cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu -shared -o
libfoobar.cpu0.so foobar.cpu0.o
${TOOLDIR}/llc -mcpu=${cpu} -march=cpu0 -relocation-model=static -filetype=obj
-cpu0-reserve-gp=true start.bc -o start.cpu0.o
/usr/local/llvm/release/cmake_debug_build/bin/clang -target mips-unknown-linux-
gnu -c ch_dynamiclinker.cpp -emit-llvm -o ch_dynamiclinker.cpu0.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj
-cpu0-reserve-gp=true ch_dynamiclinker.cpu0.bc -o ch_dynamiclinker.cpu0.o
${TOOLDIR}/lld -flavor gnu -target cpu0-unknown-linux-gnu start.cpu0.o printf-
stdarg.cpu0.o dynamic_linker.cpu0.o ch_dynamiclinker.cpu0.o libfoobar.cpu0.so
${TOOLDIR}/llvm-objdump -elf2hex -cpu0dumpso libfoobar.cpu0.so &gt; ../
cpu0_verilog/libso.hex
${TOOLDIR}/llvm-objdump -elf2hex -cpu0linkso a.out &gt; ../cpu0_verilog/cpu0.hex
cp dynstr dynsym so_func_offset global_offset ../cpu0_verilog/.</pre>
</div>
<div class="section" id="id7">
<h3>Run<a class="headerlink" href="#id7" title="Permalink to this headline">¶</a></h3>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbd/docs/BackendTutorial/source_ExampleCode/cpu0_verilog
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>bash clean.sh
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../InputFiles/
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>bash build-dlinker.sh
1-160-136-173:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/lbd/docs/BackendTutorial/source_ExampleCode/cpu0_verilog
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0IId cpu0IId.v
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>ls
clean.sh  cpu0Id  cpu0Id.v  cpu0IId.v  cpu0IIs.v  cpu0Is.v  cpu0.v  dynlinker.v
flashio.v
1-160-136-173:cpu0_verilog Jonathan<span class="nv">$ </span>./cpu0Id
WARNING: ./cpu0.v:371: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for</span>
the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
WARNING: ./dynlinker.v:185: <span class="nv">$readmemh</span><span class="o">(</span>libso.hex<span class="o">)</span>: Not enough words in the
file <span class="k">for </span>the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
WARNING: ./dynlinker.v:223: <span class="nv">$readmemh</span><span class="o">(</span>dynsym<span class="o">)</span>: Not enough words in the file
<span class="k">for </span>the requested range <span class="o">[</span>0:191<span class="o">]</span>.
WARNING: ./dynlinker.v:224: <span class="nv">$readmemh</span><span class="o">(</span>dynstr<span class="o">)</span>: Not enough words in the file
<span class="k">for </span>the requested range <span class="o">[</span>0:95<span class="o">]</span>.
WARNING: ./dynlinker.v:225: <span class="nv">$readmemh</span><span class="o">(</span>so_func_offset<span class="o">)</span>: Not enough words in
the file <span class="k">for </span>the requested range <span class="o">[</span>0:383<span class="o">]</span>.
<span class="nv">numDynEntry</span> <span class="o">=</span> 00000005
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
loading _Z3fooii...
run _Z3fooii...
foo<span class="o">(</span>1, 2<span class="o">)</span> <span class="o">=</span> 3
loading _Z3barv...
run _Z3barv...
loading _Z2laii...
run _Z2laii...
bar<span class="o">()</span> <span class="o">=</span> 11
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>The &#8220;#ifdef DEBUG_DLINKER&#8221; part of code in dynamic_linker.cpp is for debugging
purpose (since we coding it and take time to debug). After skip these debug
code, the dynamic_linker.cpp is short and not difficult to read.</p>
<p>The run result is under expectation. The main() call foo() function first.
Function foo() is loaded by dynamic linker (dynamic_linker.cpp) from flash
address FLASHADDR (defined in dynamic_linker.h) to memory.
The flashio.v implement the simulation read from flash address.
After loaded foo() body from flash, dynamic_linker.cpp jump to this loaded
address by &#8220;ret $t9&#8221; instruction.</p>
<p>Same as static linker, you can generate slt instruction instead of cmp by
change from cpu=cpu0I to cpu0=cpu0II in build-dlinker.sh and run it again to
get the same result.</p>
</div>
<div class="section" id="how-to-work">
<h3>How to work<a class="headerlink" href="#how-to-work" title="Permalink to this headline">¶</a></h3>
<p>After run build-dlinker.sh, the following files are created.</p>
<p class="rubric">lbdex/cpu0_verilog/cpu0.hex</p>
<div class="highlight-bash"><div class="highlight"><pre>/*Disassembly of section .plt:*/
/*.PLT0:*/
/*       0:*/ 36 00 00 3c                                  /* jmp     60*/
/*       4:*/ 36 00 00 04                                  /* jmp     4*/
/*       8:*/ 36 00 00 04                                  /* jmp     4*/
/*       c:*/ 36 ff ff <span class="nb">fc</span>                                  /* jmp     -4*/

/*.PLT0:*/
/*      10:*/ 02 eb 00 04                                  /* st      <span class="nv">$lr</span>, 4<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>*/
/*      14:*/ 02 cb 00 08                                  /* st      <span class="nv">$fp</span>, 8<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>*/
/*      18:*/ 02 db 00 0c                                  /* st      <span class="nv">$sp</span>, 12<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>*/
/*      1c:*/ 36 00 09 b8                                  /* jmp     2488*/

/*__plt__Z3barv:*/
/*      20:*/ 01 6b 00 24                                  /* ld      <span class="nv">$t9</span>, 36<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>
/*      24:*/ 3c 60 00 00                                  /* ret     <span class="nv">$t9</span>*/
/*      28:*/ 00 00 00 00                                  /* nop*/
/*      2c:*/ 00 00 00 00                                  /* nop*/

/*__plt__Z3fooii:*/
/*      30:*/ 01 6b 00 1c                                  /* ld      <span class="nv">$t9</span>, 28<span class="o">(</span><span class="nv">$gp</span><span class="o">)</span>
/*      34:*/ 3c 60 00 00                                  /* ret     <span class="nv">$t9</span>*/
/*      38:*/ 00 00 00 00                                  /* nop*/
/*      3c:*/ 00 00 00 00                                  /* nop*/
...

/*main:*/
...
/*     d68:*/ 3b ff f2 b4                                  /* jsub    16773812*/ // call foo<span class="o">()</span>
...
/*     d80:*/ 3b ff f3 28                                  /* jsub    16773928*/ // call <span class="nb">printf</span><span class="o">()</span>
/*     d84:*/ 3b ff f2 a8                                  /* jsub    16773800*/ // call bar<span class="o">()</span>
...
/*     d9c:*/ 3b ff f3 0c                                  /* jsub    16773900*/ // call <span class="nb">printf</span><span class="o">()</span>
...
/*     db8:*/ 3c e0 00 00                                  /* ret     <span class="nv">$lr</span>*/
...
/*Contents of section .data:*/
/*20a8 */00 00 00 01  00 00 00 01  00 00 00 01  00 00 00 01 /*  ................*/
...
</pre></div>
</div>
<p class="rubric">lbdex/cpu0_verilog/dynstr</p>
<div class="highlight-bash"><div class="highlight"><pre>00 5f 5f 74 6c 73 5f 67 65 74 5f 61 64 64 72 00 5f 5a 32 6c 61 69 69 00 5f 5a
35 70 6f 77 65 72 69 00 5f 5a 33 66 6f 6f 69 69 00 5f 5a 33 62 61 72 76 00 5f
47 4c 4f 42 41 4c 5f 4f 46 46 53 45 54 5f 54 41 42 4c 45 5f 00 5f 44 59 4e 41
4d 49 43 00
</pre></div>
</div>
<p class="rubric">lbdex/cpu0_verilog/dynsym</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">01</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">10</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">18</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">22</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">2</span><span class="n">b</span> <span class="mo">00</span> <span class="mo">00</span>
<span class="mo">00</span> <span class="mi">33</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mo">00</span> <span class="mi">49</span>
</pre></div>
</div>
<p class="rubric">lbdex/cpu0_verilog/global_offset</p>
<div class="highlight-bash"><div class="highlight"><pre>00 00 20 68
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/num_dyn_entry</p>
<div class="highlight-bash"><div class="highlight"><pre>6
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/libfoobar.cpu0.so</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/
llvm-objdump -s libfoobar.cpu0.so

libfoobar.cpu0.so:    file format ELF32-CPU0

Contents of section :
...
Contents of section .dynsym:
 00e4 00000000 00000000 00000000 00000000  ................
 00f4 00000001 0000019c 00000000 12000004  ................
 0104 00000010 0000019c 0000003c 12000004  ...........&lt;....
 0114 00000018 000001d8 00000038 12000004  ...........8....
 0124 00000021 00000210 00000070 12000004  ...!.......p....
 0134 00000029 00001040 00000000 10000006  ...<span class="o">)</span>...@........
 0144 0000003f 00001040 00000000 11000005  ...?...@........
Contents of section .dynstr:
 0154 005f5f74 6c735f67 65745f61 64647200  .__tls_get_addr.
 0164 5f5a326c 61696900 5f5a3366 6f6f6969  _Z2laii._Z3fooii
 0174 005f5a33 62617276 005f474c 4f42414c  ._Z3barv._GLOBAL
 0184 5f4f4646 5345545f 5441424c 455f005f  _OFFSET_TABLE_._
 0194 44594e41 4d494300                    DYNAMIC.
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/a.out</p>
<div class="highlight-bash"><div class="highlight"><pre>1-160-136-173:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/
llvm-objdump -s a.out

a.out:        file format ELF32-CPU0

Contents of section :
...
Contents of section .dynsym:
 013c 00000000 00000000 00000000 00000000  ................
 014c 00000001 00000000 00000000 12000000  ................
 015c 0000000a 00000000 00000000 12000000  ................
Contents of section .dynstr:
 016c 005f5a33 666f6f69 69005f5a 33626172  ._Z3fooii._Z3bar
 017c 76006c69 62666f6f 6261722e 63707530  v.libfoobar.cpu0
 018c 2e736f00                             .so.
...
Contents of section .got.plt:
 2068 00000000 00000000 00000000 00000000  ................
 2078 00000000 00000000 00000000 00000000  ................
 2088 000001d0 00000000 00000000 00000000  ................
 2098 000001e0 00000000 00000000 00000000  ................
Contents of section .data:
 20a8 00000001 00000001 00000001 00000001  ................
</pre></div>
</div>
<p>File dynstr is section .dynstr of libfoobar.cpu0.so. File dynsym is the first
4 bytes of every entry of .dynsym. File global_offset contains the start address
of section .got.plt.</p>
<p>The code of dynlinker.v will set the memory as follows after program is loaded.
(gp value below is 2068 came from file global_offset).</p>
<p class="rubric">memory contents</p>
<div class="highlight-bash"><pre>//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                          |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address      | (4 bytes)
//                                    | ...                        |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8'h10 ----------------&gt; | 32'h10: pointer to plt0         |
// gpPlt+16+1*8'h10 ----------------&gt; | 1st plt entry                   |
// gpPlt+16+2*8'h10 ----------------&gt; | 2nd plt entry                   |
//                                    | ...                             |
// gpPlt+16+(numDynEntry-1)*8'h10 --&gt; | the last plt entry              |
//                                    -----------------------------------</pre>
</div>
<p>For example as ch_dynamiclinker.cpp and foobar.cpp, gp is 2068, numDynEntry is
the contents of file num_dyn_entry which is 6. Every plt entry above (memory
address gp+16+1*8&#8217;h10..gp+16+(numDynEntry-1)*8&#8217;h10) is initialize to &#8220;addiu     $t9,
$zero, 4($gp); st       $t9, 0($gp); ld $t9, 16($gp); ret       $t9&#8221; as follows,</p>
<p class="rubric">memory contents</p>
<div class="highlight-bash"><pre>//                                    -----------------------------------
// gp ------------------------------&gt; | all 0                           | (16 bytes)
// gp+16 ---------------------------&gt; | 0                          |
// gp+16+1*4 -----------------------&gt; | 1st plt entry address      | (4 bytes)
//                                    | ...                        |
// gp+16+(numDynEntry-1)*4 ---------&gt; | the last plt entry address |
//                                    -----------------------------------
// gpPlt ---------------------------&gt; | all 0                           | (16 bytes)
// gpPlt+16+0*8'h10 ----------------&gt; | 32'h10: pointer to plt0         |
// gpPlt+16+1*8'h10 ----------------&gt; | addiu $t9, $zero, 4             |
//                                    | st  $t9, 0($gp)                 |
//                                    | ld  $t9, 16($gp)                |
//                                    | ret $t9                         |
// gpPlt+16+2*8'h10 ----------------&gt; | addiu $t9, $zero, 4             |
//                                    | st  $t9, 0($gp)                 |
//                                    | ld  $t9, 16($gp)                |
//                                    | ret $t9                         |
// ...                                | ...                             |
// gpPlt+16+(6-1)*8'h10 ------------&gt; | addiu $t9, $zero, 4             |
//                                    | st  $t9, 0($gp)                 |
//                                    | ld  $t9, 16($gp)                |
//                                    | ret $t9                         |
//                                    -----------------------------------</pre>
</div>
<p><a class="pageref" href="#lld-f6">Figure  8</a> is the memory content after the example program is loaded.</p>
<div class="figure align-center" id="lld-f6">
<a class="reference internal image-reference" href="_images/64.png"><img alt="_images/64.png" src="_images/64.png" /></a>
<p class="caption">Figure 8: Memory content after the program is loaded</p>
</div>
<div class="figure align-center" id="lld-f7">
<a class="reference internal image-reference" href="_images/73.png"><img alt="_images/73.png" src="_images/73.png" /></a>
<p class="caption">Figure 9: Control flow transfer from calling foo() instruction of main() to dynamic linker</p>
</div>
<p><a class="pageref" href="#lld-f7">Figure  9</a> is the Control flow transfer from call foo() of main() to
dynamic linker. After ch_dynamiclinker.cpp call foo() first time, it jump to
__plt_Z3fooii plt entry. In __plt_Z3fooii, &#8220;ld $t9, 1c($gp)&#8221; and &#8220;ret $t9&#8221; will
jump to &#8220;Plt foo:&#8221;. Since foo is the 3rd plt entry, in &#8220;Plt foo:&#8221;
it save 3 to 0($gp) memory address then jump to PLT0. The PLT0 purpose is to
save $lr, $fp, $sp and jump to dynamic linker.
Now, the control flow transfer to dynamic linker.
Dynamic linker will get the loaded function name and function offset of shared
library by the value of 0($gp) which is 3 set in &#8220;Plt foo:&#8221;. The value
3 tells dynamic linker loading foo() (3rd string in .dynstr) from offset of
shared library, 0x3c (3rd value of Function offset area in Figure).
Now, dynamic linker can load foo() function from flash to memory, set the
address gp+3*4 to 0x40000 where the address 0x40000 is the foo() function is
loaded to memory and prepare jump to the foo() memory address.
Remind we say the prepare jump to foo(). Because
before jump to foo(), dynamic linker need to restore the $lr, $fp, $sp to the
value of just before caller calling foo() (they are saved in 4, 8, 12 of $gp
offset in PLT0, so them can be restored from that address).</p>
<div class="figure align-center" id="lld-f8">
<a class="reference internal image-reference" href="_images/83.png"><img alt="_images/83.png" src="_images/83.png" /></a>
<p class="caption">Figure 10: Transfer from dynamic linker to foo() and back to main()</p>
</div>
<p>As <a class="pageref" href="#lld-f8">Figure  10</a> depicted, control flow from dynamic linker to foo() and
back to caller main() when it meets the instruction &#8220;ret $lr&#8221; in foo().</p>
<div class="figure align-center" id="lld-f9">
<a class="reference internal image-reference" href="_images/93.png"><img alt="_images/93.png" src="_images/93.png" /></a>
<p class="caption">Figure 11: Control flow transfer from calling bar() instruction of main() to dynamic linker</p>
</div>
<div class="figure align-center" id="lld-f10">
<a class="reference internal image-reference" href="_images/103.png"><img alt="_images/103.png" src="_images/103.png" /></a>
<p class="caption">Figure 12: Dynamic linker load bar() from flash to memory</p>
</div>
<p>Now the program run at the next instruction of call foo() in main() as
<a class="pageref" href="#lld-f9">Figure  11</a> depicted. When it run
to address 0xd8 &#8220;jsub __plt__Z3barv&#8221;, the control flow will transfer from
main through __plt_Z3barv, &#8220;Plt bar:&#8221; and PLT0 to dynamic linker as
<a class="pageref" href="#lld-f9">Figure  11</a> depicted. Then load and run bar() from flash to memory
just like the calling __plt__Z3fooii as <a class="pageref" href="#lld-f10">Figure  12</a> depicted.
The difference is bar() will call foo() first and call la() next.
The call foo() in bar() will jump to foo() directly as
<a class="pageref" href="#lld-f9">Figure  11</a> because the content of gp+28 is the address of 0x40000 which
set in dynamic linker when the foo() function is called first time.</p>
<p>Finally when bar() call la() function it will jump to &#8220;Plt la:&#8221; since the
content of $gp+24 point to &#8220;Plt la:&#8221;.
The &#8220;Plt la:&#8221; code will call dynamic linker
to load la() function, run la() and back to bar() as <a class="pageref" href="#lld-f11">Figure  13</a>.</p>
<div class="figure align-center" id="lld-f11">
<a class="reference internal image-reference" href="_images/112.png"><img alt="_images/112.png" src="_images/112.png" /></a>
<p class="caption">Figure 13: Call la through &#8220;Plt la:&#8221; in bar()</p>
</div>
<p>The dynamic linker implementation usually is not specified in ABI. It need the
co-work between linker and dynamic linker/loader. It use the pointers (the area
from gp+16+1*4 to gp+16+(numDynEntry-1)*4). When the code is loaded, this
corresponding pointer in this area point to the loaded memory. Otherwise, it
point to dynamic linker. The Plt or __plt_Z3fooii, __pltZ3barv are coding in
our cpu0PltAtomContent[] of Cpu0RelocationPass.cpp. It is called linkage editor
implementation.</p>
</div>
</div>
<div class="section" id="summary">
<h2>Summary<a class="headerlink" href="#summary" title="Permalink to this headline">¶</a></h2>
<div class="section" id="llvm-judgement">
<h3>LLVM judgement<a class="headerlink" href="#llvm-judgement" title="Permalink to this headline">¶</a></h3>
<p>Thanks the llvm open source project.
To write a linker and ELF to Hex tools for a new CPU architecture is easy and
reliable.
Combined with the llvm Cpu0 backend code and Verilog language code we program
in previouse Chapters, we design a software
toolchain to compile C/C++ code, link and run it on Verilog Cpu0 simulated
machine of PC without any real hardware to investment.
If you like to pay money to buy the FPGA development hardware, we believe these
code can run on FPGA CPU even though we didn&#8217;t do it.
Extend system program toolchain to support a new CPU instructions can be
designed just like we show you at this point.
School knowledges of system program, compiler, linker, loader, computer
architecture and CPU design has been translated into a real work and see how it
is run. Now, these school books knowledge is not limited on paper.
We design it, program it, and run it on real world.</p>
<p>The total code size of llvm Cpu0 backend compiler, Cpu0 lld linker, llvm-objdump
with elf2hex Cpu0 support and Cpu0 Verilog Language is under 10 thousands lines
of source code include comments.
The clang, llvm and lld has 1000 thousands lines exclude the
test and documents parts. It is only 1 % of the llvm size.
Based on this truth, we believe llvm is a well defined structure in compiler
architecture.</p>
</div>
<div class="section" id="contribute-back-to-open-source-through-working-and-learning">
<h3>Contribute back to Open Source through working and learning<a class="headerlink" href="#contribute-back-to-open-source-through-working-and-learning" title="Permalink to this headline">¶</a></h3>
<p>Finally, 10 thousands lines of source code in Cpu0 backend is very small in UI
program. But it&#8217;s quite complex in system program which based on llvm.
We spent 500 pages of pdf to explain these code. Open source code give
programmers best opportunity to understand the code and enhance/extend the
code function. But not enough, we believe the documentation is the next most
important thing to improve the open source code development.
The Open Source Organization recognized this point before us and set
Open Source Document Project years ago <a class="footnote-reference" href="#id21" id="id8">[7]</a> <a class="footnote-reference" href="#id22" id="id9">[8]</a> <a class="footnote-reference" href="#id23" id="id10">[9]</a> <a class="footnote-reference" href="#id24" id="id11">[10]</a> <a class="footnote-reference" href="#id25" id="id12">[11]</a>.
Open Source grows up and becomes a giant software infrastructure with the forces
of company <a class="footnote-reference" href="#id26" id="id13">[12]</a>  <a class="footnote-reference" href="#id27" id="id14">[13]</a>, school research team and countless talent engineers passion.
It terminated the situation of everyone trying to re-invent wheels during 10
years ago.
Extend your software from the re-usable source code is the right way.
Of course you should consider an open source license if you are working
with business.
Actually anyone can contribute back to open source through the learning process.
We write this book through the process of learning llvm backend and contribute
back to llvm open source project.
We think this book cannot exists in traditional paper book form since only
few number of readers interested to read this llvm backend book even
there are many paper published books in concept of compiler.
There are distance between the concept and the practice program implemenation.
Keep note through learning a large complicate software is not enough
such as this llvm backend study.
We all learned the knowledge through books during school and after school.
So, if you cannot find a good way to produce documents, you can consider to
write document like this book. This book document use sphinx tool just
like the llvm development team. Appendix A tell you how to install sphinx tool.
Documentation work will help yourself to re-examine your software and make your
program better in structure, reliability and more important &#8220;Extend your code
to somewhere you didn&#8217;t expect&#8221;.</p>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://lld.llvm.org/">http://lld.llvm.org/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://lld.llvm.org/getting_started.html#on-unix-like-systems">http://lld.llvm.org/getting_started.html#on-unix-like-systems</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/releases/download.html#3.4">http://llvm.org/releases/download.html#3.4</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id18" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/">http://www.cplusplus.com/reference/memory/unique_ptr/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id19" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/memory/unique_ptr/get/">http://www.cplusplus.com/reference/memory/unique_ptr/get/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id20" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://www.cplusplus.com/reference/utility/move/">http://www.cplusplus.com/reference/utility/move/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id21" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/BSD_Documentation_License">http://en.wikipedia.org/wiki/BSD_Documentation_License</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id22" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td><a class="reference external" href="http://www.freebsd.org/docproj/">http://www.freebsd.org/docproj/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id23" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id10">[9]</a></td><td><a class="reference external" href="http://www.freebsd.org/copyright/freebsd-doc-license.html">http://www.freebsd.org/copyright/freebsd-doc-license.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id24" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id11">[10]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/GNU_Free_Documentation_License">http://en.wikipedia.org/wiki/GNU_Free_Documentation_License</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id25" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id12">[11]</a></td><td><a class="reference external" href="http://www.gnu.org/copyleft/fdl.html">http://www.gnu.org/copyleft/fdl.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id26" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id13">[12]</a></td><td><a class="reference external" href="http://www.apple.com/opensource/">http://www.apple.com/opensource/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id27" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id14">[13]</a></td><td><a class="reference external" href="https://www.ibm.com/developerworks/opensource/">https://www.ibm.com/developerworks/opensource/</a></td></tr>
</tbody>
</table>
</div>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="optimize.html">Backend Optimization</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="install.html">Appendix A: Getting Started: Installing LLVM and the Cpu0 example code</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>