

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Backend structure &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.3.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Adding arithmetic and local pointer support" href="otherinst.html" />
    <link rel="prev" title="Cpu0 Instruction Set and LLVM Target Description" href="llvmstructure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Backend structure</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Adding arithmetic and local pointer support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="backend-structure">
<span id="sec-backendstructure"></span><h1>Backend structure<a class="headerlink" href="#backend-structure" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduce the back end class inherit tree and class members first.
Next, following the back end structure, adding individual class implementation
in each section.
There are compiler knowledge like DAG (Directed-Acyclic-Graph) and instruction
selection needed in this chapter.
This chapter explains these knowledge just when needed.
At the end of this chapter, we will have a back end to compile llvm
intermediate code into cpu0 assembly code.</p>
<p>Many code are added in this chapter. They almost are common in every back end
except the back end name (cpu0 or mips ...). Actually, we copy almost all the
code from mips and replace the name with cpu0. Please focus on the classes
relationship in this backend structure. Once knowing the structure, you can
create your backend structure as quickly as we did, even though there are 3000
lines of code in this chapter.</p>
<div class="section" id="targetmachine-structure">
<h2>TargetMachine structure<a class="headerlink" href="#targetmachine-structure" title="Permalink to this headline">¶</a></h2>
<p>Your back end should define a TargetMachine class, for example, we define the
Cpu0TargetMachine class.
Cpu0TargetMachine class contains it&#8217;s own instruction class, frame/stack class,
DAG (Directed-Acyclic-Graph) class, and register class.
The Cpu0TargetMachine contents and it&#8217;s own class as follows,</p>
<p class="rubric">include/llvm/Target/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- TargetMachine.h</span>
<span class="k">class</span> <span class="nc">TargetMachine</span> <span class="p">{</span>
  <span class="n">TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="p">...</span>
<span class="k">public</span><span class="o">:</span>
  <span class="c1">// Interfaces to the major aspects of target machine information:</span>
  <span class="c1">// -- Instruction opcode and operand information</span>
  <span class="c1">// -- Pipelines and scheduling information</span>
  <span class="c1">// -- Stack frame information</span>
  <span class="c1">// -- Selection DAG lowering information</span>
  <span class="c1">//</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span>         <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetLowering</span>    <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetSelectionDAGInfo</span> <span class="o">*</span><span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span>             <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
  <span class="c1">/// getSubtarget - This method returns a pointer to the specified type of</span>
  <span class="c1">/// TargetSubtargetInfo.  In debug builds, it verifies that the object being</span>
  <span class="c1">/// returned is of the correct type.</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">STC</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">STC</span> <span class="o">&amp;</span><span class="n">getSubtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">STC</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">getSubtargetImpl</span><span class="p">());</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">LLVMTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetMachine</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span> <span class="c1">// Can only create subclasses.</span>
  <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TargetTriple</span><span class="p">,</span>
          <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="n">TargetOptions</span> <span class="n">Options</span><span class="p">,</span>
          <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
          <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.h - Define TargetMachine for Cpu0 -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetMachine.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETMACHINE_H</span>
<span class="cp">#define CPU0TARGETMACHINE_H</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0SelectionDAGInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">formatted_raw_ostream</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
    <span class="n">Cpu0Subtarget</span>       <span class="n">Subtarget</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">DataLayout</span>    <span class="n">DL</span><span class="p">;</span> <span class="c1">// Calculates type size &amp; alignment</span>
    <span class="n">Cpu0InstrInfo</span>       <span class="n">InstrInfo</span><span class="p">;</span>	<span class="c1">//- Instructions</span>
    <span class="n">Cpu0FrameLowering</span>   <span class="n">FrameLowering</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0TargetLowering</span>  <span class="n">TLInfo</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0SelectionDAGInfo</span> <span class="n">TSInfo</span><span class="p">;</span>	<span class="c1">//- Map .bc DAG to backend DAG</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                      <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0InstrInfo</span>   <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameLowering</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0Subtarget</span>   <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span> <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span>    <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetLowering</span> <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TLInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="o">*</span> <span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TSInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Pass Pipeline Configuration</span>
    <span class="k">virtual</span> <span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">);</span>
  <span class="p">};</span>

<span class="c1">/// Cpu0ebTargetMachine - Cpu032 big endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0ebTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Cpu0elTargetMachine - Cpu032 little endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0elTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.cpp - Define TargetMachine for Cpu0 -------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Implements the info about Cpu0 target spec.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/PassManager.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/Passes.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0Target</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the target.</span>
  <span class="c1">//- Big endian Target Machine</span>
  <span class="n">RegisterTargetMachine</span><span class="o">&lt;</span><span class="n">Cpu0ebTargetMachine</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="c1">//- Little endian Target Machine</span>
  <span class="n">RegisterTargetMachine</span><span class="o">&lt;</span><span class="n">Cpu0elTargetMachine</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// DataLayout --&gt; Big-endian, 32-bit pointer/ABI/alignment</span>
<span class="c1">// The stack is always 8 byte aligned</span>
<span class="c1">// On function prologue, the stack is created by decrementing</span>
<span class="c1">// its pointer. Once decremented, all references are done with positive</span>
<span class="c1">// offset from the stack/frame pointer, using StackGrowsUp enables</span>
<span class="c1">// an easier handling.</span>
<span class="c1">// Using CodeModel::Large enables different CALL behavior.</span>
<span class="n">Cpu0TargetMachine</span><span class="o">::</span>
<span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                  <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                  <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                  <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                  <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">)</span>
  <span class="c1">//- Default is big endian</span>
  <span class="o">:</span> <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">isLittle</span><span class="p">),</span>
    <span class="n">DL</span><span class="p">(</span><span class="n">isLittle</span> <span class="o">?</span>
               <span class="p">(</span><span class="s">&quot;e-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32&quot;</span><span class="p">)</span> <span class="o">:</span>
               <span class="p">(</span><span class="s">&quot;E-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32&quot;</span><span class="p">)),</span>
    <span class="n">InstrInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span>
    <span class="n">FrameLowering</span><span class="p">(</span><span class="n">Subtarget</span><span class="p">),</span> 
    <span class="n">TLInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">TSInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0ebTargetMachine</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0ebTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0elTargetMachine</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0elTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// Cpu0 Code Generator Pass Configuration Options.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0PassConfig</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">*</span><span class="n">TM</span><span class="p">,</span> <span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetPassConfig</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">PM</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">getCpu0TargetMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">getTM</span><span class="o">&lt;</span><span class="n">Cpu0TargetMachine</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">getCpu0Subtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">getCpu0TargetMachine</span><span class="p">().</span><span class="n">getSubtargetImpl</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace</span>

<span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">Cpu0TargetMachine</span><span class="o">::</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0PassConfig</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">PM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">include/llvm/Target/TargetInstInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TargetInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCInstrInfo</span> <span class="p">{</span>
  <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">TargetInstrInfoImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfo</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="n">TargetInstrInfoImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">CallFrameSetupOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">CallFrameDestroyOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="n">CallFrameSetupOpcode</span><span class="p">,</span> <span class="n">CallFrameDestroyOpcode</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">public</span><span class="o">:</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0CallingConv.td</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0CallingConv.td - Calling Conventions for Cpu0 --*- tablegen -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// This describes the calling conventions for Cpu0 architecture.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// CCIfSubtarget - Match if the current subtarget has a feature F.</span>
<span class="k">class</span> <span class="nc">CCIfSubtarget</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">F</span><span class="p">,</span> <span class="n">CCAction</span> <span class="n">A</span><span class="o">&gt;:</span>
  <span class="n">CCIf</span><span class="o">&lt;!</span><span class="n">strconcat</span><span class="p">(</span><span class="s">&quot;State.getTarget().getSubtarget&lt;Cpu0Subtarget&gt;().&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">),</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">CSR_O32</span> <span class="o">:</span> <span class="n">CalleeSavedRegs</span><span class="o">&lt;</span><span class="p">(</span><span class="n">add</span> <span class="n">LR</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span>
                                   <span class="p">(</span><span class="n">sequence</span> <span class="s">&quot;S%u&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0FrameLowering.h - Define frame lowering for Cpu0 ----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0_FRAMEINFO_H</span>
<span class="cp">#define CPU0_FRAMEINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Cpu0Subtarget</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0FrameLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetFrameLowering</span> <span class="p">{</span>
<span class="k">protected</span><span class="o">:</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0FrameLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">sti</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetFrameLowering</span><span class="p">(</span><span class="n">StackGrowsDown</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
      <span class="n">STI</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="c1">/// emitProlog/emitEpilog - These methods insert prolog and epilog code into</span>
  <span class="c1">/// the function.</span>
  <span class="kt">void</span> <span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">hasFP</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0FrameLowering.cpp - Cpu0 Frame Information --------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of TargetFrameLowering class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineModuleInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineRegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">//- emitPrologue() and emitEpilogue must exist for main(). </span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Stack Frame Processing methods</span>
<span class="c1">// +----------------------------+</span>
<span class="c1">//</span>
<span class="c1">// The stack is allocated decrementing the stack pointer on</span>
<span class="c1">// the first instruction of a function prologue. Once decremented,</span>
<span class="c1">// all stack references are done thought a positive offset</span>
<span class="c1">// from the stack/frame pointer, so the stack is considering</span>
<span class="c1">// to grow up! Otherwise terrible hacks would have to be made</span>
<span class="c1">// to get this stack ABI compliant :)</span>
<span class="c1">//</span>
<span class="c1">//  The stack frame required by the ABI (after call):</span>
<span class="c1">//  Offset</span>
<span class="c1">//</span>
<span class="c1">//  0                 ----------</span>
<span class="c1">//  4                 Args to pass</span>
<span class="c1">//  .                 saved $GP  (used in PIC)</span>
<span class="c1">//  .                 Alloca allocations</span>
<span class="c1">//  .                 Local Area</span>
<span class="c1">//  .                 CPU &quot;Callee Saved&quot; Registers</span>
<span class="c1">//  .                 saved FP</span>
<span class="c1">//  .                 saved RA</span>
<span class="c1">//  .                 FPU &quot;Callee Saved&quot; Registers</span>
<span class="c1">//  StackSize         -----------</span>
<span class="c1">//</span>
<span class="c1">// Offset - offset from sp after stack allocation on function prologue</span>
<span class="c1">//</span>
<span class="c1">// The sp is the stack pointer subtracted/added from the stack size</span>
<span class="c1">// at the Prologue/Epilogue</span>
<span class="c1">//</span>
<span class="c1">// References to the previous stack (to obtain arguments) are done</span>
<span class="c1">// with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1))</span>
<span class="c1">//</span>
<span class="c1">// Examples:</span>
<span class="c1">// - reference to the actual stack frame</span>
<span class="c1">//   for any local area var there is smt like : FI &gt;= 0, StackOffset: 4</span>
<span class="c1">//     st REGX, 4(SP)</span>
<span class="c1">//</span>
<span class="c1">// - reference to previous stack frame</span>
<span class="c1">//   suppose there&#39;s a load to the 5th arguments : FI &lt; 0, StackOffset: 16.</span>
<span class="c1">//   The emitted instruction will be something like:</span>
<span class="c1">//     ld REGX, 16+StackSize(SP)</span>
<span class="c1">//</span>
<span class="c1">// Since the total stack size is unknown on LowerFormalArguments, all</span>
<span class="c1">// stack references (ObjectOffset) created to reference the function</span>
<span class="c1">// arguments, are negative numbers. This way, on eliminateFrameIndex it&#39;s</span>
<span class="c1">// possible to detect those references and the offsets are adjusted to</span>
<span class="c1">// their real location.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//- Must have, hasFP() is pure virtual of parent</span>
<span class="c1">// hasFP - Return true if the specified function should have a dedicated frame</span>
<span class="c1">// pointer register.  This is true if the function has variable sized allocas or</span>
<span class="c1">// if frame pointer elimination is disabled.</span>
<span class="kt">bool</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">hasFP</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">Options</span><span class="p">.</span><span class="n">DisableFramePointerElim</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">hasVarSizedObjects</span><span class="p">()</span> <span class="o">||</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">isFrameAddressTaken</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrInfo.h - Cpu0 Instruction Information ----------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetInstrInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0INSTRUCTIONINFO_H</span>
<span class="cp">#define CPU0INSTRUCTIONINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="n">RI</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>

  <span class="c1">/// getRegisterInfo - TargetInstrInfo is a superset of MRegister info.  As</span>
  <span class="c1">/// such, whenever a client has an instance of instruction info, it should</span>
  <span class="c1">/// always be able to get register info as well (through this method).</span>
  <span class="c1">///</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrInfo.cpp - Cpu0 Instruction Information ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetInstrInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#define GET_INSTRINFO_CTOR</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
  <span class="o">:</span> 
    <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span>
    <span class="n">RI</span><span class="p">(</span><span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">RI</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0ISelLowering.h - Cpu0 DAG Lowering Interface --------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines the interfaces that Cpu0 uses to lower LLVM code into a</span>
<span class="c1">// selection DAG.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef Cpu0ISELLOWERING_H</span>
<span class="cp">#define Cpu0ISELLOWERING_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/SelectionDAG.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">namespace</span> <span class="n">Cpu0ISD</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">NodeType</span> <span class="p">{</span>
      <span class="c1">// Start the numbering from where ISD NodeType finishes.</span>
      <span class="n">FIRST_NUMBER</span> <span class="o">=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">BUILTIN_OP_END</span><span class="p">,</span>
      <span class="n">Ret</span>
    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">//===--------------------------------------------------------------------===//</span>
  <span class="c1">// TargetLowering Implementation</span>
  <span class="c1">//===--------------------------------------------------------------------===//</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>

  <span class="k">private</span><span class="o">:</span>
    <span class="c1">// Subtarget Info</span>
    <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">*</span><span class="n">Subtarget</span><span class="p">;</span>

	<span class="c1">//- must be exist without function all</span>
    <span class="k">virtual</span> <span class="n">SDValue</span>
      <span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                           <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                           <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                           <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

	<span class="c1">//- must be exist without function all</span>
    <span class="k">virtual</span> <span class="n">SDValue</span>
      <span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                  <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                  <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// Cpu0ISELLOWERING_H</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0ISelLowering.cpp - Cpu0 DAG Lowering Implementation -----------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines the interfaces that Cpu0 uses to lower LLVM code into a</span>
<span class="c1">// selection DAG.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-lower&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/TargetLoweringObjectFileImpl.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DerivedTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/GlobalVariable.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Intrinsics.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/CallingConv.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/CallingConvLower.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineRegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/SelectionDAGISel.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/ValueTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">TargetLoweringObjectFileELF</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
<span class="p">}</span>

<span class="cp">#include &quot;Cpu0GenCallingConv.inc&quot;</span>

<span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//               Return Value Calling Convention Implementation</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                                <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

    <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Ret</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span>
                       <span class="n">Chain</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MachineFunctionInfo.h - Private data used for Cpu0 ----*- C++ -*-=//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of MachineFunctionInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0_MACHINE_FUNCTION_INFO_H</span>
<span class="cp">#define CPU0_MACHINE_FUNCTION_INFO_H</span>

<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &lt;utility&gt;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="c1">/// Cpu0FunctionInfo - This class is derived from MachineFunction private</span>
<span class="c1">/// Cpu0 target-specific information for each MachineFunction.</span>
<span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
  <span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">MaxCallFrameSize</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">MF</span><span class="p">(</span><span class="n">MF</span><span class="p">),</span> <span class="n">MaxCallFrameSize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
  <span class="p">{}</span>

  <span class="kt">unsigned</span> <span class="n">getMaxCallFrameSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">MaxCallFrameSize</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setMaxCallFrameSize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="n">MaxCallFrameSize</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end of namespace llvm</span>

<span class="cp">#endif </span><span class="c1">// CPU0_MACHINE_FUNCTION_INFO_H</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0SelectionDAGInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0SelectionDAGInfo.h - Cpu0 SelectionDAG Info ---------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines the Cpu0 subclass for TargetSelectionDAGInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0SELECTIONDAGINFO_H</span>
<span class="cp">#define CPU0SELECTIONDAGINFO_H</span>

<span class="cp">#include &quot;llvm/Target/TargetSelectionDAGInfo.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0TargetMachine</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0SelectionDAGInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetSelectionDAGInfo</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Cpu0SelectionDAGInfo</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0SelectionDAGInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0SelectionDAGInfo.cpp - Cpu0 SelectionDAG Info -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file implements the Cpu0SelectionDAGInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-selectiondag-info&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0SelectionDAGInfo</span><span class="o">::</span><span class="n">Cpu0SelectionDAGInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetSelectionDAGInfo</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">Cpu0SelectionDAGInfo</span><span class="o">::~</span><span class="n">Cpu0SelectionDAGInfo</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0Subtarget.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_SUBTARGETINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenSubtargetInfo.inc&quot;</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">Cpu0Subtarget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenSubtargetInfo</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="c1">//- Vitual function, must have</span>
  <span class="c1">/// ParseSubtargetFeatures - Parses features string setting specified</span>
  <span class="c1">/// subtarget options.  Definition of function is auto generated by tblgen.</span>
  <span class="kt">void</span> <span class="n">ParseSubtargetFeatures</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0Subtarget.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0Subtarget.cpp - Cpu0 Subtarget Information --------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file implements the Cpu0 specific subclass of TargetSubtargetInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>

<span class="cp">#define GET_SUBTARGETINFO_TARGET_DESC</span>
<span class="cp">#define GET_SUBTARGETINFO_CTOR</span>
<span class="cp">#include &quot;Cpu0GenSubtargetInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">CPU</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">little</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">Cpu0GenSubtargetInfo</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span>
  <span class="n">Cpu0ABI</span><span class="p">(</span><span class="n">UnknownABI</span><span class="p">),</span> <span class="n">IsLittle</span><span class="p">(</span><span class="n">little</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">CPUName</span> <span class="o">=</span> <span class="n">CPU</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CPUName</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">CPUName</span> <span class="o">=</span> <span class="s">&quot;cpu032&quot;</span><span class="p">;</span>

  <span class="c1">// Parse features string.</span>
  <span class="n">ParseSubtargetFeatures</span><span class="p">(</span><span class="n">CPUName</span><span class="p">,</span> <span class="n">FS</span><span class="p">);</span>

  <span class="c1">// Initialize scheduling itinerary for the specified CPU.</span>
  <span class="n">InstrItins</span> <span class="o">=</span> <span class="n">getInstrItineraryForCPU</span><span class="p">(</span><span class="n">CPUName</span><span class="p">);</span>

  <span class="c1">// Set Cpu0ABI if it hasn&#39;t been set yet.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0ABI</span> <span class="o">==</span> <span class="n">UnknownABI</span><span class="p">)</span>
    <span class="n">Cpu0ABI</span> <span class="o">=</span> <span class="n">O32</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0RegisterInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0RegisterInfo.h - Cpu0 Register Information Impl -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetRegisterInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0REGISTERINFO_H</span>
<span class="cp">#define CPU0REGISTERINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetRegisterInfo.h&quot;</span>

<span class="cp">#define GET_REGINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0Subtarget</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TargetInstrInfo</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenRegisterInfo</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span><span class="p">;</span>

  <span class="n">Cpu0RegisterInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">tii</span><span class="p">);</span>

  <span class="c1">/// getRegisterNumbering - Given the enum value for some register, e.g.</span>
  <span class="c1">/// Cpu0::RA, return the number that it corresponds to (e.g. 31).</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getRegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">);</span>

  <span class="c1">/// Code Generation virtual methods...</span>
  <span class="k">const</span> <span class="n">uint16_t</span> <span class="o">*</span><span class="n">getCalleeSavedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span><span class="o">*</span> <span class="n">MF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="n">BitVector</span> <span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="c1">/// Stack Frame Processing Methods</span>
  <span class="kt">void</span> <span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span>
                           <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="c1">/// Debug information queries.</span>
  <span class="kt">unsigned</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0RegisterInfo.cpp - CPU0 Register Information -== --------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the CPU0 implementation of the TargetRegisterInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-reg-info&quot;</span>

<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Constants.h&quot;</span>
<span class="cp">#include &quot;llvm/DebugInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Type.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/ValueTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/BitVector.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/STLExtras.h&quot;</span>

<span class="cp">#define GET_REGINFO_TARGET_DESC</span>
<span class="cp">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">Cpu0RegisterInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">ST</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">tii</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0GenRegisterInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">ST</span><span class="p">),</span> <span class="n">TII</span><span class="p">(</span><span class="n">tii</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Callee Saved Registers methods</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">/// Cpu0 Callee Saved Registers</span>
<span class="c1">// In Cpu0CallConv.td,</span>
<span class="c1">// def CSR_O32 : CalleeSavedRegs&lt;(add LR, FP,</span>
<span class="c1">//                                   (sequence &quot;S%u&quot;, 2, 0))&gt;;</span>
<span class="c1">// llc create CSR_O32_SaveList and CSR_O32_RegMask from above defined.</span>
<span class="k">const</span> <span class="n">uint16_t</span><span class="o">*</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getCalleeSavedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">CSR_O32_SaveList</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">uint32_t</span><span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">CSR_O32_RegMask</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="n">uint16_t</span> <span class="n">ReservedCPURegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">PC</span>
  <span class="p">};</span>
  <span class="n">BitVector</span> <span class="n">Reserved</span><span class="p">(</span><span class="n">getNumRegs</span><span class="p">());</span>
  <span class="k">typedef</span> <span class="n">TargetRegisterClass</span><span class="o">::</span><span class="n">iterator</span> <span class="n">RegIter</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">array_lengthof</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">);</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">[</span><span class="n">I</span><span class="p">]);</span>

  <span class="k">return</span> <span class="n">Reserved</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="kt">unsigned</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">TFI</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span> <span class="o">:</span>
                          <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.h - Define TargetMachine for Cpu0 -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetMachine.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETMACHINE_H</span>
<span class="cp">#define CPU0TARGETMACHINE_H</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0SelectionDAGInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">formatted_raw_ostream</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
    <span class="n">Cpu0Subtarget</span>       <span class="n">Subtarget</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">DataLayout</span>    <span class="n">DL</span><span class="p">;</span> <span class="c1">// Calculates type size &amp; alignment</span>
    <span class="n">Cpu0InstrInfo</span>       <span class="n">InstrInfo</span><span class="p">;</span>	<span class="c1">//- Instructions</span>
    <span class="n">Cpu0FrameLowering</span>   <span class="n">FrameLowering</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0TargetLowering</span>  <span class="n">TLInfo</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0SelectionDAGInfo</span> <span class="n">TSInfo</span><span class="p">;</span>	<span class="c1">//- Map .bc DAG to backend DAG</span>

  <span class="k">public</span><span class="o">:</span>
    <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                      <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0InstrInfo</span>   <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameLowering</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0Subtarget</span>   <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span> <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span>    <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetLowering</span> <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TLInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="o">*</span> <span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TSInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Pass Pipeline Configuration</span>
    <span class="k">virtual</span> <span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">);</span>
  <span class="p">};</span>

<span class="c1">/// Cpu0ebTargetMachine - Cpu032 big endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0ebTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Cpu0elTargetMachine - Cpu032 little endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0elTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.cpp - Define TargetMachine for Cpu0 -------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Implements the info about Cpu0 target spec.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/PassManager.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/Passes.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0Target</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the target.</span>
  <span class="c1">//- Big endian Target Machine</span>
  <span class="n">RegisterTargetMachine</span><span class="o">&lt;</span><span class="n">Cpu0ebTargetMachine</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="c1">//- Little endian Target Machine</span>
  <span class="n">RegisterTargetMachine</span><span class="o">&lt;</span><span class="n">Cpu0elTargetMachine</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// DataLayout --&gt; Big-endian, 32-bit pointer/ABI/alignment</span>
<span class="c1">// The stack is always 8 byte aligned</span>
<span class="c1">// On function prologue, the stack is created by decrementing</span>
<span class="c1">// its pointer. Once decremented, all references are done with positive</span>
<span class="c1">// offset from the stack/frame pointer, using StackGrowsUp enables</span>
<span class="c1">// an easier handling.</span>
<span class="c1">// Using CodeModel::Large enables different CALL behavior.</span>
<span class="n">Cpu0TargetMachine</span><span class="o">::</span>
<span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                  <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                  <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                  <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                  <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">)</span>
  <span class="c1">//- Default is big endian</span>
  <span class="o">:</span> <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">isLittle</span><span class="p">),</span>
    <span class="n">DL</span><span class="p">(</span><span class="n">isLittle</span> <span class="o">?</span>
               <span class="p">(</span><span class="s">&quot;e-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32&quot;</span><span class="p">)</span> <span class="o">:</span>
               <span class="p">(</span><span class="s">&quot;E-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32&quot;</span><span class="p">)),</span>
    <span class="n">InstrInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span>
    <span class="n">FrameLowering</span><span class="p">(</span><span class="n">Subtarget</span><span class="p">),</span> 
    <span class="n">TLInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">TSInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0ebTargetMachine</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0ebTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="kc">false</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0elTargetMachine</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0elTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="kc">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// Cpu0 Code Generator Pass Configuration Options.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0PassConfig</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">*</span><span class="n">TM</span><span class="p">,</span> <span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetPassConfig</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">PM</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">getCpu0TargetMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">getTM</span><span class="o">&lt;</span><span class="n">Cpu0TargetMachine</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">getCpu0Subtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">getCpu0TargetMachine</span><span class="p">().</span><span class="n">getSubtargetImpl</span><span class="p">();</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace</span>

<span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">Cpu0TargetMachine</span><span class="o">::</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0PassConfig</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">PM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>
<span class="c1">//- Cpu0InstInfo.h</span>
<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="figure align-center" id="backendstructure-f1">
<img alt="_images/1.png" src="_images/1.png" />
<p class="caption">Figure 1: TargetMachine class diagram 1</p>
</div>
<p>The Cpu0TargetMachine inherit tree is TargetMachine &lt;- LLVMTargetMachine &lt;-
Cpu0TargetMachine.
Cpu0TargetMachine has class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering,
Cpu0TargetLowering and Cpu0SelectionDAGInfo.
Class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering, Cpu0TargetLowering and
Cpu0SelectionDAGInfo are inherited from parent class TargetSubtargetInfo,
TargetInstrInfo, TargetFrameLowering, TargetLowering and TargetSelectionDAGInfo.</p>
<p><a class="pageref" href="#backendstructure-f1">Figure  1</a> shows Cpu0TargetMachine inherit tree and it&#8217;s
Cpu0InstrInfo class inherit tree.
Cpu0TargetMachine contains Cpu0InstrInfo and ... other class.
Cpu0InstrInfo contains Cpu0RegisterInfo class, RI. Cpu0InstrInfo.td and
Cpu0RegisterInfo.td will generate Cpu0GenInstrInfo.inc and
Cpu0GenRegisterInfo.inc which contain some member functions implementation for
class Cpu0InstrInfo and Cpu0RegisterInfo.</p>
<p><a class="pageref" href="#backendstructure-f2">Figure  2</a> as below shows Cpu0TargetMachine contains
class
TSInfo: Cpu0SelectionDAGInfo, FrameLowering: Cpu0FrameLowering, Subtarget:
Cpu0Subtarget and TLInfo: Cpu0TargetLowering.</p>
<div class="figure align-center" id="backendstructure-f2">
<img alt="_images/2.png" src="_images/2.png" />
<p class="caption">Figure 2: TargetMachine class diagram 2</p>
</div>
<div class="figure align-center" id="backendstructure-f3">
<img alt="_images/3.png" src="_images/3.png" />
<p class="caption">Figure 3: TargetMachine members and operators</p>
</div>
<p><a class="pageref" href="#backendstructure-f3">Figure  3</a> shows some members and operators (member function)
of the parent class TargetMachine&#8217;s.
<a class="pageref" href="#backendstructure-f4">Figure  4</a> as below shows some members of class InstrInfo,
RegisterInfo and TargetLowering.
Class DAGInfo is skipped here.</p>
<div class="figure align-center" id="backendstructure-f4">
<img alt="_images/4.png" src="_images/4.png" />
<p class="caption">Figure 4: Other class members and operators</p>
</div>
<p>Benefit from the inherit tree structure, we just need to implement few code in
instruction, frame/stack, select DAG class.
Many code implemented by their parent class.
The llvm-tblgen generate Cpu0GenInstrInfo.inc from Cpu0InstrInfo.td.
Cpu0InstrInfo.h extract those code it need from Cpu0GenInstrInfo.inc by define
“#define GET_INSTRINFO_HEADER”.
Following is the code fragment from Cpu0GenInstrInfo.inc.
Code between “#if def  GET_INSTRINFO_HEADER” and “#endif // GET_INSTRINFO_HEADER”
will be extracted by Cpu0InstrInfo.h.</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>
</pre></div>
</div>
<p>Reference Write An LLVM Backend web site <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>Now, the code in Chapter3_1/ add class Cpu0TargetMachine(Cpu0TargetMachine.h and
cpp), Cpu0Subtarget (Cpu0Subtarget.h and .cpp), Cpu0InstrInfo (Cpu0InstrInfo.h
and .cpp), Cpu0FrameLowering (Cpu0FrameLowering.h and .cpp), Cpu0TargetLowering
(Cpu0ISelLowering.h and .cpp) and Cpu0SelectionDAGInfo ( Cpu0SelectionDAGInfo.h
and .cpp).
CMakeLists.txt  modified with those new added *.cpp as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_1/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp"># Cpu0CodeGen should match with LLVMBuild.txt Cpu0CodeGen</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="n">Cpu0ISelLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0InstrInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0FrameLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0RegisterInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0Subtarget</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0TargetMachine</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0SelectionDAGInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Please take a look for Chapter3_1 code.
After that, building Chapter3_1 by make as chapter 2 (of course, you should remove old
src/lib/Target/Cpu0 and replace with src/lib/Target/Cpu0/LLVMBackendTutorialExampleCode/Chapter3_1/).
You can remove cmake_debug_build/lib/Target/Cpu0/*.inc before do “make” to ensure your code
rebuild completely.
By remove *.inc, all files those have included .inc will be rebuild, then your
Target library will regenerate.
Command as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:cmake_debug_build Jonathan<span class="nv">$ </span>rm -rf lib/Target/Cpu0/*
</pre></div>
</div>
<p>Now, let&#8217;s build Chapter3_1 as the following command,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-75-57:ExampleCode Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/lib/Target/Cpu0/LLVMBackendTutorialExampleCode
118-165-75-57:LLVMBackendTutorialExampleCode Jonathan<span class="nv">$ </span>sh removecpu0.sh
118-165-75-57:LLVMBackendTutorialExampleCode Jonathan<span class="nv">$ </span>cp -rf Chapter3_1/
* ../.

118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
Assertion failed: <span class="o">(</span>AsmInfo <span class="o">&amp;&amp;</span> <span class="s2">&quot;MCAsmInfo not initialized.&quot;</span>
...
</pre></div>
</div>
<p>The errors say that we have not Target AsmPrinter.
Let&#8217;s add it in next section.</p>
</div>
<div class="section" id="add-asmprinter">
<h2>Add AsmPrinter<a class="headerlink" href="#add-asmprinter" title="Permalink to this headline">¶</a></h2>
<p>Chapter3_2/cpu0 contains the Cpu0AsmPrinter definition. First, we add definitions in
Cpu0.td to support AssemblyWriter.
Cpu0.td is added with the following fragment,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Without this will have error: &#39;cpu032&#39; is not a recognized processor for </span>
<span class="c1">//  this target (ignoring processor)</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Subtarget features                                                    //</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">FeatureCpu032</span>      <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;cpu032&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0ArchVersion&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu032&quot;</span><span class="p">,</span>
                                <span class="s">&quot;Cpu032 ISA Support&quot;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 processors supported.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">Proc</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Name</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">SubtargetFeature</span><span class="o">&gt;</span> <span class="n">Features</span><span class="o">&gt;</span>
 <span class="o">:</span> <span class="n">Processor</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">Cpu0GenericItineraries</span><span class="p">,</span> <span class="n">Features</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">Cpu0AsmWriter</span> <span class="o">:</span> <span class="n">AsmWriter</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">AsmWriterClassName</span>  <span class="o">=</span> <span class="s">&quot;InstPrinter&quot;</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isMCAsmWriter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Will generate Cpu0GenAsmWrite.inc included by Cpu0InstPrinter.cpp, contents </span>
<span class="c1">//  as follows,</span>
<span class="c1">// void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &amp;O) {...}</span>
<span class="c1">// const char *Cpu0InstPrinter::getRegisterName(unsigned RegNo) {...}</span>
<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span>
<span class="c1">// def Cpu0InstrInfo : InstrInfo as before.</span>
  <span class="n">let</span> <span class="n">InstructionSet</span> <span class="o">=</span> <span class="n">Cpu0InstrInfo</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">AssemblyWriters</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmWriter</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As comments indicate, it will generate Cpu0GenAsmWrite.inc which is included
by Cpu0InstPrinter.cpp.
Cpu0GenAsmWrite.inc has the implementation of
Cpu0InstPrinter::printInstruction() and Cpu0InstPrinter::getRegisterName().
Both of these functions can be auto-generated from the information we defined
in Cpu0InstrInfo.td and Cpu0RegisterInfo.td.
To let these two functions work in our code, the only thing need to do is add a
class Cpu0InstPrinter and include them as did in Chapter3_1.</p>
<p>File Chapter3_1/Cpu0/InstPrinter/Cpu0InstPrinter.cpp include Cpu0GenAsmWrite.inc and
call the auto-generated functions as shown in last section.</p>
<p>Next, add Cpu0MCInstLower (Cpu0MCInstLower.h, Cpu0MCInstLower.cpp), as well as
Cpu0BaseInfo.h,
Cpu0FixupKinds.h and Cpu0MCAsmInfo (Cpu0MCAsmInfo.h, Cpu0MCAsmInfo.cpp) in
sub-directory MCTargetDesc as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0MCInstLower.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCInstLower.h - Lower MachineInstr to MCInst -------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0MCINSTLOWER_H</span>
<span class="cp">#define CPU0MCINSTLOWER_H</span>
<span class="cp">#include &quot;llvm/ADT/SmallVector.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Compiler.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">MCContext</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MCInst</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MCOperand</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachineInstr</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachineFunction</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Mangler</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Cpu0AsmPrinter</span><span class="p">;</span>

<span class="c1">/// Cpu0MCInstLower - This class is used to lower an MachineInstr into an</span>
<span class="c1">//                    MCInst.</span>
<span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="n">Cpu0MCInstLower</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MachineOperandType</span> <span class="n">MachineOperandType</span><span class="p">;</span>
  <span class="n">MCContext</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">;</span>
  <span class="n">Mangler</span> <span class="o">*</span><span class="n">Mang</span><span class="p">;</span>
  <span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">AsmPrinter</span><span class="p">;</span>
<span class="k">public</span><span class="o">:</span>
  <span class="n">Cpu0MCInstLower</span><span class="p">(</span><span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">asmprinter</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Initialize</span><span class="p">(</span><span class="n">Mangler</span> <span class="o">*</span><span class="n">mang</span><span class="p">,</span> <span class="n">MCContext</span><span class="o">*</span> <span class="n">C</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Lower</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="k">private</span><span class="o">:</span>
  <span class="n">MCOperand</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                               <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">MCOperand</span> <span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97
98</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCInstLower.cpp - Convert Cpu0 MachineInstr to MCInst ---------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains code to lower Cpu0 MachineInstrs to their corresponding</span>
<span class="c1">// MCInst records.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MCInstLower.h&quot;</span>
<span class="cp">#include &quot;Cpu0AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstr.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/Mangler.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Cpu0MCInstLower</span><span class="p">(</span><span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">asmprinter</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">AsmPrinter</span><span class="p">(</span><span class="n">asmprinter</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Mangler</span> <span class="o">*</span><span class="n">M</span><span class="p">,</span> <span class="n">MCContext</span><span class="o">*</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Mang</span> <span class="o">=</span> <span class="n">M</span><span class="p">;</span>
  <span class="n">Ctx</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Kind</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Symbol</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span>                   <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Invalid target flag!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_GlobalAddress:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">Mang</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
    <span class="k">break</span><span class="p">;</span>

  <span class="k">default</span><span class="o">:</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;&lt;unknown operand type&gt;&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">MCSym</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span> <span class="n">Kind</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Offset</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">MCSym</span><span class="p">);</span>

  <span class="c1">// Assume offset is never negative.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">OffsetExpr</span> <span class="o">=</span>  <span class="n">MCConstantExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCBinaryExpr</span> <span class="o">*</span><span class="n">AddExpr</span> <span class="o">=</span> <span class="n">MCBinaryExpr</span><span class="o">::</span><span class="n">CreateAdd</span><span class="p">(</span><span class="n">MCSym</span><span class="p">,</span> <span class="n">OffsetExpr</span><span class="p">,</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">AddExpr</span><span class="p">);</span>
<span class="p">}</span>

<span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unknown operand type&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_Register:</span>
    <span class="c1">// Ignore all implicit register operands.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImplicit</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">());</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_Immediate:</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="nl">MO_RegisterMask:</span>
    <span class="k">break</span><span class="p">;</span>
 <span class="p">}</span>

  <span class="k">return</span> <span class="n">MCOperand</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Lower</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">OutMI</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">MCOperand</span> <span class="n">MCOp</span> <span class="o">=</span> <span class="n">LowerOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MCOp</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
      <span class="n">OutMI</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOp</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67
68
69
70
71
72
73
74
75
76
77
78
79
80
81
82
83
84
85
86
87
88
89
90
91
92
93
94
95
96
97</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0BaseInfo.h - Top level definitions for CPU0 MC ------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains small standalone helper functions and enum definitions for</span>
<span class="c1">// the Cpu0 target useful for the compiler back-end and the MC libraries.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0BASEINFO_H</span>
<span class="cp">#define CPU0BASEINFO_H</span>

<span class="cp">#include &quot;Cpu0FixupKinds.h&quot;</span>
<span class="cp">#include &quot;Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/DataTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="c1">/// Cpu0II - This namespace holds all of the target specific flags that</span>
<span class="c1">/// instruction info tracks.</span>
<span class="c1">///</span>
<span class="k">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="c1">/// Target Operand Flag enum.</span>
  <span class="k">enum</span> <span class="p">{</span>
    <span class="c1">//===------------------------------------------------------------------===//</span>
    <span class="c1">// Instruction encodings.  These are the standard/most common forms for</span>
    <span class="c1">// Cpu0 instructions.</span>
    <span class="c1">//</span>

    <span class="c1">// Pseudo - This represents an instruction that is a pseudo instruction</span>
    <span class="c1">// or one that has not been implemented yet.  It is illegal to code generate</span>
    <span class="c1">// it, but tolerated for intermediate implementation stages.</span>
    <span class="n">Pseudo</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1">/// FrmR - This form is for instructions of the format R.</span>
    <span class="n">FrmR</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="c1">/// FrmI - This form is for instructions of the format I.</span>
    <span class="n">FrmI</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="c1">/// FrmJ - This form is for instructions of the format J.</span>
    <span class="n">FrmJ</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="c1">/// FrmOther - This form is for instructions that have no specific format.</span>
    <span class="n">FrmOther</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

    <span class="n">FormMask</span> <span class="o">=</span> <span class="mi">15</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">/// getCpu0RegisterNumbering - Given the enum value for some register,</span>
<span class="c1">/// return the number that it corresponds to.</span>
<span class="kr">inline</span> <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">RegEnum</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">ZERO:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">AT:</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">V0:</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">V1:</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">A0:</span>
    <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">A1:</span>
    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">T9:</span>
    <span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">S0:</span>
    <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">S1:</span>
    <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">S2:</span>
    <span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">GP:</span>
    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">FP:</span>
    <span class="k">return</span> <span class="mi">11</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">SW:</span>
    <span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">SP:</span>
    <span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">LR:</span>
    <span class="k">return</span> <span class="mi">14</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span><span class="o">::</span><span class="nl">PC:</span>
    <span class="k">return</span> <span class="mi">15</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown register number!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0FixupKinds.h - Cpu0 Specific Fixup Entries ----------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLVM_CPU0_CPU0FIXUPKINDS_H</span>
<span class="cp">#define LLVM_CPU0_CPU0FIXUPKINDS_H</span>

<span class="cp">#include &quot;llvm/MC/MCFixup.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">namespace</span> <span class="n">Cpu0</span> <span class="p">{</span>
  <span class="c1">// Although most of the current fixup types reflect a unique relocation</span>
  <span class="c1">// one can have multiple fixup types for a given relocation and thus need</span>
  <span class="c1">// to be uniquely named.</span>
  <span class="c1">//</span>
  <span class="c1">// This table *must* be in the save order of</span>
  <span class="c1">// MCFixupKindInfo Infos[Cpu0::NumTargetFixupKinds]</span>
  <span class="c1">// in Cpu0AsmBackend.cpp.</span>
  <span class="c1">//</span>
  <span class="k">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
    <span class="c1">// Branch fixups resulting in R_CPU0_16.</span>
    <span class="n">fixup_Cpu0_16</span> <span class="o">=</span> <span class="n">FirstTargetFixupKind</span><span class="p">,</span>

    <span class="c1">// Marker</span>
    <span class="n">LastTargetFixupKind</span><span class="p">,</span>
    <span class="n">NumTargetFixupKinds</span> <span class="o">=</span> <span class="n">LastTargetFixupKind</span> <span class="o">-</span> <span class="n">FirstTargetFixupKind</span>
  <span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace Cpu0</span>
<span class="p">}</span> <span class="c1">// namespace llvm</span>


<span class="cp">#endif </span><span class="c1">// LLVM_CPU0_CPU0FIXUPKINDS_H</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/MCTargetDesc/Cpu0MCAsmInfo.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCAsmInfo.h - Cpu0 Asm Info ------------------------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the declaration of the Cpu0MCAsmInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETASMINFO_H</span>
<span class="cp">#define CPU0TARGETASMINFO_H</span>

<span class="cp">#include &quot;llvm/MC/MCAsmInfo.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">StringRef</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Target</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0MCAsmInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCAsmInfo</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">explicit</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/MCTargetDesc/Cpu0MCAsmInfo.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCAsmInfo.cpp - Cpu0 Asm Properties ---------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the declarations of the Cpu0MCAsmInfo properties.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MCAsmInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Triple.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Cpu0MCAsmInfo</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0MCAsmInfo</span><span class="o">::</span><span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Triple</span> <span class="n">TheTriple</span><span class="p">(</span><span class="n">TT</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">TheTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">))</span>
    <span class="n">IsLittleEndian</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">AlignmentIsInBytes</span>          <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="n">Data16bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.2byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data32bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.4byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data64bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.8byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">PrivateGlobalPrefix</span>         <span class="o">=</span> <span class="s">&quot;$&quot;</span><span class="p">;</span>
  <span class="n">CommentString</span>               <span class="o">=</span> <span class="s">&quot;#&quot;</span><span class="p">;</span>
  <span class="n">ZeroDirective</span>               <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.space</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">GPRel32Directive</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.gpword</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">GPRel64Directive</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.gpdword</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">WeakRefDirective</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.weak</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="n">SupportsDebugInformation</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="n">ExceptionsType</span> <span class="o">=</span> <span class="n">ExceptionHandling</span><span class="o">::</span><span class="n">DwarfCFI</span><span class="p">;</span>
  <span class="n">HasLEB128</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="n">DwarfRegNumForCFI</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>Finally, add code in Cpu0MCTargetDesc.cpp to register Cpu0InstPrinter as
follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
  <span class="n">size_t</span> <span class="n">DashPosition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">StringRef</span> <span class="n">TheTriple</span><span class="p">;</span>

  <span class="c1">// Let&#39;s see if there is a dash, like cpu0-unknown-linux.</span>
  <span class="n">DashPosition</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DashPosition</span> <span class="o">==</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// No dash, we check the string size.</span>
    <span class="n">TheTriple</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// We are only interested in substring before dash.</span>
    <span class="n">TheTriple</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">DashPosition</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0&quot;</span> <span class="o">||</span> <span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0el&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s">&quot;cpu032&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s">&quot;+cpu032&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstrInfo</span> <span class="o">*</span><span class="n">createCpu0MCInstrInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MCInstrInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCInstrInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCInstrInfo</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenInstrInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">createCpu0MCRegisterInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCRegisterInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCRegisterInfo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenRegisterInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCSubtargetInfo</span> <span class="o">*</span><span class="n">createCpu0MCSubtargetInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span>
                                                  <span class="n">StringRef</span> <span class="n">FS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span><span class="n">CPU</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FS</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ArchFS</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">ArchFS</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">FS</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">FS</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MCSubtargetInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCSubtargetInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCSubtargetInfo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">ArchFS</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenSubtargetInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">createCpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">);</span>

  <span class="n">MachineLocation</span> <span class="n">Dst</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
  <span class="n">MachineLocation</span> <span class="n">Src</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">addInitialFrameState</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MAI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCCodeGenInfo</span> <span class="o">*</span><span class="n">createCpu0MCCodeGenInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span>
                                              <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                                              <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCCodeGenInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCCodeGenInfo</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CM</span> <span class="o">==</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">JITDefault</span><span class="p">)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Static</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RM</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Default</span><span class="p">)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">;</span>
  <span class="n">X</span><span class="o">-&gt;</span><span class="n">InitMCCodeGenInfo</span><span class="p">(</span><span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">);</span> <span class="c1">// defined in lib/MC/MCCodeGenInfo.cpp</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstPrinter</span> <span class="o">*</span><span class="n">createCpu0MCInstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">SyntaxVariant</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the MC asm info.</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC codegen info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeGenInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeGenInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeGenInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeGenInfo</span><span class="p">);</span>
  <span class="c1">// Register the MC instruction info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstrInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCInstrInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstrInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCInstrInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC register info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCRegInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCRegisterInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCRegInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCRegisterInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC subtarget info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCSubtargetInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                          <span class="n">createCpu0MCSubtargetInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCSubtargetInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                          <span class="n">createCpu0MCSubtargetInfo</span><span class="p">);</span>
  <span class="c1">// Register the MCInstPrinter.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Now, it&#8217;s time to work with AsmPrinter. According section
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id6" id="id2">[2]</a>, we can register our AsmPrinter when we need it
as the following function of LLVMInitializeCpu0AsmPrinter(),</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0AsmPrinter.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56
57
58
59
60
61
62
63
64
65
66
67</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmPrinter.h - Cpu0 LLVM Assembly Printer ----------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Cpu0 Assembly printer class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0ASMPRINTER_H</span>
<span class="cp">#define CPU0ASMPRINTER_H</span>

<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;Cpu0MCInstLower.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Compiler.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">MCStreamer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MachineInstr</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MachineBasicBlock</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Module</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">raw_ostream</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="n">Cpu0AsmPrinter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AsmPrinter</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>

<span class="k">public</span><span class="o">:</span>

  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">*</span><span class="n">Subtarget</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span><span class="p">;</span>
  <span class="n">Cpu0MCInstLower</span> <span class="n">MCInstLowering</span><span class="p">;</span>

  <span class="k">explicit</span> <span class="n">Cpu0AsmPrinter</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>  <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Streamer</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">AsmPrinter</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">Streamer</span><span class="p">),</span> <span class="n">MCInstLowering</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Subtarget</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Cpu0 Assembly Printer&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">);</span>

<span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
  <span class="kt">void</span> <span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">printHex32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Value</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">emitFrameDirective</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getCurrentABIString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">EmitFunctionEntryLabel</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">EmitFunctionBodyStart</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">EmitFunctionBodyEnd</span><span class="p">();</span>
  <span class="kt">void</span> <span class="n">EmitStartOfAsmFile</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="n">MachineLocation</span> <span class="n">getDebugValueLocation</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183
184
185
186
187
188
189
190
191
192
193
194
195
196
197
198
199
200
201
202
203
204
205
206
207
208
209
210
211
212
213
214
215
216
217
218
219
220
221
222
223
224
225
226
227
228
229
230
231
232
233
234
235
236
237
238
239
240
241
242
243
244
245
246
247
248
249
250
251
252
253
254</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmPrinter.cpp - Cpu0 LLVM Assembly Printer -------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains a printer that converts from our internal representation</span>
<span class="c1">// of machine-dependent LLVM code to GAS-format CPU0 assembly language.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-asm-printer&quot;</span>
<span class="cp">#include &quot;Cpu0AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;InstPrinter/Cpu0InstPrinter.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/SmallString.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringExtras.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Twine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/BasicBlock.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Instructions.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineConstantPool.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstr.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineMemOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCStreamer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCAsmInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/Mangler.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetLoweringObjectFile.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">AsmPrinter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">isDebugValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="n">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>

    <span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">MCInst</span> <span class="n">TmpInst0</span><span class="p">;</span>
  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst0</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//  Cpu0 Asm Directives</span>
<span class="c1">//</span>
<span class="c1">//  -- Frame directive &quot;frame Stackpointer, Stacksize, RARegister&quot;</span>
<span class="c1">//  Describe the stack frame.</span>
<span class="c1">//</span>
<span class="c1">//  -- Mask directives &quot;(f)mask  bitmask, offset&quot;</span>
<span class="c1">//  Tells the assembler which registers are saved and where.</span>
<span class="c1">//  bitmask - contain a little endian bitset indicating which registers are</span>
<span class="c1">//            saved on function prologue (e.g. with a 0x80000000 mask, the</span>
<span class="c1">//            assembler knows the register 31 (RA) is saved at prologue.</span>
<span class="c1">//  offset  - the position before stack pointer subtraction indicating where</span>
<span class="c1">//            the first saved register on prologue is located. (e.g. with a</span>
<span class="c1">//</span>
<span class="c1">//  Consider the following function prologue:</span>
<span class="c1">//</span>
<span class="c1">//    .frame  $fp,48,$ra</span>
<span class="c1">//    .mask   0xc0000000,-8</span>
<span class="c1">//       addiu $sp, $sp, -48</span>
<span class="c1">//       st $ra, 40($sp)</span>
<span class="c1">//       st $fp, 36($sp)</span>
<span class="c1">//</span>
<span class="c1">//    With a 0xc0000000 mask, the assembler knows the register 31 (RA) and</span>
<span class="c1">//    30 (FP) are saved at prologue. As the save order on prologue is from</span>
<span class="c1">//    left to right, RA is saved first. A -8 offset means that after the</span>
<span class="c1">//    stack pointer subtration, the first register in the mask (RA) will be</span>
<span class="c1">//    saved at address 48-8=40.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Mask directives</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//	.frame	$sp,8,$lr</span>
<span class="c1">//-&gt;	.mask 	0x00000000,0</span>
<span class="c1">//	.set	noreorder</span>
<span class="c1">//	.set	nomacro</span>

<span class="c1">// Create a bitmask with all callee saved registers for CPU or Floating Point</span>
<span class="c1">// registers. For CPU registers consider RA, GP and FP for saving if necessary.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// CPU and FPU Saved Registers Bitmasks</span>
  <span class="kt">unsigned</span> <span class="n">CPUBitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">CPUTopSavedRegOff</span><span class="p">;</span>

  <span class="c1">// Set the CPU and FPU Bitmasks</span>
  <span class="k">const</span> <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="c1">// size of stack area to which FP callee-saved regs are saved.</span>
  <span class="kt">unsigned</span> <span class="n">CPURegSize</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">// Set CPU Bitmask.</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">RegNum</span> <span class="o">=</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="n">CPUBitmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RegNum</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">CPUTopSavedRegOff</span> <span class="o">=</span> <span class="n">CPUBitmask</span> <span class="o">?</span> <span class="o">-</span><span class="n">CPURegSize</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Print CPUBitmask</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.mask </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span> <span class="n">printHex32</span><span class="p">(</span><span class="n">CPUBitmask</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">CPUTopSavedRegOff</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Print a 32 bit hex number with all numbers.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printHex32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Value</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="n">O</span><span class="p">.</span><span class="n">write_hex</span><span class="p">((</span><span class="n">Value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xF</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Frame and Set directives</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//-&gt;	.frame	$sp,8,$lr</span>
<span class="c1">//	.mask 	0x00000000,0</span>
<span class="c1">//	.set	noreorder</span>
<span class="c1">//	.set	nomacro</span>
<span class="c1">/// Frame Directive</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">emitFrameDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">&amp;</span><span class="n">RI</span> <span class="o">=</span> <span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">stackReg</span>  <span class="o">=</span> <span class="n">RI</span><span class="p">.</span><span class="n">getFrameRegister</span><span class="p">(</span><span class="o">*</span><span class="n">MF</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">returnReg</span> <span class="o">=</span> <span class="n">RI</span><span class="p">.</span><span class="n">getRARegister</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.frame</span><span class="se">\t</span><span class="s">$&quot;</span> <span class="o">+</span>
           <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">stackReg</span><span class="p">)).</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span>
           <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">stackSize</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;,$&quot;</span> <span class="o">+</span>
           <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">returnReg</span><span class="p">)).</span><span class="n">lower</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">/// Emit Set directives.</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">getCurrentABIString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">getTargetABI</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="nl">O32:</span>  <span class="k">return</span> <span class="s">&quot;abi32&quot;</span><span class="p">;</span>
  <span class="k">default</span><span class="o">:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown Cpu0 ABI&quot;</span><span class="p">);;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//		.type	main,@function</span>
<span class="c1">//-&gt;		.ent	main                    # @main</span>
<span class="c1">//	main:</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionEntryLabel</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.ent</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()));</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitLabel</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//	.frame	$sp,8,$pc</span>
<span class="c1">//	.mask 	0x00000000,0</span>
<span class="c1">//-&gt;	.set	noreorder</span>
<span class="c1">//-&gt;	.set	nomacro</span>
<span class="c1">/// EmitFunctionBodyStart - Targets can override this to emit stuff before</span>
<span class="c1">/// the first basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Mang</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">emitFrameDirective</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="n">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
    <span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">OS</span><span class="p">);</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">OS</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noreorder&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">nomacro&quot;</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">at&quot;</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//-&gt;	.set	macro</span>
<span class="c1">//-&gt;	.set	reorder</span>
<span class="c1">//-&gt;	.end	main</span>
<span class="c1">/// EmitFunctionBodyEnd - Targets can override this to emit stuff after</span>
<span class="c1">/// the last basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyEnd</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// There are instruction for this macros, but they must</span>
  <span class="c1">// always be at the function end, and we can&#39;t emit and</span>
  <span class="c1">// break with BB logic.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">at&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">macro&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">reorder&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.end</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//	.section .mdebug.abi32</span>
<span class="c1">//	.previous</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitStartOfAsmFile</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// FIXME: Use SwitchSection.</span>

  <span class="c1">// Tell the assembler which ABI we are using</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.section .mdebug.&quot;</span> <span class="o">+</span>
                            <span class="n">Twine</span><span class="p">(</span><span class="n">getCurrentABIString</span><span class="p">()));</span>

  <span class="c1">// return to previous section</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.previous&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="n">MachineLocation</span>
<span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">getDebugValueLocation</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Handles frame addresses emitted in Cpu0InstrInfo::emitFrameIndexDebugValue.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid no. of machine operands!&quot;</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Unexpected MachineOperand types&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getReg</span><span class="p">(),</span>
                         <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                           <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: implement</span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;PrintDebugValueComment()&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Force static initialization.</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmPrinter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>The dynamic register mechanism is a good idea, right.</p>
<p>Beyond add these new .cpp files to CMakeLists.txt, please remember to add
subdirectory InstPrinter, enable asmprinter, add libraries AsmPrinter and
Cpu0AsmPrinter to LLVMBuild.txt as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenMCCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span> <span class="o">-</span><span class="n">mc</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>

<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmWriter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="k">asm</span><span class="o">-</span><span class="n">writer</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="n">Cpu0AsmPrinter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="n">Cpu0MCInstLower</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
<span class="p">...</span>
<span class="n">add_subdirectory</span><span class="p">(</span><span class="n">InstPrinter</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  LLVMBuild.txt</span>
<span class="p">[</span><span class="n">common</span><span class="p">]</span>
<span class="n">subdirectories</span> <span class="o">=</span> <span class="n">InstPrinter</span> <span class="n">MCTargetDesc</span> <span class="n">TargetInfo</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="p">...</span>
<span class="cp"># Please enable asmprinter</span>
<span class="n">has_asmprinter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">...</span>

<span class="p">[</span><span class="n">component_1</span><span class="p">]</span>
<span class="cp"># Add AsmPrinter Cpu0AsmPrinter</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">AsmPrinter</span> <span class="p">...</span> <span class="n">Cpu0AsmPrinter</span> <span class="p">...</span>
</pre></div>
</div>
<p>Now, run Chapter3_2/Cpu0 for AsmPrinter support, will get error message as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
/Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc: target does not
support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">llc</span></tt> fails to compile IR code into machine code since we didn&#8217;t implement
class Cpu0DAGToDAGISel. Before the implementation, we will introduce the LLVM
Code Generation Sequence, DAG, and LLVM instruction selection in next 3
sections.</p>
</div>
<div class="section" id="llvm-code-generation-sequence">
<h2>LLVM Code Generation Sequence<a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h2>
<p>Following diagram came from tricore_llvm.pdf.</p>
<div class="figure align-center" id="backendstructure-f5">
<img alt="_images/5.png" src="_images/5.png" />
<p class="caption">Figure 5: tricore_llvm.pdf: Code generation sequence. On the path from LLVM code to
assembly code, numerous passes are run through and several data structures
are used to represent the intermediate results.</p>
</div>
<p>LLVM is a Static Single Assignment (SSA) based representation.
LLVM provides an infinite virtual registers which can hold values of primitive
type (integral, floating point, or pointer values).
So, every operand can save in different virtual register in llvm SSA
representation.
Comment is “;” in llvm representation.
Following is the llvm SSA instructions.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">store</span> <span class="n">i32</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>  <span class="p">;</span> <span class="n">store</span> <span class="n">i32</span> <span class="n">type</span> <span class="n">of</span> <span class="mi">0</span> <span class="n">to</span> <span class="k">virtual</span> <span class="k">register</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="n">is</span>
            <span class="p">;</span>  <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span> <span class="p">;</span> <span class="n">store</span> <span class="o">%</span><span class="n">b</span> <span class="n">contents</span> <span class="n">to</span> <span class="o">%</span><span class="n">c</span> <span class="n">point</span> <span class="n">to</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="n">isi32</span> <span class="n">type</span> <span class="k">virtual</span>
            <span class="p">;</span>  <span class="k">register</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="n">is</span> <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span><span class="p">.</span>
<span class="o">%</span><span class="n">a1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>    <span class="p">;</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">value</span> <span class="n">where</span> <span class="o">%</span><span class="n">a</span> <span class="n">point</span> <span class="n">to</span> <span class="n">and</span> <span class="n">assign</span> <span class="n">the</span>
            <span class="p">;</span>  <span class="n">memory</span> <span class="n">value</span> <span class="n">to</span> <span class="o">%</span><span class="n">a1</span>
<span class="o">%</span><span class="n">a3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a2</span><span class="p">,</span> <span class="mi">1</span>  <span class="p">;</span> <span class="n">add</span> <span class="o">%</span><span class="n">a2</span> <span class="n">and</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">save</span> <span class="n">to</span> <span class="o">%</span><span class="n">a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don&#8217;t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can  read “The LLVM Target-Independent Code Generator” from <a class="footnote-reference" href="#id7" id="id3">[3]</a>
and “LLVM Language Reference Manual” from <a class="footnote-reference" href="#id8" id="id4">[4]</a>
before go ahead, but we think read section
4.2 of tricore_llvm.pdf is enough.
We suggest you read the web site documents as above only when you are still not
quite understand, even though you have read the articles of this section and
next 2 sections for DAG and Instruction Selection.</p>
<ol class="arabic simple">
<li>Instruction Selection</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
<span class="c1">//  still is llvm virtual operand.</span>
    <span class="n">store</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span> <span class="c1">// store 0 of i16 type to where virtual register %a</span>
               <span class="c1">//  point to</span>
<span class="o">=&gt;</span>  <span class="n">addiu</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Scheduling and Formation</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, reorder the instructions sequence for optimization in</span>
<span class="c1">//  instructions cycle or in register pressure.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span> <span class="c1">// st %a to *(%b+5)</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span>

<span class="c1">// Transfer above instructions order as follows. In RISC like Mips the ld %c use</span>
<span class="c1">//  the previous instruction st %c, must wait more than 1</span>
<span class="c1">// cycles. Meaning the ld cannot follow st immediately.</span>
<span class="o">=&gt;</span>  <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
<span class="c1">// If without reorder instructions, a instruction nop which do nothing must be</span>
<span class="c1">//  filled, contribute one instruction cycle more than optimization. (Actually,</span>
<span class="c1">//  Mips is scheduled with hardware dynamically and will insert nop between st</span>
<span class="c1">//  and ld instructions if compiler didn&#39;t insert nop.)</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">nop</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

<span class="c1">// Minimum register pressure</span>
<span class="c1">//  Suppose %c is alive after the instructions basic block (meaning %c will be</span>
<span class="c1">//  used after the basic block), %a and %b are not alive after that.</span>
<span class="c1">// The following no reorder version need 3 registers at least</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>

<span class="c1">// The reorder version need 2 registers only (by allocate %a and %b in the same</span>
<span class="c1">//  register)</span>
<span class="o">=&gt;</span> <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p class="first">SSA-based Machine Code Optimization</p>
<blockquote>
<div><p>For example, common expression remove, shown in next section DAG.</p>
</div></blockquote>
</li>
<li><p class="first">Register Allocation</p>
<blockquote>
<div><p>Allocate real register for virtual register.</p>
</div></blockquote>
</li>
<li><p class="first">Prologue/Epilogue Code Insertion</p>
<blockquote>
<div><p>Explain in section Add Prologue/Epilogue functions</p>
</div></blockquote>
</li>
<li><p class="first">Late Machine Code Optimizations</p>
<blockquote>
<div><p>Any “last-minute” peephole optimizations of the final machine code can be
applied during this phase.
For example, replace x = x * 2 by x = x &lt; 1 for integer operand.</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>Code Emission</dt>
<dd><p class="first last">Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</dd>
</dl>
</li>
</ol>
<p>The llvm code generation sequence also can be obtained by
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt> as the following. The first 4 code generation
sequences from <a class="pageref" href="#backendstructure-f5">Figure  5</a> are in the
<strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> of the <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt>
displayed. The order of Peephole Optimizations and Prologue/Epilogue Insertion
is inconsistent in them (please check the * in the following).
No need to bother since the the LLVM is under development and changed all the
time.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc --help-hidden
OVERVIEW: llvm system compiler

USAGE: llc <span class="o">[</span>options<span class="o">]</span> &lt;input bitcode&gt;

OPTIONS:
...
  -debug-pass                             - Print PassManager debugging <span class="nv">information</span>
    <span class="o">=</span>None                                 -   disable debug <span class="nv">output</span>
    <span class="o">=</span>Arguments                            -   print pass arguments to pass to <span class="s1">&#39;opt&#39;</span>
    <span class="o">=</span>Structure                            -   print pass structure before run<span class="o">()</span>
    <span class="o">=</span>Executions                           -   print pass name before it is <span class="nv">executed</span>
    <span class="o">=</span>Details                              -   print pass details when it is executed

118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc -march<span class="o">=</span>mips -debug-pass<span class="o">=</span>Structure ch3.bc
...
Target Library Information
Target Transform Info
Data Layout
Target Pass Configuration
No Alias Analysis <span class="o">(</span>always returns <span class="s1">&#39;may&#39;</span> <span class="nb">alias</span><span class="o">)</span>
Type-Based Alias Analysis
Basic Alias Analysis <span class="o">(</span>stateless AA impl<span class="o">)</span>
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Natural Loop Information
      Loop Pass Manager
        Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Canonicalize natural loops
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Exception handling preparation
      Optimize <span class="k">for </span>code generation
      Insert stack protectors
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Machine Function Analysis
      Natural Loop Information
      Branch Probability Analysis
    * MIPS DAG-&gt;DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
    * Peephole Optimizations
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      Eliminate PHI nodes <span class="k">for </span>register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Debug Variable Analysis
      Simple Register Coalescing
      Live Stack Slot Analysis
      Calculate spill weights
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
    * Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
    * Prologue/Epilogue Insertion &amp; Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
    * Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      Mips Delay Slot Filler
      Mips Long Branch
      MachineDominator Tree Construction
      Machine Natural Loop Construction
    * Mips Assembly Printer
      Delete Garbage Collector Information
</pre></div>
</div>
</div>
<div class="section" id="dag-directed-acyclic-graph">
<h2>DAG (Directed Acyclic Graph)<a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h2>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG. For example, the basic block code and it&#8217;s corresponding DAG as
<a class="pageref" href="#backendstructure-f6">Figure  6</a>.</p>
<div class="figure align-center" id="backendstructure-f6">
<img alt="_images/6.png" src="_images/6.png" />
<p class="caption">Figure 6: DAG example</p>
</div>
<p>If b is not live on exit from the block, then we can do common expression
remove to get the following code.</p>
<div class="highlight-c++"><pre>a = b + c
d = a – d
c = d + c</pre>
</div>
<p>As you can imagine, the common expression remove can apply in IR or machine
code.</p>
<p>DAG like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
</div>
<div class="section" id="instruction-selection">
<h2>Instruction Selection<a class="headerlink" href="#instruction-selection" title="Permalink to this headline">¶</a></h2>
<p>In back end, we need to translate IR code into machine code at Instruction
Selection Process as <a class="pageref" href="#backendstructure-f7">Figure  7</a>.</p>
<div class="figure align-center" id="backendstructure-f7">
<img alt="_images/7.png" src="_images/7.png" />
<p class="caption">Figure 7: IR and it&#8217;s corresponding machine instruction</p>
</div>
<p>For machine instruction selection, the better solution is represent IR and
machine instruction by DAG.
In <a class="pageref" href="#backendstructure-f8">Figure  8</a>, we skip the register leaf.
The rj + rk is IR DAG representation (for symbol notation, not llvm SSA form).
ADD is machine instruction.</p>
<div class="figure align-center" id="backendstructure-f8">
<img alt="_images/8.png" src="_images/8.png" />
<p class="caption">Figure 8: Instruction DAG representation</p>
</div>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ ri, rj), (- ri, 1) are lists for IR DAG; (ADD ri, rj),
(SUBI ri, 1) are lists for machine instruction DAG.</p>
<p>Now, let&#8217;s recall the ADDiu instruction defined on Cpu0InstrInfo.td in the
previous chapter. List them again as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format L instruction class in Cpu0 : &lt;|opcode|ra|rb|cx|&gt;</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs RC:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
...
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;</pre>
</div>
<p><a class="pageref" href="#backendstructure-f9">Figure  9</a> show how the pattern match work in the IR node
<strong>add</strong> and instruction ADDiu defined in Cpu0InstrInfo.td. For the example
IR node &#8220;add %a, 5&#8221;, will be translated to &#8220;addiu %r1, 5&#8221; since the IR
pattern[(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))] is set in ADDiu and the
2nd operand is signed immediate which matched &#8220;%a, 5&#8221;. In addition to pattern
match, the .td also set assembly string &#8220;addiu&#8221; and op code 0x09.
With this information, the LLVM TableGen will generate instruction both in
assembly and binary automatically (the binary instruction in obj file of ELF
format which will shown at later chapter).
Similarly, the machine instruction DAG node LD and ST can be got from IR DAG
node <strong>load</strong> and <strong>store</strong>.</p>
<div class="figure align-center" id="backendstructure-f9">
<img alt="_images/9.png" src="_images/9.png" />
<p class="caption">Figure 9: Pattern match for ADDiu instruction and IR node add</p>
</div>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-c++"><pre>def FMADDS : AForm_1&lt;59, 29,
          (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
          "fmadds $FRT, $FRA, $FRC, $FRB",
          [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                       F4RC:$FRB))]&gt;;</pre>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include node <strong>fmul</strong> and node <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">...</span>

<span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">fmul</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>
<span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fadd</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The llvm SelectionDAG Optimization Phase (is part of Instruction Selection
Process) prefered to translate this 2 IR DAG node (fmul %a, %b) (fadd %d, %c)
into one machine instruction DAG node (<strong>fmadd</strong> %a, %c, %b), than translate
them into 2 machine instruction nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fmadd</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read then llvm SSA
IR form.
So, we  use the notation form in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-c++"><pre>a = b + c   // in notation IR form
d = a – d
%e = fmadd %a, %c, %b // in llvm SSA IR form</pre>
</div>
<p>We can apply <a class="pageref" href="#backendstructure-f7">Figure  7</a> Instruction tree pattern to get the
following machine code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">load</span>  <span class="n">rb</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// assume b allocate in sp+8, sp is stack point register</span>
<span class="n">load</span>  <span class="n">rc</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
<span class="n">add</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">load</span>  <span class="n">rd</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">24</span><span class="p">);</span>
<span class="n">sub</span> <span class="n">rd</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">fmadd</span> <span class="n">re</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="add-cpu0dagtodagisel-class">
<h2>Add Cpu0DAGToDAGISel class<a class="headerlink" href="#add-cpu0dagtodagisel-class" title="Permalink to this headline">¶</a></h2>
<p>The IR DAG to machine instruction DAG transformation is introduced in the
previous section.
Now, let&#8217;s check what IR DAG nodes the file ch3.bc has. List ch3.ll as follows,</p>
<div class="highlight-c++"><pre>// ch3.ll
define i32 @main() nounwind uwtable {
%1 = alloca i32, align 4
store i32 0, i32* %1
ret i32 0
}</pre>
</div>
<p>As above, ch3.ll use the IR DAG node <strong>store</strong>, <strong>ret</strong>. Actually, it also use
<strong>add</strong> for sp (stack point) register adjust.
So, the definitions in Cpu0InstrInfo.td as follows is enough.
IR DAG is defined in file  include/llvm/Target/TargetSelectionDAG.td.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>//===----------------------------------------------------------------------===//

/// Load and Store Instructions
///  aligned
defm LD     : LoadM32&lt;0x01,  "ld",  load_a&gt;;
defm ST     : StoreM32&lt;0x02, "st",  store_a&gt;;

/// Arithmetic Instructions (ALU Immediate)
// IR "add" defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;

let isReturn=1, isTerminator=1, hasDelaySlot=1, isCodeGenOnly=1,
    isBarrier=1, hasCtrlDep=1 in
  def RET : FJ &lt;0x2C, (outs), (ins CPURegs:$target),
                "ret\t$target", [(Cpu0Ret CPURegs:$target)], IIBranch&gt;;

//===----------------------------------------------------------------------===//
</pre>
</div>
<p>Add class Cpu0DAGToDAGISel (Cpu0ISelDAGToDAG.cpp) to CMakeLists.txt, and add
following fragment to Cpu0TargetMachine.cpp,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(...</span>
  <span class="p">...</span>
  <span class="n">Cpu0ISelDAGToDAG</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">}</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">addInstSelector</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addInstSelector</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100
101
102
103
104
105
106
107
108
109
110
111
112
113
114
115
116
117
118
119
120
121
122
123
124
125
126
127
128
129
130
131
132
133
134
135
136
137
138
139
140
141
142
143
144
145
146
147
148
149
150
151
152
153
154
155
156
157
158
159
160
161
162
163
164
165
166
167
168
169
170
171
172
173
174
175
176
177
178
179
180
181
182
183</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0ISelDAGToDAG.cpp - A Dag to Dag Inst Selector for Cpu0 --------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines an instruction selector for the CPU0 target.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-isel&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/GlobalValue.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Instructions.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Intrinsics.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CFG.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Type.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineConstantPool.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineRegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/SelectionDAGISel.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/SelectionDAGNodes.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Instruction Selector Implementation</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0DAGToDAGISel - CPU0 specific code to select CPU0 machine</span>
<span class="c1">// instructions for SelectionDAG operations.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="k">namespace</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0DAGToDAGISel</span> <span class="o">:</span> <span class="k">public</span> <span class="n">SelectionDAGISel</span> <span class="p">{</span>

  <span class="c1">/// TM - Keep a reference to Cpu0TargetMachine.</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>

  <span class="c1">/// Subtarget - Keep a pointer to the Cpu0Subtarget around so that we can</span>
  <span class="c1">/// make the right decision when generating code for different targets.</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span>

<span class="k">public</span><span class="o">:</span>
  <span class="k">explicit</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">SelectionDAGISel</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span>
  <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{}</span>

  <span class="c1">// Pass Name</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;CPU0 DAG-&gt;DAG Pattern Instruction Selection&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">);</span>

<span class="k">private</span><span class="o">:</span>
  <span class="c1">// Include the pieces autogenerated from the target description.</span>
  <span class="cp">#include &quot;Cpu0GenDAGISel.inc&quot;</span>

  <span class="c1">/// getTargetMachine - Return a reference to the TargetMachine, casted</span>
  <span class="c1">/// to the target-specific type.</span>
  <span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">getTargetMachine</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;&gt;</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">/// getInstrInfo - Return a reference to the TargetInstrInfo, casted</span>
  <span class="c1">/// to the target-specific type.</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="n">SDNode</span> <span class="o">*</span><span class="n">getGlobalBaseReg</span><span class="p">();</span>

  <span class="n">SDNode</span> <span class="o">*</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">);</span>
  <span class="c1">// Complex Pattern.</span>
  <span class="kt">bool</span> <span class="n">SelectAddr</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Parent</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">N</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Base</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Offset</span><span class="p">);</span>
  <span class="c1">// getImm - Return a target constant with the specified value.</span>
  <span class="kr">inline</span> <span class="n">SDValue</span> <span class="n">getImm</span><span class="p">(</span><span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Imm</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">Ret</span> <span class="o">=</span> <span class="n">SelectionDAGISel</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">Ret</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// ComplexPattern used on Cpu0InstrInfo</span>
<span class="c1">/// Used on Cpu0 Load/Store instructions</span>
<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span>
<span class="n">SelectAddr</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Parent</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Base</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Offset</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EVT</span> <span class="n">ValTy</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>

  <span class="c1">// If Parent is an unaligned f32 load or store, select a (base + index)</span>
  <span class="c1">// floating point load/store instruction (luxc1 or suxc1).</span>
  <span class="k">const</span> <span class="n">LSBaseSDNode</span><span class="o">*</span> <span class="n">LS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">LS</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">LSBaseSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Parent</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">EVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">LS</span><span class="o">-&gt;</span><span class="n">getMemoryVT</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">VT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">&gt;</span> <span class="n">LS</span><span class="o">-&gt;</span><span class="n">getAlignment</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">TLI</span><span class="p">.</span><span class="n">allowsUnalignedMemoryAccesses</span><span class="p">(</span><span class="n">VT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;Unaligned loads/stores not supported for this type.&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">)</span>
        <span class="k">return</span> <span class="kc">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// if Address is FI, get the TargetFrameIndex.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">FrameIndexSDNode</span> <span class="o">*</span><span class="n">FIN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">FrameIndexSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Base</span>   <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetFrameIndex</span><span class="p">(</span><span class="n">FIN</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">ValTy</span><span class="p">);</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ValTy</span><span class="p">);</span>
    <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Base</span>   <span class="o">=</span> <span class="n">Addr</span><span class="p">;</span>
  <span class="n">Offset</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ValTy</span><span class="p">);</span>
  <span class="k">return</span> <span class="kc">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>

  <span class="c1">// Dump information about the Node being selected</span>
  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Selecting: &quot;</span><span class="p">;</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">);</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If we have a custom node, we already have selected!</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Node</span><span class="o">-&gt;</span><span class="n">isMachineOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;== &quot;</span><span class="p">;</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">);</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">///</span>
  <span class="c1">// Instruction Selection not handled by the auto-generated</span>
  <span class="c1">// tablegen selection should be handled here.</span>
  <span class="c1">///</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">default</span><span class="o">:</span> <span class="k">break</span><span class="p">;</span>

  <span class="k">case</span> <span class="n">ISD</span><span class="o">::</span><span class="nl">Constant:</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">CN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">CN</span><span class="o">-&gt;</span><span class="n">getValueSizeInBits</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Select the default instruction</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">ResNode</span> <span class="o">=</span> <span class="n">SelectCode</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;=&gt; &quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ResNode</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ResNode</span> <span class="o">==</span> <span class="n">Node</span><span class="p">)</span>
    <span class="n">DEBUG</span><span class="p">(</span><span class="n">Node</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">));</span>
  <span class="k">else</span>
    <span class="n">DEBUG</span><span class="p">(</span><span class="n">ResNode</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">));</span>
  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ResNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// createCpu0ISelDag - This pass converts a legalized DAG into a</span>
<span class="c1">/// CPU0-specific DAG, ready for instruction scheduling.</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p>This version adding the following code in Cpu0InstInfo.cpp to enable debug
information which called by llvm at proper time.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="n">MachineInstr</span><span class="o">*</span> <span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                 <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span> <span class="n">uint64_t</span> <span class="n">Offset</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                                 <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_3/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="n">MachineInstr</span><span class="o">*</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span>
                                        <span class="n">uint64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                        <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">DBG_VALUE</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FrameIx</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">).</span><span class="n">addMetadata</span><span class="p">(</span><span class="n">MDPtr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&amp;*</span><span class="n">MIB</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Build Chapter3_3, run it, we find the error message in Chapter3_2 is gone.
The new error message for Chapter3_3 as follows,</p>
<div class="highlight-bash"><pre>118-165-78-230:InputFiles Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o
ch3.cpu0.s
...
Target didn't implement TargetInstrInfo::storeRegToStackSlot!
1.  Running pass 'Function Pass Manager' on module 'ch3.bc'.
2.  Running pass 'Prologue/Epilogue Insertion &amp; Frame Finalization' on function
'@main'
...</pre>
</div>
</div>
<div class="section" id="add-prologue-epilogue-functions">
<h2>Add Prologue/Epilogue functions<a class="headerlink" href="#add-prologue-epilogue-functions" title="Permalink to this headline">¶</a></h2>
<p>Following came from tricore_llvm.pdf section “4.4.2 Non-static Register
Information ”.</p>
<p>For some target architectures, some aspects of the target architecture’s
register set are dependent upon variable factors and have to be determined at
runtime.
As a consequence, they cannot be generated statically from a TableGen
description – although that would be possible for the bulk of them in the case
of the TriCore backend.
Among them are the following points:</p>
<ul class="simple">
<li>Callee-saved registers. Normally, the ABI specifies a set of registers that a
function must save on entry and restore on return if their contents are
possibly modified during execution.</li>
<li>Reserved registers. Although the set of unavailable registers is already
defined in the TableGen file, TriCoreRegisterInfo contains a method that marks
all non-allocatable register numbers in a bit vector.</li>
</ul>
<p>The following methods are implemented:</p>
<ul class="simple">
<li>emitPrologue() inserts prologue code at the beginning of a function. Thanks
to TriCore’s context model, this is a trivial task as it is not required to
save any registers manually. The only thing that has to be done is reserving
space for the function’s stack frame by decrementing the stack pointer.
In addition, if the function needs a frame pointer, the frame register %a14 is
set to the old value of the stack pointer beforehand.</li>
<li>emitEpilogue() is intended to emit instructions to destroy the stack frame
and restore all previously saved registers before returning from a function.
However, as %a10 (stack pointer), %a11 (return address), and %a14 (frame
pointer, if any) are all part of the upper context, no epilogue code is needed
at all. All cleanup operations are performed implicitly by the ret instruction.</li>
<li>eliminateFrameIndex() is called for each instruction that references a word
of data in a stack slot. All previous passes of the code generator have been
addressing stack slots through an abstract frame index and an immediate offset.
The purpose of this function is to translate such a reference into a
register–offset pair. Depending on whether the machine function that contains
the instruction has a fixed or a variable stack frame, either the stack pointer
%a10 or the frame pointer %a14 is used as the base register.
The offset is computed accordingly.
<a class="pageref" href="#backendstructure-f10">Figure  10</a> demonstrates for both cases how a stack slot
is addressed.</li>
</ul>
<p>If the addressing mode of the affected instruction cannot handle the address
because the offset is too large (the offset field has 10 bits for the BO
addressing mode and 16 bits for the BOL mode), a sequence of instructions is
emitted that explicitly computes the effective address.
Interim results are put into an unused address register.
If none is available, an already occupied address register is scavenged.
For this purpose, LLVM’s framework offers a class named RegScavenger that
takes care of all the details.</p>
<div class="figure align-center" id="backendstructure-f10">
<img alt="_images/10.png" src="_images/10.png" />
<p class="caption">Figure 10: Addressing of a variable a located on the stack.
If the stack frame has a variable size, slot must be addressed relative to
the frame pointer</p>
</div>
<p>We will explain the Prologue and Epilogue further by example code.
So for the following llvm IR code, Cpu0 back end will emit the corresponding
machine instructions as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  ret i32 0
<span class="o">}</span>

  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>LLVM get the stack size by parsing IR and counting how many virtual registers
is assigned to local variables. After that, it call emitPrologue().
This function will emit machine instructions to adjust sp (stack pointer
register) for local variables since we don&#8217;t use fp (frame pointer register).
For our example, it will emit the instructions,</p>
<div class="highlight-c++"><pre>addiu $sp, $sp, -8</pre>
</div>
<p>The  emitEpilogue will emit “addiu  $sp, $sp, 8”, 8 is the stack size.</p>
<p>Since Instruction Selection and Register Allocation occurs before
Prologue/Epilogue Code Insertion, eliminateFrameIndex() is called after machine
instruction and real register allocated.
It translate the frame index of local variable (%1 and %2 in the following
example) into stack offset according the frame index order upward (stack grow
up downward from high address to low address, 0($sp) is the top, 52($sp) is the
bottom) as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
     %1 <span class="o">=</span> alloca i32, align 4
     %2 <span class="o">=</span> alloca i32, align 4
    ...
    store i32 0, i32* %1
    store i32 5, i32* %2, align 4
    ...
    ret i32 <span class="nv">0</span>

<span class="o">=</span>&gt; <span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -56
<span class="nv">$tmp1</span>:
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$3</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %1 is the first frame index <span class="nb">local </span>variable, so allocate
                    // in 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %2 is the second frame index <span class="nb">local </span>variable, so
                    // allocate in 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
  ret <span class="nv">$lr</span>
</pre></div>
</div>
<p>The Prologue and Epilogue functions as follows,</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="n">expandLargeImm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">int64_t</span> <span class="n">Imm</span><span class="p">,</span> 
                           <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">&amp;</span> <span class="n">MBB</span><span class="p">,</span>
                           <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZEROReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ATReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">;</span>
  <span class="n">Cpu0AnalyzeImmediate</span> <span class="n">AnalyzeImm</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Seq</span> <span class="o">=</span>
    <span class="n">AnalyzeImm</span><span class="p">.</span><span class="n">Analyze</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="kc">false</span> <span class="cm">/* LastInstrIsADDiu */</span><span class="p">);</span>
  <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">InstSeq</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">Inst</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">Opc</span><span class="p">),</span> <span class="n">ATReg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZEROReg</span><span class="p">)</span>
    <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">SignExtend64</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">ImmOpnd</span><span class="p">));</span>

  <span class="c1">// Build the remaining instructions in Seq.</span>
  <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">Inst</span><span class="p">;</span> <span class="n">Inst</span> <span class="o">!=</span> <span class="n">Seq</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">Inst</span><span class="p">)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">Opc</span><span class="p">),</span> <span class="n">ATReg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ATReg</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">SignExtend64</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">ImmOpnd</span><span class="p">));</span>

  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Reg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ATReg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span>   <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span>    <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span>
    <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0InstrInfo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">MBBI</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="n">MBBI</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">()</span> <span class="o">:</span> <span class="n">DebugLoc</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>
  <span class="c1">// First, compute final stack size.</span>
  <span class="kt">unsigned</span> <span class="n">StackAlign</span> <span class="o">=</span> <span class="n">getStackAlignment</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">LocalVarAreaOffset</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getMaxCallFrameSize</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">StackSize</span> <span class="o">=</span>  <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">LocalVarAreaOffset</span><span class="p">,</span> <span class="n">StackAlign</span><span class="p">)</span> <span class="o">+</span>
     <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">(),</span> <span class="n">StackAlign</span><span class="p">);</span>

   <span class="c1">// Update stack size</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setStackSize</span><span class="p">(</span><span class="n">StackSize</span><span class="p">);</span>

  <span class="c1">// No need to allocate space on the stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">StackSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">adjustsStack</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">MachineModuleInfo</span> <span class="o">&amp;</span><span class="n">MMI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getMMI</span><span class="p">();</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">MachineMove</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Moves</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getFrameMoves</span><span class="p">();</span>
  <span class="n">MachineLocation</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">;</span>

  <span class="c1">// Adjust stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">StackSize</span><span class="p">))</span> <span class="c1">// addiu sp, sp, (-stacksize)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="o">-</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span> <span class="c1">// Expand immediate that doesn&#39;t fit in 16-bit.</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setEmitNOAT</span><span class="p">();</span>
    <span class="n">expandLargeImm</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="o">-</span><span class="n">StackSize</span><span class="p">,</span> <span class="n">TII</span><span class="p">,</span> <span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// emit &quot;.cfi_def_cfa_offset StackSize&quot;</span>
  <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">AdjustSPLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
          <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">AdjustSPLabel</span><span class="p">);</span>
  <span class="n">DstML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
  <span class="n">SrcML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">,</span> <span class="o">-</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="n">Moves</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MachineMove</span><span class="p">(</span><span class="n">AdjustSPLabel</span><span class="p">,</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">));</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Find the instruction past the last instruction that saves a callee-saved</span>
    <span class="c1">// register to the stack.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">++</span><span class="n">MBBI</span><span class="p">;</span>

    <span class="c1">// Iterate over list of callee-saved registers and emit .cfi_offset</span>
    <span class="c1">// directives.</span>
    <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">CSLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
            <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">CSLabel</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
           <span class="n">E</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">int64_t</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getFrameIdx</span><span class="p">());</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getReg</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="c1">// Reg is either in CPURegs or FGR32.</span>
        <span class="n">DstML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">,</span> <span class="n">Offset</span><span class="p">);</span>
        <span class="n">SrcML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
        <span class="n">Moves</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MachineMove</span><span class="p">(</span><span class="n">CSLabel</span><span class="p">,</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">getLastNonDebugInstr</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span>            <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span>
    <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0InstrInfo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">MBBI</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>

  <span class="c1">// Get the number of bytes from FrameInfo</span>
  <span class="n">uint64_t</span> <span class="n">StackSize</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StackSize</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Adjust stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StackSize</span><span class="p">))</span> <span class="c1">// addiu sp, sp, (stacksize)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span> <span class="c1">// Expand immediate that doesn&#39;t fit in 16-bit.</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setEmitNOAT</span><span class="p">();</span>
    <span class="n">expandLargeImm</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="n">StackSize</span><span class="p">,</span> <span class="n">TII</span><span class="p">,</span> <span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// This method is called immediately before PrologEpilogInserter scans the </span>
<span class="c1">//  physical registers used to determine what callee saved registers should be </span>
<span class="c1">//  spilled. This method is optional. </span>
<span class="c1">// Without this will have following errors,</span>
<span class="c1">//  Target didn&#39;t implement TargetInstrInfo::storeRegToStackSlot!</span>
<span class="c1">//  UNREACHABLE executed at /usr/local/llvm/3.1.test/cpu0/1/src/include/llvm/</span>
<span class="c1">//  Target/TargetInstrInfo.h:390!</span>
<span class="c1">//  Stack dump:</span>
<span class="c1">//  0.	Program arguments: /usr/local/llvm/3.1.test/cpu0/1/cmake_debug_build/</span>
<span class="c1">//  bin/llc -march=cpu0 -relocation-model=pic -filetype=asm ch0.bc -o </span>
<span class="c1">//  ch0.cpu0.s</span>
<span class="c1">//  1.	Running pass &#39;Function Pass Manager&#39; on module &#39;ch0.bc&#39;.</span>
<span class="c1">//  2.	Running pass &#39;Prologue/Epilogue Insertion &amp; Frame Finalization&#39; on </span>
<span class="c1">//      function &#39;@main&#39;</span>
<span class="c1">//  Aborted (core dumped)</span>

<span class="c1">// Must exist</span>
<span class="c1">//	ldi	$sp, $sp, 8</span>
<span class="c1">//-&gt;	ret	$lr</span>
<span class="c1">//	.set	macro</span>
<span class="c1">//	.set	reorder</span>
<span class="c1">//	.end	main</span>
<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span>
<span class="n">processFunctionBeforeCalleeSavedScan</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                     <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineRegisterInfo</span><span class="o">&amp;</span> <span class="n">MRI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">();</span>

  <span class="c1">// FIXME: remove this code if register allocator can correctly mark</span>
  <span class="c1">//        $fp and $ra used or unused.</span>

  <span class="c1">// The register allocator might determine $ra is used after seeing</span>
  <span class="c1">// instruction &quot;jr $ra&quot;, but we do not want PrologEpilogInserter to insert</span>
  <span class="c1">// instructions to save/restore $ra unless there is a function call.</span>
  <span class="c1">// To correct this, $ra is explicitly marked unused if there is no</span>
  <span class="c1">// function call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasCalls</span><span class="p">())</span>
    <span class="n">MRI</span><span class="p">.</span><span class="n">setPhysRegUsed</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span>
    <span class="n">MRI</span><span class="p">.</span><span class="n">setPhysRegUnused</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0AnalyzeImmediate.h</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre> 1
 2
 3
 4
 5
 6
 7
 8
 9
10
11
12
13
14
15
16
17
18
19
20
21
22
23
24
25
26
27
28
29
30
31
32
33
34
35
36
37
38
39
40
41
42
43
44
45
46
47
48
49
50
51
52
53
54
55
56</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0AnalyzeImmediate.h - Analyze Immediates ------------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0_ANALYZE_IMMEDIATE_H</span>
<span class="cp">#define CPU0_ANALYZE_IMMEDIATE_H</span>

<span class="cp">#include &quot;llvm/ADT/SmallVector.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/DataTypes.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">Cpu0AnalyzeImmediate</span> <span class="p">{</span>
  <span class="k">public</span><span class="o">:</span>
    <span class="k">struct</span> <span class="n">Inst</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="n">ImmOpnd</span><span class="p">;</span>
      <span class="n">Inst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ImmOpnd</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Inst</span><span class="p">,</span> <span class="mi">7</span> <span class="o">&gt;</span> <span class="n">InstSeq</span><span class="p">;</span>

    <span class="c1">/// Analyze - Get an instrucion sequence to load immediate Imm. The last</span>
    <span class="c1">/// instruction in the sequence must be an ADDiu if LastInstrIsADDiu is</span>
    <span class="c1">/// true;</span>
    <span class="k">const</span> <span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Analyze</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">LastInstrIsADDiu</span><span class="p">);</span>
  <span class="k">private</span><span class="o">:</span>
    <span class="k">typedef</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">InstSeq</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">InstSeqLs</span><span class="p">;</span>

    <span class="c1">/// AddInstr - Add I to all instruction sequences in SeqLs.</span>
    <span class="kt">void</span> <span class="n">AddInstr</span><span class="p">(</span><span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Inst</span> <span class="o">&amp;</span><span class="n">I</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLsADDiu - Get instrucion sequences which end with an ADDiu to</span>
    <span class="c1">/// load immediate Imm</span>
    <span class="kt">void</span> <span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLsORi - Get instrucion sequences which end with an ORi to</span>
    <span class="c1">/// load immediate Imm</span>
    <span class="kt">void</span> <span class="n">GetInstSeqLsORi</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLsSHL - Get instrucion sequences which end with a SHL to</span>
    <span class="c1">/// load immediate Imm</span>
    <span class="kt">void</span> <span class="n">GetInstSeqLsSHL</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLs - Get instrucion sequences to load immediate Imm.</span>
    <span class="kt">void</span> <span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">ADDiu</span><span class="p">,</span> <span class="n">ORi</span><span class="p">,</span> <span class="n">SHL</span><span class="p">;</span>
    <span class="n">InstSeq</span> <span class="n">Insts</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0AnalyzeImmediate.cpp</p>
<div class="highlight-c++"><table class="highlighttable"><tr><td class="linenos"><div class="linenodiv"><pre>  1
  2
  3
  4
  5
  6
  7
  8
  9
 10
 11
 12
 13
 14
 15
 16
 17
 18
 19
 20
 21
 22
 23
 24
 25
 26
 27
 28
 29
 30
 31
 32
 33
 34
 35
 36
 37
 38
 39
 40
 41
 42
 43
 44
 45
 46
 47
 48
 49
 50
 51
 52
 53
 54
 55
 56
 57
 58
 59
 60
 61
 62
 63
 64
 65
 66
 67
 68
 69
 70
 71
 72
 73
 74
 75
 76
 77
 78
 79
 80
 81
 82
 83
 84
 85
 86
 87
 88
 89
 90
 91
 92
 93
 94
 95
 96
 97
 98
 99
100</pre></div></td><td class="code"><div class="highlight"><pre><span class="c1">//===-- Cpu0AnalyzeImmediate.cpp - Analyze Immediates ---------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#include &quot;Cpu0AnalyzeImmediate.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/MathExtras.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">Inst</span><span class="o">::</span><span class="n">Inst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">O</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">I</span><span class="p">)</span> <span class="o">:</span> <span class="n">Opc</span><span class="p">(</span><span class="n">O</span><span class="p">),</span> <span class="n">ImmOpnd</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Add I to the instruction sequences.</span>
<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">AddInstr</span><span class="p">(</span><span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Inst</span> <span class="o">&amp;</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Add an instruction seqeunce consisting of just I.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SeqLs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SeqLs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">InstSeq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">InstSeqLs</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span> <span class="o">=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">Iter</span> <span class="o">!=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">Iter</span><span class="p">)</span>
    <span class="n">Iter</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                             <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GetInstSeqLs</span><span class="p">((</span><span class="n">Imm</span> <span class="o">+</span> <span class="mh">0x8000ULL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffff0000ULL</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">,</span> <span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffffULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLsORi</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                           <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffff0000ULL</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">ORi</span><span class="p">,</span> <span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffffULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLsSHL</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                           <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Shamt</span> <span class="o">=</span> <span class="n">CountTrailingZeros_64</span><span class="p">(</span><span class="n">Imm</span><span class="p">);</span>
  <span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">Imm</span> <span class="o">&gt;&gt;</span> <span class="n">Shamt</span><span class="p">,</span> <span class="n">RemSize</span> <span class="o">-</span> <span class="n">Shamt</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">SHL</span><span class="p">,</span> <span class="n">Shamt</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                        <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">uint64_t</span> <span class="n">MaskedImm</span> <span class="o">=</span> <span class="n">Imm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xffffffffffffffffULL</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">Size</span><span class="p">));</span>

  <span class="c1">// Do nothing if Imm is 0.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MaskedImm</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// A single ADDiu will do if RemSize &lt;= 16.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RemSize</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">,</span> <span class="n">MaskedImm</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Shift if the lower 16-bit is cleared.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">GetInstSeqLsSHL</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>

  <span class="c1">// If bit 15 is cleared, it doesn&#39;t make a difference whether the last</span>
  <span class="c1">// instruction is an ADDiu or ORi. In that case, do not call GetInstSeqLsORi.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InstSeqLs</span> <span class="n">SeqLsORi</span><span class="p">;</span>
    <span class="n">GetInstSeqLsORi</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLsORi</span><span class="p">);</span>
    <span class="n">SeqLs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">SeqLsORi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">SeqLsORi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">InstSeq</span>
<span class="o">&amp;</span><span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">Analyze</span><span class="p">(</span><span class="n">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="n">LastInstrIsADDiu</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">;</span>

  <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>
  <span class="n">ORi</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">;</span>
  <span class="n">SHL</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SHL</span><span class="p">;</span>

  <span class="n">InstSeqLs</span> <span class="n">SeqLs</span><span class="p">;</span>

  <span class="c1">// Get the list of instruction sequences.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LastInstrIsADDiu</span> <span class="o">|</span> <span class="o">!</span><span class="n">Imm</span><span class="p">)</span>
    <span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>

  <span class="n">Insts</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">Insts</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">());</span>

  <span class="k">return</span> <span class="n">Insts</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</td></tr></table></div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">//- If eliminateFrameIndex() is empty, it will hang on run. </span>
<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MI</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">isFI</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Instr doesn&#39;t have FrameIndex operand!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Function : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MI</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">FrameIndex</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">getIndex</span><span class="p">();</span>
  <span class="n">uint64_t</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>
  <span class="n">int64_t</span> <span class="n">spOffset</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FrameIndex : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">FrameIndex</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;spOffset   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spOffset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;stackSize  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stackSize</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">MinCSFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MinCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
    <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// The following stack frame objects are always referenced relative to $sp:</span>
  <span class="c1">//  1. Outgoing arguments.</span>
  <span class="c1">//  2. Pointer to dynamically allocated stack space.</span>
  <span class="c1">//  3. Locations for callee-saved registers.</span>
  <span class="c1">// Everything else is referenced relative to whatever register</span>
  <span class="c1">// getFrameRegister() returns.</span>
  <span class="kt">unsigned</span> <span class="n">FrameReg</span><span class="p">;</span>

    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>

  <span class="c1">// Calculate final offset.</span>
  <span class="c1">// - There is no need to change the offset if the frame object is one of the</span>
  <span class="c1">//   following: an outgoing argument, pointer to a dynamically allocated</span>
  <span class="c1">//   stack space or a $gp restore location,</span>
  <span class="c1">// - If the frame object is any of the following, its offset must be adjusted</span>
  <span class="c1">//   by adding the size of the stack:</span>
  <span class="c1">//   incoming argument, callee-saved register location or local variable.</span>
  <span class="n">int64_t</span> <span class="n">Offset</span><span class="p">;</span>
  <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span> <span class="o">+</span> <span class="p">(</span><span class="n">int64_t</span><span class="p">)</span><span class="n">stackSize</span><span class="p">;</span>

  <span class="n">Offset</span>    <span class="o">+=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Offset     : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If MI is not a debug value, make sure Offset fits in the 16-bit immediate</span>
  <span class="c1">// field.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">isDebugValue</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;(!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset))&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ChangeToRegister</span><span class="p">(</span><span class="n">FrameReg</span><span class="p">,</span> <span class="kc">false</span><span class="p">);</span>
  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">ChangeToImmediate</span><span class="p">(</span><span class="n">Offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
</pre></div>
</div>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(...</span>
  <span class="p">...</span>
  <span class="n">Cpu0AnalyzeImmediate</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>After add these Prologue and Epilogue functions, and build with Chapter3_4/Cpu0.
Now we are ready to compile our example code ch3.bc into cpu0 assembly code.
Following is the command and output file ch3.cpu0.s,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o ch3.cpu0.s
118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>cat ch3.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>To see how the <strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> work in llc, let&#8217;s
compile with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> option and see what happens.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
...
Optimized legalized selection DAG: BB#0 <span class="s1">&#39;main:&#39;</span>
SelectionDAG has 8 nodes:
  0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

  0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>

      0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

      0x7fbe4082d010: &lt;multiple use&gt;
      0x7fbe4082d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>

      0x7fbe4082d210: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>

    0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668, 0x7fbe4082d010, 0x7fbe4082d110,
    0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

    0x7fbe4082d410: &lt;multiple use&gt;
    0x7fbe4082d010: &lt;multiple use&gt;
  0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
  0x7fbe4082d010 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

    0x7fbe4082d510: &lt;multiple use&gt;
    0x7fbe4082d410: &lt;multiple use&gt;
    0x7fbe4082d510: &lt;multiple use&gt;
  0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fbe4082d510, 0x7fbe4082d410,
  0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>


<span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;&#39;</span>
Selecting: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fbe4082d510, 0x7fbe4082d410,
0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret
0x7fbe4082d510, 0x7fbe4082d410, 0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

  Morphed node: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> RET 0x7fbe4082d410, 0x7fbe4082d510,
  0x7fbe4082d510:1

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> RET 0x7fbe4082d410, 0x7fbe4082d510, 0x7fbe4082d510:1

Selecting: 0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
0x7fbe4082d010 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
0x7fbe4082d010

Selecting: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668, 0x7fbe4082d010,
0x7fbe4082d110, 0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668,
0x7fbe4082d010, 0x7fbe4082d110, 0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

  Initial Opcode index to 166
  Morphed node: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> ST 0x7fbe4082d010, 0x7fbe4082d710,
  0x7fbe4082d810, 0x7fbe40410668&lt;Mem:ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> ST 0x7fbe4082d010, 0x7fbe4082d710, 0x7fbe4082d810,
0x7fbe40410668&lt;Mem:ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

Selecting: 0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0

Selecting: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span>
Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

  Initial Opcode index to 1201
  Morphed node: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbe4082d110, 0x7fbe4082d810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbe4082d110, 0x7fbe4082d810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

Selecting: 0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

<span class="o">=====</span> Instruction selection ends:
</pre></div>
</div>
<p>Summary above translation into Table: Chapter 3 .bc IR instructions.</p>
<table border="1" class="docutils">
<caption>Chapter 3 .bc IR instructions</caption>
<colgroup>
<col width="40%" />
<col width="47%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">Cpu0</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>constant 0</td>
<td>constant 0</td>
<td>addiu</td>
</tr>
<tr class="row-odd"><td>store</td>
<td>store</td>
<td>st</td>
</tr>
<tr class="row-even"><td>ret</td>
<td>Cpu0ISD::Ret</td>
<td>ret</td>
</tr>
</tbody>
</table>
<p>From above <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> display, we see the <strong>store</strong> and <strong>ret</strong> are
translated into <strong>store</strong> and <strong>Cpu0ISD::Ret</strong> in stage Optimized legalized
selection DAG, and then translated into Cpu0 instructions <strong>st</strong> and <strong>ret</strong>
finally.
Since store use <strong>constant 0</strong> (<strong>store i32 0, i32* %1</strong> in this example), the
constant 0 will be translated into <strong>&#8220;addiu $2, $zero, 0&#8221;</strong> via the following
pattern defined in Cpu0InstrInfo.td.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>//===----------------------------------------------------------------------===//

// Small immediates

def : Pat&lt;(i32 immSExt16:$in),
          (ADDiu ZERO, imm:$in)&gt;;
</pre>
</div>
<p>At this point, we have translate the very simple main() function with return 0
single instruction. The Cpu0AnalyzeImmediate.cpp defined as above and the
Cpu0InstrInfo.td instructions add as below, takes care
the 32 bits stack size adjustments.</p>
<p class="rubric">LLVMBackendTutorialExampleCode/Chapter3_4/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def shamt       : Operand&lt;i32&gt;;

// Unsigned Operand
def uimm16      : Operand&lt;i32&gt; {
  let PrintMethod = "printUnsignedImm";
}
...
// Node immediate fits as 16-bit zero extended on target immediate.
// The LO16 param means that only the lower 16 bits of the node
// immediate are caught.
// e.g. addiu, sltiu
def immZExt16  : PatLeaf&lt;(imm), [{
  if (N-&gt;getValueType(0) == MVT::i32)
    return (uint32_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
  else
    return (uint64_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
}]&gt;;

// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;
...
// Arithmetic and logical instructions with 3 register operands.
class ArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set RC:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;  // e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
...

// Shifts
class shift_rotate_imm&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
                       RegisterClass RC&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, ImmOpnd:$shamt),
     !strconcat(instr_asm, "\t$ra, $rb, $shamt"),
     [(set RC:$ra, (OpNode RC:$rb, PF:$shamt))], IIAlu&gt; {
  let rc = isRotate;
  let shamt = shamt;
}

// 32-bit shift instructions.
class shift_rotate_imm32&lt;bits&lt;8&gt; func, bits&lt;4&gt; isRotate, string instr_asm,
                         SDNode OpNode&gt;:
  shift_rotate_imm&lt;func, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs&gt;;
...
def ORi     : ArithLogicI&lt;0x0D, "ori", or, uimm16, immZExt16, CPURegs&gt;;

/// Arithmetic Instructions (3-Operand, R-Type)
def ADDu    : ArithLogicR&lt;0x11, "addu", add, IIAlu, CPURegs, 1&gt;;

/// Shift Instructions
def SHL     : shift_rotate_imm32&lt;0x1E, 0x00, "shl", shl&gt;;
...</pre>
</div>
<p>The Cpu0AnalyzeImmediate.cpp written in recursive and a little complicate in
logic. You can skip these recursive code and think these code in last chapter 12.
Since in Chapter 12 Optimization, it replace addiu and shl with lui single
instruction, you have chance to think this thing in details. Anyway, the recursive
skills is used in the front end compile book, you should fimiliar with it.
Instead tracking the code, listing the stack size and the instructions
generated in Table: Cpu0 stack adjustment instructions as follows,</p>
<table border="1" class="docutils">
<caption>Cpu0 stack adjustment instructions</caption>
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stack size range</th>
<th class="head">ex. stack size</th>
<th class="head">Cpu0 Prologue instructions</th>
<th class="head">Cpu0 Epilogue instructions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0 ~ 0x7fff</td>
<td><ul class="first last simple">
<li>0x7fff</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, 32767;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, 32767;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>0x8000 ~ 0xffff</td>
<td><ul class="first last simple">
<li>0x8000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, -32768;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 1;</li>
<li>shl $1, $1, 16;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>x10000 ~ 0xffffffff</td>
<td><ul class="first last simple">
<li>0x7fffffff</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -1;</li>
<li>shl $1, $1, 31;</li>
<li>addiu $1, $1, 1;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 1;</li>
<li>shl $1, $1, 31;</li>
<li>addiu $1, $1, -1;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>x10000 ~ 0xffffffff</td>
<td><ul class="first last simple">
<li>0x90008000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -9;</li>
<li>shl $1, $1, 28;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -28671;</li>
<li>shl $1, $1, 16</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Assume sp = 0xa0008000 and stack size = 0x90008000, then (0xa0008000 -
0x90008000) =&gt; 0x10000000. Verify with the Cpu0 Prologue instructions as
follows,</p>
<ol class="arabic simple">
<li>&#8220;addiu       $1, $zero, -9&#8221; =&gt; ($1 = 0 + 0xfffffff7) =&gt; $1 = 0xfffffff7.</li>
<li>&#8220;shl $1, $1, 28;&#8221; =&gt; $1 = 0x70000000.</li>
<li>&#8220;addiu       $1, $1, -32768&#8221; =&gt; $1 = (0x70000000 + 0xffff8000) =&gt; $1 = 0x6fff8000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0xa0008000 + 0x6fff8000) =&gt; $sp = 0x10000000.</li>
</ol>
<p>Verify with the Cpu0 Epilogue instructions with sp = 0x10000000 and stack size =
0x90008000 as follows,</p>
<ol class="arabic simple">
<li>&#8220;addiu       $1, $zero, -28671&#8221; =&gt; ($1 = 0 + 0xffff9001) =&gt; $1 = 0xffff9001.</li>
<li>&#8220;shl $1, $1, 16;&#8221; =&gt; $1 = 0x90010000.</li>
<li>&#8220;addiu       $1, $1, -32768&#8221; =&gt; $1 = (0x90010000 + 0xffff8000) =&gt; $1 = 0x90008000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0x10000000 + 0x90008000) =&gt; $sp = 0xa0008000.</li>
</ol>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this Chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>Summary the functions for llvm backend stages as the following table.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc
-debug-pass<span class="o">=</span>Structure -o -
...
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      ...
      CPU0 DAG-&gt;DAG Pattern Instruction Selection
        Initial selection DAG
        Optimized lowered selection DAG
        Type-legalized selection DAG
        Optimized <span class="nb">type</span>-legalized selection DAG
        Legalized selection DAG
        Optimized legalized selection DAG
        Instruction selection
        Selected selection DAG
        Scheduling
      ...
      Greedy Register Allocator
      ...
      Post-RA pseudo instruction expansion pass
      ...
      Cpu0 Assembly Printer
</pre></div>
</div>
<table border="1" class="docutils">
<caption>functions for llvm backend stage</caption>
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Before CPU0 DAG-&gt;DAG Pattern Instruction Selection</td>
<td><ul class="first last simple">
<li>Cpu0TargetLowering::LowerFormalArguments</li>
<li>Cpu0TargetLowering::LowerReturn</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Instruction selection</td>
<td><ul class="first last simple">
<li>Cpu0DAGToDAGISel::Select</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>Prologue/Epilogue Insertion &amp; Frame Finalization</td>
<td><ul class="first last simple">
<li>Cpu0FrameLowering.cpp</li>
<li>Cpu0RegisterInfo::eliminateFrameIndex()</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Cpu0 Assembly Printer</td>
<td><ul class="first last simple">
<li>Cpu0AsmPrinter.cpp -&gt; Cpu0MCInstLower.cpp</li>
<li>Cpu0InstPrinter.cpp</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>We have finished a simple assembler for cpu0 which only support <strong>ld</strong>,
<strong>st</strong>, <strong>addiu</strong>, <strong>ori</strong>, <strong>addu</strong>, <strong>shl</strong> and <strong>ret</strong> 7 instructions.</p>
<p>We are satisfied with this result.
But you may think “After so many codes we program, and just get these 7
instructions”.
The point is we have created a frame work for cpu0 target machine (please
look back the llvm back end structure class inherit tree early in this
chapter).
Until now, we have over 3000 lines of source code with comments which include
files *.cpp, *.h, *.td, CMakeLists.txt and LLVMBuild.txt.
It can be counted by command <tt class="docutils literal"><span class="pre">wc</span> <span class="pre">`find</span> <span class="pre">dir</span> <span class="pre">-name</span> <span class="pre">*.cpp`</span></tt> for files *.cpp,
*.h, *.td, *.txt.
LLVM front end tutorial have 700 lines of source code without comments totally.
Don&#8217;t feel down with this result.
In reality, write a back end is warm up slowly but run fast.
Clang has over 500,000 lines of source code with comments in clang/lib
directory which include C++ and Obj C support.
Mips back end has only 15,000 lines with comments.
Even the complicate X86 CPU which CISC outside and RISC inside (micro
instruction), has only 45,000 lines with comments.
In next chapter, we will show you that add a new instruction support is as easy
as 123.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Adding arithmetic and local pointer support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>