<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Backend structure &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Arithmetic and logic lsupport" href="otherinst.html" />
    <link rel="prev" title="Cpu0 Instruction Set and LLVM Target Description" href="llvmstructure.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Backend structure</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Arithmetic and logic lsupport</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="backend-structure">
<span id="sec-backendstructure"></span><h1>Backend structure<a class="headerlink" href="#backend-structure" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduce the back end class inherit tree and class members first.
Next, following the back end structure, adding individual class implementation
in each section.
There are compiler knowledge like DAG (Directed-Acyclic-Graph) and instruction
selection needed in this chapter.
This chapter explains these knowledge just when needed.
At the end of this chapter, we will have a back end to compile llvm
intermediate code into cpu0 assembly code.</p>
<p>Many code are added in this chapter. They almost are common in every back end
except the back end name (cpu0 or mips ...). Actually, we copy almost all the
code from mips and replace the name with cpu0. In addition to knowing the DAGs
pattern match in compiler code generation process and the llvm process phase,
please focus on the classes
relationship in this backend structure. Once knowing the structure, you can
create your backend structure as quickly as we did, even though there are 3000
lines of code in this chapter.</p>
<div class="section" id="targetmachine-structure">
<h2>TargetMachine structure<a class="headerlink" href="#targetmachine-structure" title="Permalink to this headline">¶</a></h2>
<p>Your back end should define a TargetMachine class, for example, we define the
Cpu0TargetMachine class.
Cpu0TargetMachine class contains it&#8217;s own instruction class, frame/stack class,
DAG (Directed-Acyclic-Graph) class, and register class.
The Cpu0TargetMachine contents and it&#8217;s own class as follows,</p>
<p class="rubric">include/llvm/Target/TargetMachine.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- TargetMachine.h</span>
<span class="k">class</span> <span class="nc">TargetMachine</span> <span class="p">{</span>
  <span class="n">TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="p">...</span>
<span class="nl">public:</span>
  <span class="c1">// Interfaces to the major aspects of target machine information:</span>
  <span class="c1">// -- Instruction opcode and operand information</span>
  <span class="c1">// -- Pipelines and scheduling information</span>
  <span class="c1">// -- Stack frame information</span>
  <span class="c1">// -- Selection DAG lowering information</span>
  <span class="c1">//</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span>         <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetLowering</span>    <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetSelectionDAGInfo</span> <span class="o">*</span><span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span>             <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="mi">0</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
  <span class="c1">/// getSubtarget - This method returns a pointer to the specified type of</span>
  <span class="c1">/// TargetSubtargetInfo.  In debug builds, it verifies that the object being</span>
  <span class="c1">/// returned is of the correct type.</span>
  <span class="k">template</span><span class="o">&lt;</span><span class="k">typename</span> <span class="n">STC</span><span class="o">&gt;</span> <span class="k">const</span> <span class="n">STC</span> <span class="o">&amp;</span><span class="n">getSubtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">STC</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">getSubtargetImpl</span><span class="p">());</span>
  <span class="p">}</span>

<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">LLVMTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetMachine</span> <span class="p">{</span>
<span class="nl">protected:</span> <span class="c1">// Can only create subclasses.</span>
  <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TargetTriple</span><span class="p">,</span>
          <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="n">TargetOptions</span> <span class="n">Options</span><span class="p">,</span>
          <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
          <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetObjectFile.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- llvm/Target/Cpu0TargetObjectFile.h - Cpu0 Object Info ---*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef LLVM_TARGET_CPU0_TARGETOBJECTFILE_H</span>
<span class="cp">#define LLVM_TARGET_CPU0_TARGETOBJECTFILE_H</span>

<span class="cp">#include &quot;llvm/CodeGen/TargetLoweringObjectFileImpl.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetObjectFile</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLoweringObjectFileELF</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetObjectFile.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetObjectFile.cpp - Cpu0 Object Files ----------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetObjectFile.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DerivedTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/GlobalVariable.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSectionELF.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ELF.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span>
<span class="n">SSThreshold</span><span class="p">(</span><span class="s">&quot;cpu0-ssection-threshold&quot;</span><span class="p">,</span> <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">,</span>
            <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Small data and bss section threshold size (default=8)&quot;</span><span class="p">),</span>
            <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="mi">8</span><span class="p">));</span>

<span class="kt">void</span> <span class="n">Cpu0TargetObjectFile</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">MCContext</span> <span class="o">&amp;</span><span class="n">Ctx</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">){</span>
  <span class="n">TargetLoweringObjectFileELF</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">Ctx</span><span class="p">,</span> <span class="n">TM</span><span class="p">);</span>

  <span class="n">SmallDataSection</span> <span class="o">=</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">getELFSection</span><span class="p">(</span><span class="s">&quot;.sdata&quot;</span><span class="p">,</span> <span class="n">ELF</span><span class="o">::</span><span class="n">SHT_PROGBITS</span><span class="p">,</span>
                               <span class="n">ELF</span><span class="o">::</span><span class="n">SHF_WRITE</span> <span class="o">|</span><span class="n">ELF</span><span class="o">::</span><span class="n">SHF_ALLOC</span><span class="p">,</span>
                               <span class="n">SectionKind</span><span class="o">::</span><span class="n">getDataRel</span><span class="p">());</span>

  <span class="n">SmallBSSSection</span> <span class="o">=</span>
    <span class="n">getContext</span><span class="p">().</span><span class="n">getELFSection</span><span class="p">(</span><span class="s">&quot;.sbss&quot;</span><span class="p">,</span> <span class="n">ELF</span><span class="o">::</span><span class="n">SHT_NOBITS</span><span class="p">,</span>
                               <span class="n">ELF</span><span class="o">::</span><span class="n">SHF_WRITE</span> <span class="o">|</span><span class="n">ELF</span><span class="o">::</span><span class="n">SHF_ALLOC</span><span class="p">,</span>
                               <span class="n">SectionKind</span><span class="o">::</span><span class="n">getBSS</span><span class="p">());</span>

<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetMachine.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0TargetMachine.h - Define TargetMachine for Cpu0 -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetMachine.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETMACHINE_H</span>
<span class="cp">#define CPU0TARGETMACHINE_H</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
<span class="cp">#include &quot;Cpu0SelectionDAGInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">formatted_raw_ostream</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">LLVMTargetMachine</span> <span class="p">{</span>
    <span class="n">Cpu0Subtarget</span>       <span class="n">Subtarget</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">DataLayout</span>    <span class="n">DL</span><span class="p">;</span> <span class="c1">// Calculates type size &amp; alignment</span>
    <span class="n">Cpu0InstrInfo</span>       <span class="n">InstrInfo</span><span class="p">;</span>	<span class="c1">//- Instructions</span>
    <span class="n">Cpu0FrameLowering</span>   <span class="n">FrameLowering</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0TargetLowering</span>  <span class="n">TLInfo</span><span class="p">;</span>	<span class="c1">//- Stack(Frame) and Stack direction</span>
    <span class="n">Cpu0SelectionDAGInfo</span> <span class="n">TSInfo</span><span class="p">;</span>	<span class="c1">//- Map .bc DAG to backend DAG</span>

  <span class="nl">public:</span>
    <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                      <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">);</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0InstrInfo</span>   <span class="o">*</span><span class="n">getInstrInfo</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">getFrameLowering</span><span class="p">()</span>     <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">FrameLowering</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0Subtarget</span>   <span class="o">*</span><span class="n">getSubtargetImpl</span><span class="p">()</span> <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span> <span class="p">}</span>
    <span class="k">virtual</span> <span class="k">const</span> <span class="n">DataLayout</span> <span class="o">*</span><span class="n">getDataLayout</span><span class="p">()</span>    <span class="k">const</span>
    <span class="p">{</span> <span class="k">return</span> <span class="o">&amp;</span><span class="n">DL</span><span class="p">;}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">*</span><span class="n">getRegisterInfo</span><span class="p">()</span>  <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">InstrInfo</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0TargetLowering</span> <span class="o">*</span><span class="n">getTargetLowering</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TLInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="o">*</span> <span class="n">getSelectionDAGInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="o">&amp;</span><span class="n">TSInfo</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Pass Pipeline Configuration</span>
    <span class="k">virtual</span> <span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">);</span>
  <span class="p">};</span>

<span class="c1">/// Cpu0ebTargetMachine - Cpu032 big endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0ebTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="nl">public:</span>
  <span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>

<span class="c1">/// Cpu0elTargetMachine - Cpu032 little endian target machine.</span>
<span class="c1">///</span>
<span class="k">class</span> <span class="nc">Cpu0elTargetMachine</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0TargetMachine</span> <span class="p">{</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
<span class="nl">public:</span>
  <span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                      <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                      <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                      <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/PassManager.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/Passes.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0Target</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the target.</span>
  <span class="c1">//- Big endian Target Machine</span>
  <span class="n">RegisterTargetMachine</span><span class="o">&lt;</span><span class="n">Cpu0ebTargetMachine</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="c1">//- Little endian Target Machine</span>
  <span class="n">RegisterTargetMachine</span><span class="o">&lt;</span><span class="n">Cpu0elTargetMachine</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// DataLayout --&gt; Big-endian, 32-bit pointer/ABI/alignment</span>
<span class="c1">// The stack is always 8 byte aligned</span>
<span class="c1">// On function prologue, the stack is created by decrementing</span>
<span class="c1">// its pointer. Once decremented, all references are done with positive</span>
<span class="c1">// offset from the stack/frame pointer, using StackGrowsUp enables</span>
<span class="c1">// an easier handling.</span>
<span class="c1">// Using CodeModel::Large enables different CALL behavior.</span>
<span class="n">Cpu0TargetMachine</span><span class="o">::</span>
<span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                  <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                  <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                  <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">,</span>
                  <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">)</span>
  <span class="c1">//- Default is big endian</span>
  <span class="o">:</span> <span class="n">LLVMTargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">isLittle</span><span class="p">,</span> <span class="n">RM</span><span class="p">),</span>
    <span class="n">DL</span><span class="p">(</span><span class="n">isLittle</span> <span class="o">?</span>
               <span class="p">(</span><span class="s">&quot;e-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32&quot;</span><span class="p">)</span> <span class="o">:</span>
               <span class="p">(</span><span class="s">&quot;E-p:32:32:32-i8:8:32-i16:16:32-i64:64:64-n32&quot;</span><span class="p">)),</span>
    <span class="n">InstrInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span>
    <span class="n">FrameLowering</span><span class="p">(</span><span class="n">Subtarget</span><span class="p">),</span> 
    <span class="n">TLInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">),</span> <span class="n">TSInfo</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">initAsmInfo</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0ebTargetMachine</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0ebTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0ebTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="nb">false</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0elTargetMachine</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0elTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">namespace</span> <span class="p">{</span>
<span class="c1">/// Cpu0 Code Generator Pass Configuration Options.</span>
<span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0PassConfig</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">*</span><span class="n">TM</span><span class="p">,</span> <span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetPassConfig</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">PM</span><span class="p">)</span> <span class="p">{}</span>

  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">getCpu0TargetMachine</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">getTM</span><span class="o">&lt;</span><span class="n">Cpu0TargetMachine</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">getCpu0Subtarget</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="o">*</span><span class="n">getCpu0TargetMachine</span><span class="p">().</span><span class="n">getSubtargetImpl</span><span class="p">();</span>
  <span class="p">}</span> <span class="c1">// lbd document - mark - getCpu0Subtarget()</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace</span>

<span class="n">TargetPassConfig</span> <span class="o">*</span><span class="n">Cpu0TargetMachine</span><span class="o">::</span><span class="n">createPassConfig</span><span class="p">(</span><span class="n">PassManagerBase</span> <span class="o">&amp;</span><span class="n">PM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0PassConfig</span><span class="p">(</span><span class="k">this</span><span class="p">,</span> <span class="n">PM</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - createPassConfig</span>
</pre></div>
</div>
<p class="rubric">include/llvm/Target/TargetInstInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">TargetInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCInstrInfo</span> <span class="p">{</span>
  <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
  <span class="kt">void</span> <span class="k">operator</span><span class="o">=</span><span class="p">(</span><span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="p">)</span> <span class="n">LLVM_DELETED_FUNCTION</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="k">class</span> <span class="nc">TargetInstrInfoImpl</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfo</span> <span class="p">{</span>
<span class="nl">protected:</span>
  <span class="n">TargetInstrInfoImpl</span><span class="p">(</span><span class="kt">int</span> <span class="n">CallFrameSetupOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span>
            <span class="kt">int</span> <span class="n">CallFrameDestroyOpcode</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetInstrInfo</span><span class="p">(</span><span class="n">CallFrameSetupOpcode</span><span class="p">,</span> <span class="n">CallFrameDestroyOpcode</span><span class="p">)</span> <span class="p">{}</span>
<span class="nl">public:</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">include</span> <span class="s">&quot;Cpu0CallingConv.td&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Without this will have error: &#39;cpu032I&#39; is not a recognized processor for </span>
<span class="c1">//  this target (ignoring processor)</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Subtarget features                                                    //</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">FeatureCmp</span>         <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;cmp&quot;</span><span class="p">,</span> <span class="s">&quot;HasCmp&quot;</span><span class="p">,</span> <span class="s">&quot;true&quot;</span><span class="p">,</span>
                                <span class="s">&quot;Enable &#39;cmp&#39; instructions.&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">FeatureSlt</span>         <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;slt&quot;</span><span class="p">,</span> <span class="s">&quot;HasSlt&quot;</span><span class="p">,</span> <span class="s">&quot;true&quot;</span><span class="p">,</span>
                                <span class="s">&quot;Enable &#39;slt&#39; instructions.&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">FeatureCpu032I</span>     <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;cpu032I&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0ArchVersion&quot;</span><span class="p">,</span> 
                                <span class="s">&quot;Cpu032I&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu032I ISA Support&quot;</span><span class="p">,</span>
                                <span class="p">[</span><span class="n">FeatureCmp</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">FeatureCpu032II</span>    <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;cpu032II&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0ArchVersion&quot;</span><span class="p">,</span>                      
                               <span class="s">&quot;Cpu032II&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu032II ISA Support (slt)&quot;</span><span class="p">,</span>
                                <span class="p">[</span><span class="n">FeatureCmp</span><span class="p">,</span> <span class="n">FeatureSlt</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 processors supported.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">Proc</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">Name</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">SubtargetFeature</span><span class="o">&gt;</span> <span class="n">Features</span><span class="o">&gt;</span>
 <span class="o">:</span> <span class="n">Processor</span><span class="o">&lt;</span><span class="n">Name</span><span class="p">,</span> <span class="n">Cpu0GenericItineraries</span><span class="p">,</span> <span class="n">Features</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032I&quot;</span><span class="p">,</span>  <span class="p">[</span><span class="n">FeatureCpu032I</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032II&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032II</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">// Above make Cpu0GenSubtargetInfo.inc set feature bit as the following order</span>
<span class="c1">// enum {</span>
<span class="c1">//   FeatureCmp =  1ULL &lt;&lt; 0,</span>
<span class="c1">//   FeatureCpu032I =  1ULL &lt;&lt; 1,</span>
<span class="c1">//   FeatureCpu032II =  1ULL &lt;&lt; 2,</span>
<span class="c1">//   FeatureSlt =  1ULL &lt;&lt; 3</span>
<span class="c1">// };</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0CallingConv.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0CallingConv.td - Calling Conventions for Cpu0 --*- tablegen -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// This describes the calling conventions for Cpu0 architecture.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// CCIfSubtarget - Match if the current subtarget has a feature F.</span>
<span class="k">class</span> <span class="nc">CCIfSubtarget</span><span class="o">&lt;</span><span class="n">string</span> <span class="n">F</span><span class="p">,</span> <span class="n">CCAction</span> <span class="n">A</span><span class="o">&gt;:</span>
  <span class="n">CCIf</span><span class="o">&lt;!</span><span class="n">strconcat</span><span class="p">(</span><span class="s">&quot;State.getTarget().getSubtarget&lt;Cpu0Subtarget&gt;().&quot;</span><span class="p">,</span> <span class="n">F</span><span class="p">),</span> <span class="n">A</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">CSR_O32</span> <span class="o">:</span> <span class="n">CalleeSavedRegs</span><span class="o">&lt;</span><span class="p">(</span><span class="n">add</span> <span class="n">LR</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span>
                                   <span class="p">(</span><span class="n">sequence</span> <span class="s">&quot;S%u&quot;</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0FrameLowering.h - Define frame lowering for Cpu0 ----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0_FRAMEINFO_H</span>
<span class="cp">#define CPU0_FRAMEINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">Cpu0Subtarget</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0FrameLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetFrameLowering</span> <span class="p">{</span>
<span class="nl">protected:</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="nf">Cpu0FrameLowering</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">sti</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">TargetFrameLowering</span><span class="p">(</span><span class="n">StackGrowsDown</span><span class="p">,</span> <span class="mi">8</span><span class="p">,</span> <span class="mi">0</span><span class="p">),</span>
      <span class="n">STI</span><span class="p">(</span><span class="n">sti</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span> <span class="c1">// lbd document - mark - explicit Cpu0FrameLowering</span>

  <span class="c1">/// emitProlog/emitEpilog - These methods insert prolog and epilog code into</span>
  <span class="c1">/// the function.</span>
  <span class="kt">void</span> <span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">hasFP</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>

<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0FrameLowering.cpp - Cpu0 Frame Information --------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of TargetFrameLowering class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0FrameLowering.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineModuleInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineRegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/DataLayout.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="c1">//- emitPrologue() and emitEpilogue must exist for main(). </span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Stack Frame Processing methods</span>
<span class="c1">// +----------------------------+</span>
<span class="c1">//</span>
<span class="c1">// The stack is allocated decrementing the stack pointer on</span>
<span class="c1">// the first instruction of a function prologue. Once decremented,</span>
<span class="c1">// all stack references are done thought a positive offset</span>
<span class="c1">// from the stack/frame pointer, so the stack is considering</span>
<span class="c1">// to grow up! Otherwise terrible hacks would have to be made</span>
<span class="c1">// to get this stack ABI compliant :)</span>
<span class="c1">//</span>
<span class="c1">//  The stack frame required by the ABI (after call):</span>
<span class="c1">//  Offset</span>
<span class="c1">//</span>
<span class="c1">//  0                 ----------</span>
<span class="c1">//  4                 Args to pass</span>
<span class="c1">//  .                 saved $GP  (used in PIC)</span>
<span class="c1">//  .                 Alloca allocations</span>
<span class="c1">//  .                 Local Area</span>
<span class="c1">//  .                 CPU &quot;Callee Saved&quot; Registers</span>
<span class="c1">//  .                 saved FP</span>
<span class="c1">//  .                 saved RA</span>
<span class="c1">//  .                 FPU &quot;Callee Saved&quot; Registers</span>
<span class="c1">//  StackSize         -----------</span>
<span class="c1">//</span>
<span class="c1">// Offset - offset from sp after stack allocation on function prologue</span>
<span class="c1">//</span>
<span class="c1">// The sp is the stack pointer subtracted/added from the stack size</span>
<span class="c1">// at the Prologue/Epilogue</span>
<span class="c1">//</span>
<span class="c1">// References to the previous stack (to obtain arguments) are done</span>
<span class="c1">// with offsets that exceeds the stack size: (stacksize+(4*(num_arg-1))</span>
<span class="c1">//</span>
<span class="c1">// Examples:</span>
<span class="c1">// - reference to the actual stack frame</span>
<span class="c1">//   for any local area var there is smt like : FI &gt;= 0, StackOffset: 4</span>
<span class="c1">//     st REGX, 4(SP)</span>
<span class="c1">//</span>
<span class="c1">// - reference to previous stack frame</span>
<span class="c1">//   suppose there&#39;s a load to the 5th arguments : FI &lt; 0, StackOffset: 16.</span>
<span class="c1">//   The emitted instruction will be something like:</span>
<span class="c1">//     ld REGX, 16+StackSize(SP)</span>
<span class="c1">//</span>
<span class="c1">// Since the total stack size is unknown on LowerFormalArguments, all</span>
<span class="c1">// stack references (ObjectOffset) created to reference the function</span>
<span class="c1">// arguments, are negative numbers. This way, on eliminateFrameIndex it&#39;s</span>
<span class="c1">// possible to detect those references and the offsets are adjusted to</span>
<span class="c1">// their real location.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//- Must have, hasFP() is pure virtual of parent</span>
<span class="c1">// hasFP - Return true if the specified function should have a dedicated frame</span>
<span class="c1">// pointer register.  This is true if the function has variable sized allocas or</span>
<span class="c1">// if frame pointer elimination is disabled.</span>
<span class="kt">bool</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">hasFP</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">Options</span><span class="p">.</span><span class="n">DisableFramePointerElim</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">hasVarSizedObjects</span><span class="p">()</span> <span class="o">||</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">isFrameAddressTaken</span><span class="p">();</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - hasFP</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrInfo.h - Cpu0 Instruction Information ----------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetInstrInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0INSTRUCTIONINFO_H</span>
<span class="cp">#define CPU0INSTRUCTIONINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="n">RI</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="nf">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>

  <span class="c1">/// getRegisterInfo - TargetInstrInfo is a superset of MRegister info.  As</span>
  <span class="c1">/// such, whenever a client has an instance of instruction info, it should</span>
  <span class="c1">/// always be able to get register info as well (through this method).</span>
  <span class="c1">///</span>
  <span class="k">virtual</span> <span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstrInfo.cpp - Cpu0 Instruction Information ------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetInstrInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_INSTRINFO_CTOR_DTOR</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
  <span class="o">:</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span>
    <span class="n">RI</span><span class="p">(</span><span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtargetImpl</span><span class="p">(),</span> <span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{}</span>

<span class="k">const</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">&amp;</span><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">getRegisterInfo</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">RI</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - getRegisterInfo()</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Instruction Predicate Definitions.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="n">def</span> <span class="n">HasCmp</span>      <span class="o">:</span>     <span class="n">Predicate</span><span class="o">&lt;</span><span class="s">&quot;Subtarget.hasCmp()&quot;</span><span class="o">&gt;</span><span class="p">,</span>
                      <span class="n">AssemblerPredicate</span><span class="o">&lt;</span><span class="s">&quot;FeatureCmp&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">HasSlt</span>      <span class="o">:</span>     <span class="n">Predicate</span><span class="o">&lt;</span><span class="s">&quot;Subtarget.hasSlt()&quot;</span><span class="o">&gt;</span><span class="p">,</span>
                      <span class="n">AssemblerPredicate</span><span class="o">&lt;</span><span class="s">&quot;FeatureSlt&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IsCpu032I</span>   <span class="o">:</span>     <span class="n">Predicate</span><span class="o">&lt;</span><span class="s">&quot;Subtarget.hasCpu032I()&quot;</span><span class="o">&gt;</span><span class="p">,</span>
                      <span class="n">AssemblerPredicate</span><span class="o">&lt;</span><span class="s">&quot;FeatureCpu032I&quot;</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="n">IsCpu032II</span>  <span class="o">:</span>     <span class="n">Predicate</span><span class="o">&lt;</span><span class="s">&quot;Subtarget.hasCpu032II()&quot;</span><span class="o">&gt;</span><span class="p">,</span>
                      <span class="n">AssemblerPredicate</span><span class="o">&lt;</span><span class="s">&quot;FeatureCpu032II&quot;</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0ISelLowering.h - Cpu0 DAG Lowering Interface --------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines the interfaces that Cpu0 uses to lower LLVM code into a</span>
<span class="c1">// selection DAG.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef Cpu0ISELLOWERING_H</span>
<span class="cp">#define Cpu0ISELLOWERING_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/SelectionDAG.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetLowering.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">namespace</span> <span class="n">Cpu0ISD</span> <span class="p">{</span>
    <span class="k">enum</span> <span class="n">NodeType</span> <span class="p">{</span>
      <span class="c1">// Start the numbering from where ISD NodeType finishes.</span>
      <span class="n">FIRST_NUMBER</span> <span class="o">=</span> <span class="n">ISD</span><span class="o">::</span><span class="n">BUILTIN_OP_END</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="c1">// Return</span>
      <span class="n">Ret</span><span class="p">,</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="p">};</span>
  <span class="p">}</span>

  <span class="c1">//===--------------------------------------------------------------------===//</span>
  <span class="c1">// TargetLowering Implementation</span>
  <span class="c1">//===--------------------------------------------------------------------===//</span>

  <span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">explicit</span> <span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="nl">private:</span>
    <span class="c1">// Subtarget Info</span>
    <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">*</span><span class="n">Subtarget</span><span class="p">;</span>
    
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>	<span class="c1">//- must be exist without function all</span>
    <span class="k">virtual</span> <span class="n">SDValue</span>
      <span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                           <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                           <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                           <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                           <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>	<span class="c1">//- must be exist without function all</span>
    <span class="k">virtual</span> <span class="n">SDValue</span>
      <span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                  <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                  <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">// Inline asm support</span>
    <span class="n">ConstraintType</span> <span class="n">getConstraintType</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">/// Examine constraint string and operand type and determine a weight value.</span>
    <span class="c1">/// The operand object must already have been set up with the operand type.</span>
    <span class="n">ConstraintWeight</span> <span class="n">getSingleConstraintMatchWeight</span><span class="p">(</span>
      <span class="n">AsmOperandInfo</span> <span class="o">&amp;</span><span class="n">info</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">constraint</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">/// This function parses registers that appear in inline-asm constraints.</span>
    <span class="c1">/// It returns pair (0, 0) on failure.</span>
    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*&gt;</span>
    <span class="n">parseRegForInlineAsmConstraint</span><span class="p">(</span><span class="k">const</span> <span class="n">StringRef</span> <span class="o">&amp;</span><span class="n">C</span><span class="p">,</span> <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span><span class="o">*&gt;</span>
              <span class="n">getRegForInlineAsmConstraint</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">,</span>
                                           <span class="n">MVT</span> <span class="n">VT</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="c1">/// LowerAsmOperandForConstraint - Lower the specified operand into the Ops</span>
    <span class="c1">/// vector.  If it is invalid, don&#39;t add anything to Ops. If hasMemory is</span>
    <span class="c1">/// true it means one of the asm constraint of the inline asm instruction</span>
    <span class="c1">/// being processed is &#39;m&#39;.</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">LowerAsmOperandForConstraint</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span>
                                              <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">Constraint</span><span class="p">,</span>
                                              <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">,</span>
                                              <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

    <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">isLegalAddressingMode</span><span class="p">(</span><span class="k">const</span> <span class="n">AddrMode</span> <span class="o">&amp;</span><span class="n">AM</span><span class="p">,</span> <span class="n">Type</span> <span class="o">*</span><span class="n">Ty</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif </span><span class="c1">// Cpu0ISELLOWERING_H</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0ISelLowering.cpp - Cpu0 DAG Lowering Implementation -----------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines the interfaces that Cpu0 uses to lower LLVM code into a</span>
<span class="c1">// selection DAG.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-lower&quot;</span>
<span class="cp">#include &quot;Cpu0ISelLowering.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetObjectFile.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/IR/DerivedTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/GlobalVariable.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Intrinsics.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/CallingConv.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/CallingConvLower.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineRegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/SelectionDAGISel.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/ValueTypes.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// lbd document - mark - Cpu0TargetLowering(Cpu0TargetMachine &amp;TM) - begin</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="cp">#include &quot;Cpu0GenCallingConv.inc&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//               Return Value Calling Convention Implementation</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                                <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MachineFunctionInfo.h - Private data used for Cpu0 ----*- C++ -*-=//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of MachineFunctionInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0_MACHINE_FUNCTION_INFO_H</span>
<span class="cp">#define CPU0_MACHINE_FUNCTION_INFO_H</span>

<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &lt;utility&gt;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="c1">/// Cpu0FunctionInfo - This class is derived from MachineFunction private</span>
<span class="c1">/// Cpu0 target-specific information for each MachineFunction.</span>
<span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">MaxCallFrameSize</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="nl">public:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">MF</span><span class="p">(</span><span class="n">MF</span><span class="p">),</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">MaxCallFrameSize</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">{}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">getMaxCallFrameSize</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">MaxCallFrameSize</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setMaxCallFrameSize</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span> <span class="n">MaxCallFrameSize</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>

<span class="p">}</span> <span class="c1">// end of namespace llvm</span>

<span class="cp">#endif </span><span class="c1">// CPU0_MACHINE_FUNCTION_INFO_H</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0SelectionDAGInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0SelectionDAGInfo.h - Cpu0 SelectionDAG Info ---------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines the Cpu0 subclass for TargetSelectionDAGInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0SELECTIONDAGINFO_H</span>
<span class="cp">#define CPU0SELECTIONDAGINFO_H</span>

<span class="cp">#include &quot;llvm/Target/TargetSelectionDAGInfo.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="k">class</span> <span class="nc">Cpu0TargetMachine</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0SelectionDAGInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetSelectionDAGInfo</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="n">Cpu0SelectionDAGInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
  <span class="o">~</span><span class="n">Cpu0SelectionDAGInfo</span><span class="p">();</span>
<span class="p">};</span>

<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0SelectionDAGInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0SelectionDAGInfo.cpp - Cpu0 SelectionDAG Info -----------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file implements the Cpu0SelectionDAGInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-selectiondag-info&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0SelectionDAGInfo</span><span class="o">::</span><span class="n">Cpu0SelectionDAGInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetSelectionDAGInfo</span><span class="p">(</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span>
<span class="p">}</span>

<span class="n">Cpu0SelectionDAGInfo</span><span class="o">::~</span><span class="n">Cpu0SelectionDAGInfo</span><span class="p">()</span> <span class="p">{</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0Subtarget.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0Subtarget.h - Define Subtarget for the Cpu0 ---------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file declares the Cpu0 specific subclass of TargetSubtargetInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0SUBTARGET_H</span>
<span class="cp">#define CPU0SUBTARGET_H</span>

<span class="cp">#include &quot;llvm/Target/TargetSubtargetInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInstrItineraries.h&quot;</span>
<span class="cp">#include &lt;string&gt;</span>

<span class="cp">#define GET_SUBTARGETINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenSubtargetInfo.inc&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="nl">public:</span>
  <span class="kt">unsigned</span> <span class="n">getTargetABI</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ABI</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">/// This constructor initializes the data members to match that</span>
  <span class="c1">/// of the specified triple.</span>
  <span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">CPU</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">little</span><span class="p">,</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">_RM</span><span class="p">);</span>

<span class="c1">//- Vitual function, must have</span>
  <span class="c1">/// ParseSubtargetFeatures - Parses features string setting specified</span>
  <span class="c1">/// subtarget options.  Definition of function is auto generated by tblgen.</span>
  <span class="kt">void</span> <span class="nf">ParseSubtargetFeatures</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">IsLittle</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">hasCpu032I</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ArchVersion</span> <span class="o">&gt;=</span> <span class="n">Cpu032I</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isCpu032I</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ArchVersion</span> <span class="o">==</span> <span class="n">Cpu032I</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">hasCpu032II</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ArchVersion</span> <span class="o">&gt;=</span> <span class="n">Cpu032II</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isCpu032II</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ArchVersion</span> <span class="o">==</span> <span class="n">Cpu032II</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">/// Features related to the presence of specific instructions.</span>
  <span class="kt">bool</span> <span class="n">hasCmp</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">HasCmp</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">hasSlt</span><span class="p">()</span>   <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">HasSlt</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0Subtarget.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0Subtarget.cpp - Cpu0 Subtarget Information --------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file implements the Cpu0 specific subclass of TargetSubtargetInfo.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_SUBTARGETINFO_TARGET_DESC</span>
<span class="cp">#define GET_SUBTARGETINFO_CTOR</span>
<span class="cp">#include &quot;Cpu0GenSubtargetInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">CPU</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">little</span><span class="p">,</span> 
                             <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">_RM</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">Cpu0GenSubtargetInfo</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span>
  <span class="n">Cpu0ABI</span><span class="p">(</span><span class="n">UnknownABI</span><span class="p">),</span> <span class="n">IsLittle</span><span class="p">(</span><span class="n">little</span><span class="p">),</span> <span class="n">RM</span><span class="p">(</span><span class="n">_RM</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">CPUName</span> <span class="o">=</span> <span class="n">CPU</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CPUName</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">CPUName</span> <span class="o">=</span> <span class="s">&quot;cpu032II&quot;</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CPUName</span> <span class="o">==</span> <span class="s">&quot;cpu032I&quot;</span><span class="p">)</span>
    <span class="n">Cpu0ArchVersion</span> <span class="o">=</span> <span class="n">Cpu032I</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CPUName</span> <span class="o">==</span> <span class="s">&quot;cpu032II&quot;</span><span class="p">)</span>
    <span class="n">Cpu0ArchVersion</span> <span class="o">=</span> <span class="n">Cpu032II</span><span class="p">;</span>

  <span class="c1">// Parse features string.</span>
  <span class="n">ParseSubtargetFeatures</span><span class="p">(</span><span class="n">CPUName</span><span class="p">,</span> <span class="n">FS</span><span class="p">);</span>

  <span class="c1">// Initialize scheduling itinerary for the specified CPU.</span>
  <span class="n">InstrItins</span> <span class="o">=</span> <span class="n">getInstrItineraryForCPU</span><span class="p">(</span><span class="n">CPUName</span><span class="p">);</span>

  <span class="c1">// Set Cpu0ABI if it hasn&#39;t been set yet.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0ABI</span> <span class="o">==</span> <span class="n">UnknownABI</span><span class="p">)</span>
    <span class="n">Cpu0ABI</span> <span class="o">=</span> <span class="n">O32</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0RegisterInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0RegisterInfo.h - Cpu0 Register Information Impl -----*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the Cpu0 implementation of the TargetRegisterInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0REGISTERINFO_H</span>
<span class="cp">#define CPU0REGISTERINFO_H</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetRegisterInfo.h&quot;</span>

<span class="cp">#define GET_REGINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0Subtarget</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">TargetInstrInfo</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Type</span><span class="p">;</span>

<span class="k">struct</span> <span class="n">Cpu0RegisterInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenRegisterInfo</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span><span class="p">;</span>

  <span class="n">Cpu0RegisterInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">tii</span><span class="p">);</span>

  <span class="c1">/// getRegisterNumbering - Given the enum value for some register, e.g.</span>
  <span class="c1">/// Cpu0::RA, return the number that it corresponds to (e.g. 31).</span>
  <span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">getRegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">);</span>

  <span class="c1">/// Code Generation virtual methods...</span>
  <span class="k">const</span> <span class="kt">uint16_t</span> <span class="o">*</span><span class="n">getCalleeSavedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span><span class="o">*</span> <span class="n">MF</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="n">BitVector</span> <span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="c1">/// Stack Frame Processing Methods</span>
  <span class="kt">void</span> <span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span>
                           <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span>
                           <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span> <span class="o">=</span> <span class="nb">NULL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="c1">// pure virtual method</span>
  <span class="c1">/// Debug information queries.</span>
  <span class="kt">unsigned</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>

<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_1/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0RegisterInfo.cpp - CPU0 Register Information -== --------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the CPU0 implementation of the TargetRegisterInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-reg-info&quot;</span>

<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Constants.h&quot;</span>
<span class="cp">#include &quot;llvm/DebugInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Type.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Function.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/ValueTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetFrameLowering.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Debug.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/BitVector.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/STLExtras.h&quot;</span>

<span class="cp">#define GET_REGINFO_TARGET_DESC</span>
<span class="cp">#include &quot;Cpu0GenRegisterInfo.inc&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">Cpu0RegisterInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">ST</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">&amp;</span><span class="n">tii</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0GenRegisterInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">),</span> <span class="n">Subtarget</span><span class="p">(</span><span class="n">ST</span><span class="p">),</span> <span class="n">TII</span><span class="p">(</span><span class="n">tii</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Callee Saved Registers methods</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">/// Cpu0 Callee Saved Registers</span>
<span class="c1">// In Cpu0CallConv.td,</span>
<span class="c1">// def CSR_O32 : CalleeSavedRegs&lt;(add LR, FP,</span>
<span class="c1">//                                   (sequence &quot;S%u&quot;, 2, 0))&gt;;</span>
<span class="c1">// llc create CSR_O32_SaveList and CSR_O32_RegMask from above defined.</span>
<span class="k">const</span> <span class="kt">uint16_t</span><span class="o">*</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getCalleeSavedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">*</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">CSR_O32_SaveList</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">const</span> <span class="kt">uint32_t</span><span class="o">*</span>
<span class="n">Cpu0RegisterInfo</span><span class="o">::</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">CSR_O32_RegMask</span><span class="p">;</span> 
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">ReservedCPURegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
    <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">PC</span>
  <span class="p">};</span>
  <span class="n">BitVector</span> <span class="nf">Reserved</span><span class="p">(</span><span class="n">getNumRegs</span><span class="p">());</span>
  <span class="k">typedef</span> <span class="n">TargetRegisterClass</span><span class="o">::</span><span class="n">iterator</span> <span class="n">RegIter</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">I</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">I</span> <span class="o">&lt;</span> <span class="n">array_lengthof</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">);</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">ReservedCPURegs</span><span class="p">[</span><span class="n">I</span><span class="p">]);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">return</span> <span class="n">Reserved</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - getReservedRegs</span>

<span class="c1">//- If no eliminateFrameIndex(), it will hang on run. </span>
<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="c1">// pure virtual method</span>
<span class="kt">unsigned</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getFrameRegister</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">TFI</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">)</span> <span class="o">?</span> <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span> <span class="o">:</span>
                          <span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>

<span class="cp">#define GET_INSTRINFO_HEADER</span>
<span class="cp">#include &quot;Cpu0GenInstrInfo.inc&quot;</span>
<span class="c1">//- Cpu0InstInfo.h</span>
<span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="k">explicit</span> <span class="nf">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
<span class="p">};</span>
</pre></div>
</div>
<div class="figure align-center" id="backendstructure-f1">
<img alt="_images/11.png" src="_images/11.png" />
<p class="caption">Figure 1: TargetMachine class diagram 1</p>
</div>
<p>The Cpu0TargetMachine inherit tree is TargetMachine &lt;- LLVMTargetMachine &lt;-
Cpu0TargetMachine.
Cpu0TargetMachine has class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering,
Cpu0TargetLowering and Cpu0SelectionDAGInfo.
Class Cpu0Subtarget, Cpu0InstrInfo, Cpu0FrameLowering, Cpu0TargetLowering and
Cpu0SelectionDAGInfo are inherited from base class TargetSubtargetInfo,
TargetInstrInfo, TargetFrameLowering, TargetLowering and TargetSelectionDAGInfo.</p>
<p><a class="pageref" href="#backendstructure-f1">Figure  1</a> shows Cpu0TargetMachine inherit tree and it&#8217;s
Cpu0InstrInfo class inherit tree.
Cpu0TargetMachine contains Cpu0InstrInfo and ... other class.
Cpu0InstrInfo contains Cpu0RegisterInfo class, RI.
With TableGen tool, Cpu0InstrInfo.td and Cpu0RegisterInfo.td will generate
Cpu0GenInstrInfo.inc and Cpu0GenRegisterInfo.inc which contain some member
functions implementation for class Cpu0InstrInfo and Cpu0RegisterInfo.</p>
<p><a class="pageref" href="#backendstructure-f2">Figure  2</a> as below shows Cpu0TargetMachine contains
class
TSInfo: Cpu0SelectionDAGInfo, FrameLowering: Cpu0FrameLowering, Subtarget:
Cpu0Subtarget and TLInfo: Cpu0TargetLowering.</p>
<div class="figure align-center" id="backendstructure-f2">
<img alt="_images/2.png" src="_images/2.png" />
<p class="caption">Figure 2: TargetMachine class diagram 2</p>
</div>
<div class="figure align-center" id="backendstructure-f3">
<img alt="_images/3.png" src="_images/3.png" />
<p class="caption">Figure 3: TargetMachine members and operators</p>
</div>
<p><a class="pageref" href="#backendstructure-f3">Figure  3</a> shows some members and operators (member function)
of the parent class TargetMachine&#8217;s.
<a class="pageref" href="#backendstructure-f4">Figure  4</a> as below shows some members of class InstrInfo,
RegisterInfo and TargetLowering.
Class DAGInfo is skipped here.</p>
<div class="figure align-center" id="backendstructure-f4">
<img alt="_images/4.png" src="_images/4.png" />
<p class="caption">Figure 4: Other class members and operators</p>
</div>
<p>Benefit from the inherit tree structure, we just need to implement few code in
instruction, frame/stack, select DAG class.
Many code implemented by their parent class.
The llvm-tblgen generate Cpu0GenInstrInfo.inc from Cpu0InstrInfo.td.
Cpu0InstrInfo.h extract those code it need from Cpu0GenInstrInfo.inc by define
“#define GET_INSTRINFO_HEADER”.
Following is the code fragment from Cpu0GenInstrInfo.inc.
Code between “#if def  GET_INSTRINFO_HEADER” and “#endif // GET_INSTRINFO_HEADER”
will be extracted by Cpu0InstrInfo.h.</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenInstInfo.inc</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- Cpu0GenInstInfo.inc which generate from Cpu0InstrInfo.td</span>
<span class="cp">#ifdef GET_INSTRINFO_HEADER</span>
<span class="cp">#undef GET_INSTRINFO_HEADER</span>
<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">struct</span> <span class="n">Cpu0GenInstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetInstrInfoImpl</span> <span class="p">{</span>
  <span class="k">explicit</span> <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="kt">int</span> <span class="n">SO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">DO</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span> <span class="c1">// End llvm namespace</span>
<span class="cp">#endif </span><span class="c1">// GET_INSTRINFO_HEADER</span>
</pre></div>
</div>
<p>Reference Write An LLVM Backend web site <a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
<p>Now, the code in Chapter3_1/ add class Cpu0TargetMachine(Cpu0TargetMachine.h and
cpp), Cpu0Subtarget (Cpu0Subtarget.h and .cpp), Cpu0InstrInfo (Cpu0InstrInfo.h
and .cpp), Cpu0FrameLowering (Cpu0FrameLowering.h and .cpp), Cpu0TargetLowering
(Cpu0ISelLowering.h and .cpp) and Cpu0SelectionDAGInfo ( Cpu0SelectionDAGInfo.h
and .cpp).
CMakeLists.txt  modified with those new added *.cpp as follows,</p>
<p class="rubric">lbdex/Chapter3_1/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenDisassemblerTables</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">disassembler</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenMCCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span> <span class="o">-</span><span class="n">mc</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>

<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmWriter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="k">asm</span><span class="o">-</span><span class="n">writer</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenDAGISel</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">dag</span><span class="o">-</span><span class="n">isel</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenCallingConv</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">callingconv</span><span class="p">)</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0InstrInfo</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0ISelLowering</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0FrameLowering</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0RegisterInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0Subtarget</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0TargetObjectFile</span><span class="p">.</span><span class="n">cpp</span>
  <span class="n">Cpu0SelectionDAGInfo</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>Please take a look for Chapter3_1 code.
After that, building Chapter3_1 by make as chapter 2 (of course, you should
remove old files and sub-directories from src/lib/Target/Cpu0 and replace them
with src/lib/Target/Cpu0/lbdex/Chapter3_1/*).
You can remove cmake_debug_build/lib/Target/Cpu0/*.inc before do “make” to ensure your code
rebuild completely.
With removing *.inc, all files those have included .inc will be re-built, then your
Target library will be regenerated.
Command as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:cmake_debug_build Jonathan<span class="nv">$ </span>rm -rf lib/Target/Cpu0/*
</pre></div>
</div>
<p>Now, let&#8217;s build Chapter3_1 as the following commands,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-75-57:ExampleCode Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/llvm/test/src/lib/Target/Cpu0/lbdex
118-165-75-57:lbdex Jonathan<span class="nv">$ </span>sh removecpu0.sh
118-165-75-57:lbdex Jonathan<span class="nv">$ </span>cp -rf Chapter3_1/
* ../.

118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
... Assertion <span class="sb">`</span>AsmInfo <span class="o">&amp;&amp;</span> <span class="s2">&quot;MCAsmInfo not initialized. &quot;</span>
...
</pre></div>
</div>
<p>With Chapter3_1 implementation, the Chapter2 error message
&#8220;Could not allocate target machine!&#8221; has gone.
The new errors say that we have not Target AsmPrinter.
We will add it in next section.</p>
<p>Chapter3_1 create cpu032I and cpu032II two CPU and define two features with the
same name of CPU. With the added code of cpu032I and cpu32II in Cpu0.td and
Cpu0InstrInfo.td of Chapter3_1, the command <cite>llc -march=cpu0 -mcpu=help</cite> can
display message as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span><span class="nb">help</span>
Available CPUs <span class="k">for </span>this target:

  cpu032I  - Select the cpu032I processor.
  cpu032II - Select the cpu032II processor.

Available features <span class="k">for </span>this target:

  cmp      - Enable <span class="s1">&#39;cmp&#39;</span> instructions..
  cpu032I  - Cpu032I ISA Support.
  cpu032II - Cpu032II ISA Support <span class="o">(</span>slt<span class="o">)</span>.
  slt      - Enable <span class="s1">&#39;slt&#39;</span> instructions..

Use +feature to <span class="nb">enable </span>a feature, or -feature to disable it.
For example, llc -mcpu<span class="o">=</span>mycpu -mattr<span class="o">=</span>+feature1,-feature2
</pre></div>
</div>
<p>When user input -mcpu=cpu032I, the IsCpu032I of Cpu0InstrInfo.td is true since
function isCpu032I() defined in Cpu0Subtarget.h is true by check CPU variable
in constructor function.
Please notify the Cpu0ArchVersion must be initialized as Cpu0Subtarget.cpp,
otherwise the Cpu0ArchVersion can be any value and the functions
isCpu032I() and isCpu032II() which support <cite>llc -mcpu=cpu032I</cite> and
<cite>llc -mcpu=cpu032II</cite> will have trouble.</p>
</div>
<div class="section" id="add-asmprinter">
<h2>Add AsmPrinter<a class="headerlink" href="#add-asmprinter" title="Permalink to this headline">¶</a></h2>
<p>Chapter3_2/ contains the Cpu0AsmPrinter definition. First, we add definitions in
Cpu0.td to support AssemblyWriter.
Cpu0.td is added with the following fragment,</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">Cpu0AsmWriter</span> <span class="o">:</span> <span class="n">AsmWriter</span> <span class="p">{</span>
  <span class="n">string</span> <span class="n">AsmWriterClassName</span>  <span class="o">=</span> <span class="s">&quot;InstPrinter&quot;</span><span class="p">;</span>
  <span class="n">bit</span> <span class="n">isMCAsmWriter</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Will generate Cpu0GenAsmWrite.inc included by Cpu0InstPrinter.cpp, contents </span>
<span class="c1">//  as follows,</span>
<span class="c1">// void Cpu0InstPrinter::printInstruction(const MCInst *MI, raw_ostream &amp;O) {...}</span>
<span class="c1">// const char *Cpu0InstPrinter::getRegisterName(unsigned RegNo) {...}</span>
<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">let</span> <span class="n">AssemblyWriters</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmWriter</span><span class="p">];</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>
</pre></div>
</div>
<p>As comments indicate, it will generate Cpu0GenAsmWrite.inc which is included
by Cpu0InstPrinter.cpp as follows,</p>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/Cpu0InstPrinter.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//=== Cpu0InstPrinter.h - Convert Cpu0 MCInst to assembly syntax -*- C++ -*-==//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This class prints a Cpu0 MCInst to a .s file.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0INSTPRINTER_H</span>
<span class="cp">#define CPU0INSTPRINTER_H</span>
<span class="cp">#include &quot;llvm/MC/MCInstPrinter.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="c1">// These enumeration declarations were orignally in Cpu0InstrInfo.h but</span>
<span class="c1">// had to be moved here to avoid circular dependencies between</span>
<span class="c1">// LLVMCpu0CodeGen and LLVMCpu0AsmPrinter.</span>

<span class="k">class</span> <span class="nc">TargetMachine</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">Cpu0InstPrinter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCInstPrinter</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                  <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">MCInstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">)</span> <span class="p">{}</span>

  <span class="c1">// Autogenerated by tblgen.</span>
  <span class="kt">void</span> <span class="n">printInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="k">static</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="nf">getRegisterName</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">);</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">printRegName</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">);</span>

<span class="nl">private:</span>
  <span class="kt">void</span> <span class="nf">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">printUnsignedImm</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">printMemOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>
<span class="p">}</span> <span class="c1">// end namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0InstPrinter.cpp - Convert Cpu0 MCInst to assembly syntax ------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This class prints an Cpu0 MCInst to a .s file.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;asm-printer&quot;</span>
<span class="cp">#include &quot;Cpu0InstPrinter.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringExtras.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="cp">#include &quot;Cpu0GenAsmWriter.inc&quot;</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printRegName</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RegNo</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="c1">//- getRegisterName(RegNo) defined in Cpu0GenAsmWriter.inc which came from </span>
<span class="c1">//   Cpu0.td indicate.</span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">RegNo</span><span class="p">)).</span><span class="n">lower</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printInst</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">,</span>
                                <span class="n">StringRef</span> <span class="n">Annot</span><span class="p">)</span> <span class="p">{</span>
<span class="c1">//- printInstruction(MI, O) defined in Cpu0GenAsmWriter.inc which came from </span>
<span class="c1">//   Cpu0.td indicate.</span>
  <span class="n">printInstruction</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">printAnnotation</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">Annot</span><span class="p">);</span>
<span class="p">}</span>

<span class="k">static</span> <span class="kt">void</span> <span class="n">printExpr</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">SRE</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCBinaryExpr</span> <span class="o">*</span><span class="n">BE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCBinaryExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SRE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BE</span><span class="o">-&gt;</span><span class="n">getLHS</span><span class="p">());</span>
    <span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">CE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">BE</span><span class="o">-&gt;</span><span class="n">getRHS</span><span class="p">());</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">SRE</span> <span class="o">&amp;&amp;</span> <span class="n">CE</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Binary expression must be sym+const.&quot;</span><span class="p">);</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">CE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">SRE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)))</span>
    <span class="n">assert</span><span class="p">(</span><span class="nb">false</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Unexpected MCExpr type.&quot;</span><span class="p">);</span>

  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Kind</span> <span class="o">=</span> <span class="n">SRE</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span>                                 <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Invalid kind!&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span>:<span class="o">:</span><span class="n">VK_None</span><span class="o">:</span>           <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">}</span>

  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">SRE</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Offset</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;+&#39;</span><span class="p">;</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_HI</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_LO</span><span class="p">))</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)))&quot;</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Kind</span> <span class="o">!=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_None</span><span class="p">)</span>
    <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;)&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                                   <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">Op</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNo</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">isReg</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">printRegName</span><span class="p">(</span><span class="n">O</span><span class="p">,</span> <span class="n">Op</span><span class="p">.</span><span class="n">getReg</span><span class="p">());</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">isImm</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">Op</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">assert</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">isExpr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;unknown operand kind in printOperand&quot;</span><span class="p">);</span>
  <span class="n">printExpr</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getExpr</span><span class="p">(),</span> <span class="n">O</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">printUnsignedImm</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span>
                                       <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">opNum</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImm</span><span class="p">())</span>
    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="kt">short</span> <span class="kt">int</span><span class="p">)</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="k">else</span>
    <span class="nf">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span>
<span class="n">printMemOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Load/Store memory operands -- imm($reg)</span>
  <span class="c1">// If PIC target the target is loaded as the</span>
  <span class="c1">// pattern ld $t9,%call16($gp)</span>
  <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="o">+</span><span class="mi">1</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;(&quot;</span><span class="p">;</span>
  <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/CMakeLists.txt</p>
<div class="highlight-c++"><pre>include_directories( ${CMAKE_CURRENT_BINARY_DIR}/.. ${CMAKE_CURRENT_SOURCE_DIR}/.. )

add_llvm_library(LLVMCpu0AsmPrinter
  Cpu0InstPrinter.cpp
  )

add_dependencies(LLVMCpu0AsmPrinter Cpu0CommonTableGen)
</pre>
</div>
<p class="rubric">lbdex/Chapter3_2/InstPrinter/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">;</span><span class="o">===-</span> <span class="p">.</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">Target</span><span class="o">/</span><span class="n">Cpu0</span><span class="o">/</span><span class="n">InstPrinter</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="p">.</span><span class="n">txt</span> <span class="o">--------------*-</span> <span class="n">Conf</span> <span class="o">-*--===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">file</span> <span class="n">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="p">;</span> <span class="n">License</span><span class="p">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="p">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="p">.</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">is</span> <span class="n">an</span> <span class="n">LLVMBuild</span> <span class="n">description</span> <span class="n">file</span> <span class="k">for</span> <span class="n">the</span> <span class="n">components</span> <span class="n">in</span> <span class="k">this</span> <span class="n">subdirectory</span><span class="p">.</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">on</span> <span class="n">the</span> <span class="n">LLVMBuild</span> <span class="n">system</span><span class="p">,</span> <span class="n">please</span> <span class="n">see</span><span class="o">:</span>
<span class="p">;</span>
<span class="p">;</span>   <span class="n">http</span><span class="o">:</span><span class="c1">//llvm.org/docs/LLVMBuild.html</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="n">type</span> <span class="o">=</span> <span class="n">Library</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">Cpu0AsmPrinter</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">Cpu0</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">MC</span> <span class="n">Support</span>
<span class="n">add_to_library_groups</span> <span class="o">=</span> <span class="n">Cpu0</span>
</pre></div>
</div>
<p>Cpu0GenAsmWrite.inc has the implementation of
Cpu0InstPrinter::printInstruction() and Cpu0InstPrinter::getRegisterName().
Both of these functions can be auto-generated from the information we defined
in Cpu0InstrInfo.td and Cpu0RegisterInfo.td.
To let these two functions work in our code, the only thing needed is adding a
class Cpu0InstPrinter and include them as did in Chapter3_1.</p>
<p>File Chapter3_1/Cpu0/InstPrinter/Cpu0InstPrinter.cpp include Cpu0GenAsmWrite.inc and
call the auto-generated functions from TableGen.</p>
<p>Next, add Cpu0MCInstLower (Cpu0MCInstLower.h, Cpu0MCInstLower.cpp), as well as
Cpu0BaseInfo.h,
Cpu0FixupKinds.h and Cpu0MCAsmInfo (Cpu0MCAsmInfo.h, Cpu0MCAsmInfo.cpp) in
sub-directory MCTargetDesc as follows,</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0MCInstLower.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCInstLower.h - Lower MachineInstr to MCInst -------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0MCINSTLOWER_H</span>
<span class="cp">#define CPU0MCINSTLOWER_H</span>
<span class="cp">#include &quot;llvm/ADT/SmallVector.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Compiler.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">MCContext</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MCInst</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MCOperand</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachineInstr</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">MachineFunction</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Cpu0AsmPrinter</span><span class="p">;</span>

<span class="c1">/// Cpu0MCInstLower - This class is used to lower an MachineInstr into an</span>
<span class="c1">//                    MCInst.</span>
<span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="n">Cpu0MCInstLower</span> <span class="p">{</span>
  <span class="k">typedef</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MachineOperandType</span> <span class="n">MachineOperandType</span><span class="p">;</span>
  <span class="n">MCContext</span> <span class="o">*</span><span class="n">Ctx</span><span class="p">;</span>
  <span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">AsmPrinter</span><span class="p">;</span>
<span class="nl">public:</span>
  <span class="n">Cpu0MCInstLower</span><span class="p">(</span><span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">asmprinter</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">Initialize</span><span class="p">(</span><span class="n">MCContext</span><span class="o">*</span> <span class="n">C</span><span class="p">);</span>
  <span class="kt">void</span> <span class="n">Lower</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="nl">private:</span>
  <span class="n">MCOperand</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                               <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="n">MCOperand</span> <span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCInstLower.cpp - Convert Cpu0 MachineInstr to MCInst ---------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains code to lower Cpu0 MachineInstrs to their corresponding</span>
<span class="c1">// MCInst records.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MCInstLower.h&quot;</span>
<span class="cp">#include &quot;Cpu0AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstr.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/Mangler.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Cpu0MCInstLower</span><span class="p">(</span><span class="n">Cpu0AsmPrinter</span> <span class="o">&amp;</span><span class="n">asmprinter</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">AsmPrinter</span><span class="p">(</span><span class="n">asmprinter</span><span class="p">)</span> <span class="p">{}</span>

<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Initialize</span><span class="p">(</span><span class="n">MCContext</span><span class="o">*</span> <span class="n">C</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Ctx</span> <span class="o">=</span> <span class="n">C</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - Initialize</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineOperandType</span> <span class="n">MOTy</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">();</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unknown operand type&quot;</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_Register</span><span class="o">:</span>
    <span class="c1">// Ignore all implicit register operands.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImplicit</span><span class="p">())</span> <span class="k">break</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">());</span>
  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_Immediate</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">+</span> <span class="n">offset</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_RegisterMask</span><span class="o">:</span>
    <span class="k">break</span><span class="p">;</span>
 <span class="p">}</span>

  <span class="k">return</span> <span class="n">MCOperand</span><span class="p">();</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">Lower</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">OutMI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">OutMI</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">());</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">);</span>
    <span class="n">MCOperand</span> <span class="n">MCOp</span> <span class="o">=</span> <span class="n">LowerOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">MCOp</span><span class="p">.</span><span class="n">isValid</span><span class="p">())</span>
      <span class="n">OutMI</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOp</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0BaseInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0BaseInfo.h - Top level definitions for CPU0 MC ------*- C++ -*-===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains small standalone helper functions and enum definitions for</span>
<span class="c1">// the Cpu0 target useful for the compiler back-end and the MC libraries.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0BASEINFO_H</span>
<span class="cp">#define CPU0BASEINFO_H</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/DataTypes.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/ErrorHandling.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

<span class="c1">/// Cpu0II - This namespace holds all of the target specific flags that</span>
<span class="c1">/// instruction info tracks.</span>
<span class="c1">///</span>
<span class="k">namespace</span> <span class="n">Cpu0II</span> <span class="p">{</span>
  <span class="c1">/// Target Operand Flag enum.</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">enum</span> <span class="p">{</span>
    <span class="c1">//===------------------------------------------------------------------===//</span>
    <span class="c1">// Instruction encodings.  These are the standard/most common forms for</span>
    <span class="c1">// Cpu0 instructions.</span>
    <span class="c1">//</span>

    <span class="c1">// Pseudo - This represents an instruction that is a pseudo instruction</span>
    <span class="c1">// or one that has not been implemented yet.  It is illegal to code generate</span>
    <span class="c1">// it, but tolerated for intermediate implementation stages.</span>
    <span class="n">Pseudo</span>   <span class="o">=</span> <span class="mi">0</span><span class="p">,</span>

    <span class="c1">/// FrmR - This form is for instructions of the format R.</span>
    <span class="n">FrmR</span>  <span class="o">=</span> <span class="mi">1</span><span class="p">,</span>
    <span class="c1">/// FrmI - This form is for instructions of the format I.</span>
    <span class="n">FrmI</span>  <span class="o">=</span> <span class="mi">2</span><span class="p">,</span>
    <span class="c1">/// FrmJ - This form is for instructions of the format J.</span>
    <span class="n">FrmJ</span>  <span class="o">=</span> <span class="mi">3</span><span class="p">,</span>
    <span class="c1">/// FrmOther - This form is for instructions that have no specific format.</span>
    <span class="n">FrmOther</span> <span class="o">=</span> <span class="mi">4</span><span class="p">,</span>

    <span class="n">FormMask</span> <span class="o">=</span> <span class="mi">15</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="c1">/// getCpu0RegisterNumbering - Given the enum value for some register,</span>
<span class="c1">/// return the number that it corresponds to.</span>
<span class="kr">inline</span> <span class="k">static</span> <span class="kt">unsigned</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegEnum</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">RegEnum</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">ZERO</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">AT</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">V0</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">V1</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">3</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">A0</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">4</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">A1</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">5</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">T9</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">6</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">T0</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">7</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">S0</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">8</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">S1</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">9</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">SW</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">10</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">GP</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">11</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">FP</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">12</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">SP</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">13</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LR</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">14</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">PC</span><span class="o">:</span>
    <span class="k">return</span> <span class="mi">15</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="nl">default:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown register number!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - getCpu0RegisterNumbering</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span> <span class="c1">// lbd document - mark - namespace llvm - end</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCAsmInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCAsmInfo.h - Cpu0 Asm Info ------------------------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the declaration of the Cpu0MCAsmInfo class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0TARGETASMINFO_H</span>
<span class="cp">#define CPU0TARGETASMINFO_H</span>

<span class="cp">#include &quot;llvm/MC/MCAsmInfo.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
  <span class="k">class</span> <span class="nc">StringRef</span><span class="p">;</span>
  <span class="k">class</span> <span class="nc">Target</span><span class="p">;</span>

  <span class="k">class</span> <span class="nc">Cpu0MCAsmInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCAsmInfo</span> <span class="p">{</span>
    <span class="k">virtual</span> <span class="kt">void</span> <span class="n">anchor</span><span class="p">();</span>
  <span class="nl">public:</span>
    <span class="k">explicit</span> <span class="nf">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">);</span>
  <span class="p">};</span>

<span class="p">}</span> <span class="c1">// namespace llvm</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCAsmInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0MCAsmInfo.cpp - Cpu0 Asm Properties ---------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains the declarations of the Cpu0MCAsmInfo properties.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;Cpu0MCAsmInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Triple.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="kt">void</span> <span class="n">Cpu0MCAsmInfo</span><span class="o">::</span><span class="n">anchor</span><span class="p">()</span> <span class="p">{</span> <span class="p">}</span>

<span class="n">Cpu0MCAsmInfo</span><span class="o">::</span><span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Triple</span> <span class="n">TheTriple</span><span class="p">(</span><span class="n">TT</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">TheTriple</span><span class="p">.</span><span class="n">getArch</span><span class="p">()</span> <span class="o">==</span> <span class="n">Triple</span><span class="o">::</span><span class="n">cpu0</span><span class="p">))</span>
    <span class="n">IsLittleEndian</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">AlignmentIsInBytes</span>          <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">Data16bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.2byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data32bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.4byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">Data64bitsDirective</span>         <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.8byte</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">PrivateGlobalPrefix</span>         <span class="o">=</span> <span class="s">&quot;$&quot;</span><span class="p">;</span>
  <span class="n">CommentString</span>               <span class="o">=</span> <span class="s">&quot;#&quot;</span><span class="p">;</span>
  <span class="n">ZeroDirective</span>               <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.space</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">GPRel32Directive</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.gpword</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">GPRel64Directive</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.gpdword</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>
  <span class="n">WeakRefDirective</span>            <span class="o">=</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.weak</span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span>

  <span class="n">SupportsDebugInformation</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">ExceptionsType</span> <span class="o">=</span> <span class="n">ExceptionHandling</span><span class="o">::</span><span class="n">DwarfCFI</span><span class="p">;</span>
  <span class="n">HasLEB128</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">DwarfRegNumForCFI</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, add code in Cpu0MCTargetDesc.cpp to register Cpu0InstPrinter as
follows,</p>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCTargetDesc.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/Support/DataTypes.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MCAsmBackend</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MCCodeEmitter</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MCContext</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MCInstrInfo</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MCObjectWriter</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">MCSubtargetInfo</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">StringRef</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">raw_ostream</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCAsmBackend</span> <span class="o">*</span><span class="nf">createCpu0AsmBackendEB32</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                       <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">);</span>
<span class="n">MCAsmBackend</span> <span class="o">*</span><span class="nf">createCpu0AsmBackendEL32</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                       <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/Cpu0MCTargetDesc.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0MCAsmInfo.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;InstPrinter/Cpu0InstPrinter.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
  <span class="kt">size_t</span> <span class="n">DashPosition</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">StringRef</span> <span class="n">TheTriple</span><span class="p">;</span>

  <span class="c1">// Let&#39;s see if there is a dash, like cpu0-unknown-linux.</span>
  <span class="n">DashPosition</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;-&#39;</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DashPosition</span> <span class="o">==</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">npos</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// No dash, we check the string size.</span>
    <span class="n">TheTriple</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// We are only interested in substring before dash.</span>
    <span class="n">TheTriple</span> <span class="o">=</span> <span class="n">TT</span><span class="p">.</span><span class="n">substr</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span><span class="n">DashPosition</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0&quot;</span> <span class="o">||</span> <span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0el&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span><span class="p">.</span><span class="n">empty</span><span class="p">()</span> <span class="o">||</span> <span class="n">CPU</span> <span class="o">==</span> <span class="s">&quot;cpu032II&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s">&quot;+cpu032II&quot;</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span> <span class="o">==</span> <span class="s">&quot;cpu032I&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s">&quot;+cpu032I&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstrInfo</span> <span class="o">*</span><span class="n">createCpu0MCInstrInfo</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MCInstrInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCInstrInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCInstrInfo</span><span class="p">(</span><span class="n">X</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenInstrInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">createCpu0MCRegisterInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCRegisterInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCRegisterInfo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenRegisterInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCSubtargetInfo</span> <span class="o">*</span><span class="n">createCpu0MCSubtargetInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span>
                                                  <span class="n">StringRef</span> <span class="n">FS</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span><span class="n">CPU</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">FS</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">ArchFS</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
      <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">ArchFS</span> <span class="o">+</span> <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">FS</span><span class="p">.</span><span class="n">str</span><span class="p">();</span>
    <span class="k">else</span>
      <span class="n">ArchFS</span> <span class="o">=</span> <span class="n">FS</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">MCSubtargetInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCSubtargetInfo</span><span class="p">();</span>
  <span class="n">InitCpu0MCSubtargetInfo</span><span class="p">(</span><span class="n">X</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">ArchFS</span><span class="p">);</span> <span class="c1">// defined in Cpu0GenSubtargetInfo.inc</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">createCpu0MCAsmInfo</span><span class="p">(</span><span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCAsmInfo</span> <span class="o">*</span><span class="n">MAI</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0MCAsmInfo</span><span class="p">(</span><span class="n">TT</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">MRI</span><span class="p">.</span><span class="n">getDwarfRegNum</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">MCCFIInstruction</span> <span class="n">Inst</span> <span class="o">=</span> <span class="n">MCCFIInstruction</span><span class="o">::</span><span class="n">createDefCfa</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">SP</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
  <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">addInitialFrameState</span><span class="p">(</span><span class="n">Inst</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MAI</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCCodeGenInfo</span> <span class="o">*</span><span class="n">createCpu0MCCodeGenInfo</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span>
                                              <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                                              <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCCodeGenInfo</span> <span class="o">*</span><span class="n">X</span> <span class="o">=</span> <span class="k">new</span> <span class="n">MCCodeGenInfo</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">CM</span> <span class="o">==</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">JITDefault</span><span class="p">)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Static</span><span class="p">;</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">RM</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">Default</span><span class="p">)</span>
    <span class="n">RM</span> <span class="o">=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">;</span>
  <span class="n">X</span><span class="o">-&gt;</span><span class="n">InitMCCodeGenInfo</span><span class="p">(</span><span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">);</span> <span class="c1">// defined in lib/MC/MCCodeGenInfo.cpp</span>
  <span class="k">return</span> <span class="n">X</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">static</span> <span class="n">MCInstPrinter</span> <span class="o">*</span><span class="n">createCpu0MCInstPrinter</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">SyntaxVariant</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCAsmInfo</span> <span class="o">&amp;</span><span class="n">MAI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCInstrInfo</span> <span class="o">&amp;</span><span class="n">MII</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">&amp;</span><span class="n">MRI</span><span class="p">,</span>
                                              <span class="k">const</span> <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0InstPrinter</span><span class="p">(</span><span class="n">MAI</span><span class="p">,</span> <span class="n">MII</span><span class="p">,</span> <span class="n">MRI</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - createCpu0MCInstPrinter</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0TargetMC</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Register the MC asm info.</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>
  <span class="n">RegisterMCAsmInfoFn</span> <span class="nf">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCAsmInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC codegen info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeGenInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeGenInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCCodeGenInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCCodeGenInfo</span><span class="p">);</span>
  <span class="c1">// Register the MC instruction info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstrInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCInstrInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstrInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCInstrInfo</span><span class="p">);</span>

  <span class="c1">// Register the MC register info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCRegInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span> <span class="n">createCpu0MCRegisterInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCRegInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span> <span class="n">createCpu0MCRegisterInfo</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Register the MC subtarget info.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCSubtargetInfo</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                          <span class="n">createCpu0MCSubtargetInfo</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCSubtargetInfo</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                          <span class="n">createCpu0MCSubtargetInfo</span><span class="p">);</span>
  <span class="c1">// Register the MCInstPrinter.</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
  <span class="n">TargetRegistry</span><span class="o">::</span><span class="n">RegisterMCInstPrinter</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">,</span>
                                        <span class="n">createCpu0MCInstPrinter</span><span class="p">);</span>
  <span class="c1">// lbd document - mark - RegisterMCInstPrinter</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0MCAsmInfo</span><span class="p">.</span><span class="n">cpp</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/MCTargetDesc/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0AsmPrinter</span>
</pre></div>
</div>
<p>Now, it&#8217;s time to work with AsmPrinter. According section
&#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id6" id="id2">[2]</a>, we can register our AsmPrinter when we need it
as the following function of LLVMInitializeCpu0AsmPrinter(),</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0AsmPrinter.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmPrinter.h - Cpu0 LLVM Assembly Printer ----------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Cpu0 Assembly printer class.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#ifndef CPU0ASMPRINTER_H</span>
<span class="cp">#define CPU0ASMPRINTER_H</span>

<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;Cpu0MCInstLower.h&quot;</span>
<span class="cp">#include &quot;Cpu0Subtarget.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/Compiler.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">MCStreamer</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MachineInstr</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">MachineBasicBlock</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">Module</span><span class="p">;</span>
<span class="k">class</span> <span class="nc">raw_ostream</span><span class="p">;</span>

<span class="k">class</span> <span class="nc">LLVM_LIBRARY_VISIBILITY</span> <span class="n">Cpu0AsmPrinter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">AsmPrinter</span> <span class="p">{</span>

  <span class="kt">void</span> <span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>

<span class="nl">public:</span>

  <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">*</span><span class="n">Subtarget</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span><span class="p">;</span>
  <span class="n">Cpu0MCInstLower</span> <span class="n">MCInstLowering</span><span class="p">;</span>

  <span class="k">explicit</span> <span class="nf">Cpu0AsmPrinter</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">,</span>  <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Streamer</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">AsmPrinter</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="n">Streamer</span><span class="p">),</span> <span class="n">MCInstLowering</span><span class="p">(</span><span class="o">*</span><span class="k">this</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Subtarget</span> <span class="o">=</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="s">&quot;Cpu0 Assembly Printer&quot;</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">);</span>

<span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
  <span class="kt">void</span> <span class="nf">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">printSavedRegsBitmask</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">printHex32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">int</span> <span class="n">Value</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">emitFrameDirective</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getCurrentABIString</span><span class="p">()</span> <span class="k">const</span><span class="p">;</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EmitFunctionEntryLabel</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EmitFunctionBodyStart</span><span class="p">();</span>
  <span class="k">virtual</span> <span class="kt">void</span> <span class="nf">EmitFunctionBodyEnd</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">PrintAsmOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                       <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                       <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">PrintAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNum</span><span class="p">,</span>
                             <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                             <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">EmitStartOfAsmFile</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">);</span>
  <span class="k">virtual</span> <span class="n">MachineLocation</span> <span class="n">getDebugValueLocation</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="nf">PrintDebugValueComment</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmPrinter.cpp - Cpu0 LLVM Assembly Printer -------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file contains a printer that converts from our internal representation</span>
<span class="c1">// of machine-dependent LLVM code to GAS-format CPU0 assembly language.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-asm-printer&quot;</span>
<span class="cp">#include &quot;Cpu0AsmPrinter.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0InstrInfo.h&quot;</span>
<span class="cp">#include &quot;InstPrinter/Cpu0InstPrinter.h&quot;</span>
<span class="cp">#include &quot;MCTargetDesc/Cpu0BaseInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/SmallString.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringExtras.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Twine.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/BasicBlock.h&quot;</span>
<span class="cp">#include &quot;llvm/IR/Instructions.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineConstantPool.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFrameInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstr.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineMemOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCStreamer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCAsmInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/raw_ostream.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/Mangler.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetLoweringObjectFile.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetOptions.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="n">AsmPrinter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//- EmitInstruction() must exists or will have run time error.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">isDebugValue</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="nf">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>

    <span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OS</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">MCInst</span> <span class="n">TmpInst0</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst0</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst0</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//  Cpu0 Asm Directives</span>
<span class="c1">//</span>
<span class="c1">//  -- Frame directive &quot;frame Stackpointer, Stacksize, RARegister&quot;</span>
<span class="c1">//  Describe the stack frame.</span>
<span class="c1">//</span>
<span class="c1">//  -- Mask directives &quot;(f)mask  bitmask, offset&quot;</span>
<span class="c1">//  Tells the assembler which registers are saved and where.</span>
<span class="c1">//  bitmask - contain a little endian bitset indicating which registers are</span>
<span class="c1">//            saved on function prologue (e.g. with a 0x80000000 mask, the</span>
<span class="c1">//            assembler knows the register 31 (RA) is saved at prologue.</span>
<span class="c1">//  offset  - the position before stack pointer subtraction indicating where</span>
<span class="c1">//            the first saved register on prologue is located. (e.g. with a</span>
<span class="c1">//</span>
<span class="c1">//  Consider the following function prologue:</span>
<span class="c1">//</span>
<span class="c1">//    .frame  $fp,48,$ra</span>
<span class="c1">//    .mask   0xc0000000,-8</span>
<span class="c1">//       addiu $sp, $sp, -48</span>
<span class="c1">//       st $ra, 40($sp)</span>
<span class="c1">//       st $fp, 36($sp)</span>
<span class="c1">//</span>
<span class="c1">//    With a 0xc0000000 mask, the assembler knows the register 31 (RA) and</span>
<span class="c1">//    30 (FP) are saved at prologue. As the save order on prologue is from</span>
<span class="c1">//    left to right, RA is saved first. A -8 offset means that after the</span>
<span class="c1">//    stack pointer subtration, the first register in the mask (RA) will be</span>
<span class="c1">//    saved at address 48-8=40.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Mask directives</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//	.frame	$sp,8,$lr</span>
<span class="c1">//-&gt;	.mask 	0x00000000,0</span>
<span class="c1">//	.set	noreorder</span>
<span class="c1">//	.set	nomacro</span>

<span class="c1">// Create a bitmask with all callee saved registers for CPU or Floating Point</span>
<span class="c1">// registers. For CPU registers consider RA, GP and FP for saving if necessary.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// CPU and FPU Saved Registers Bitmasks</span>
  <span class="kt">unsigned</span> <span class="n">CPUBitmask</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">CPUTopSavedRegOff</span><span class="p">;</span>

  <span class="c1">// Set the CPU and FPU Bitmasks</span>
  <span class="k">const</span> <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="c1">// size of stack area to which FP callee-saved regs are saved.</span>
  <span class="kt">unsigned</span> <span class="n">CPURegSize</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>

  <span class="c1">// Set CPU Bitmask.</span>
  <span class="k">for</span> <span class="p">(;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getReg</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">RegNum</span> <span class="o">=</span> <span class="n">getCpu0RegisterNumbering</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="n">CPUBitmask</span> <span class="o">|=</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="n">RegNum</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">CPUTopSavedRegOff</span> <span class="o">=</span> <span class="n">CPUBitmask</span> <span class="o">?</span> <span class="o">-</span><span class="n">CPURegSize</span> <span class="o">:</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Print CPUBitmask</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\t</span><span class="s">.mask </span><span class="se">\t</span><span class="s">&quot;</span><span class="p">;</span> <span class="n">printHex32</span><span class="p">(</span><span class="n">CPUBitmask</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;,&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">CPUTopSavedRegOff</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;\n&#39;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Print a 32 bit hex number with all numbers.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printHex32</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Value</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span><span class="p">;</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">7</span><span class="p">;</span> <span class="n">i</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span><span class="o">--</span><span class="p">)</span>
    <span class="n">O</span><span class="p">.</span><span class="n">write_hex</span><span class="p">((</span><span class="n">Value</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xF</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">)))</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="n">i</span><span class="o">*</span><span class="mi">4</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Frame and Set directives</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//-&gt;	.frame	$sp,8,$lr</span>
<span class="c1">//	.mask 	0x00000000,0</span>
<span class="c1">//	.set	noreorder</span>
<span class="c1">//	.set	nomacro</span>
<span class="c1">/// Frame Directive</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">emitFrameDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">&amp;</span><span class="n">RI</span> <span class="o">=</span> <span class="o">*</span><span class="n">TM</span><span class="p">.</span><span class="n">getRegisterInfo</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">stackReg</span>  <span class="o">=</span> <span class="n">RI</span><span class="p">.</span><span class="n">getFrameRegister</span><span class="p">(</span><span class="o">*</span><span class="n">MF</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">returnReg</span> <span class="o">=</span> <span class="n">RI</span><span class="p">.</span><span class="n">getRARegister</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="o">-&gt;</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.frame</span><span class="se">\t</span><span class="s">$&quot;</span> <span class="o">+</span>
           <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">stackReg</span><span class="p">)).</span><span class="n">lower</span><span class="p">()</span> <span class="o">+</span>
           <span class="s">&quot;,&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">stackSize</span><span class="p">)</span> <span class="o">+</span> <span class="s">&quot;,$&quot;</span> <span class="o">+</span>
           <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">returnReg</span><span class="p">)).</span><span class="n">lower</span><span class="p">());</span>
<span class="p">}</span>

<span class="c1">/// Emit Set directives.</span>
<span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">getCurrentABIString</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">getTargetABI</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0Subtarget</span>:<span class="o">:</span><span class="n">O32</span><span class="o">:</span>  <span class="k">return</span> <span class="s">&quot;abi32&quot;</span><span class="p">;</span>
  <span class="nl">default:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown Cpu0 ABI&quot;</span><span class="p">);;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//		.type	main,@function</span>
<span class="c1">//-&gt;		.ent	main                    # @main</span>
<span class="c1">//	main:</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionEntryLabel</span><span class="p">()</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.ent</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()));</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitLabel</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="p">);</span>
<span class="p">}</span>


<span class="c1">//	.frame	$sp,8,$pc</span>
<span class="c1">//	.mask 	0x00000000,0</span>
<span class="c1">//-&gt;	.set	noreorder</span>
<span class="c1">//-&gt;	.set	nomacro</span>
<span class="c1">/// EmitFunctionBodyStart - Targets can override this to emit stuff before</span>
<span class="c1">/// the first basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyStart</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Initialize</span><span class="p">(</span><span class="o">&amp;</span><span class="n">MF</span><span class="o">-&gt;</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">emitFrameDirective</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SmallString</span><span class="o">&lt;</span><span class="mi">128</span><span class="o">&gt;</span> <span class="n">Str</span><span class="p">;</span>
    <span class="n">raw_svector_ostream</span> <span class="nf">OS</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
    <span class="n">printSavedRegsBitmask</span><span class="p">(</span><span class="n">OS</span><span class="p">);</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">OS</span><span class="p">.</span><span class="n">str</span><span class="p">());</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noreorder&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">nomacro&quot;</span><span class="p">));</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noat&quot;</span><span class="p">));</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//-&gt;	.set	macro</span>
<span class="c1">//-&gt;	.set	reorder</span>
<span class="c1">//-&gt;	.end	main</span>
<span class="c1">/// EmitFunctionBodyEnd - Targets can override this to emit stuff after</span>
<span class="c1">/// the last basic block in the function.</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitFunctionBodyEnd</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// There are instruction for this macros, but they must</span>
  <span class="c1">// always be at the function end, and we can&#39;t emit and</span>
  <span class="c1">// break with BB logic.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
      <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">at&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">macro&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">reorder&quot;</span><span class="p">));</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.end</span><span class="se">\t</span><span class="s">&quot;</span> <span class="o">+</span> <span class="n">Twine</span><span class="p">(</span><span class="n">CurrentFnSym</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">//	.section .mdebug.abi32</span>
<span class="c1">//	.previous</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitStartOfAsmFile</span><span class="p">(</span><span class="n">Module</span> <span class="o">&amp;</span><span class="n">M</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// FIXME: Use SwitchSection.</span>

  <span class="c1">// Tell the assembler which ABI we are using</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.section .mdebug.&quot;</span> <span class="o">+</span>
                            <span class="n">Twine</span><span class="p">(</span><span class="n">getCurrentABIString</span><span class="p">()));</span>

  <span class="c1">// return to previous section</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.previous&quot;</span><span class="p">));</span>
<span class="p">}</span>

<span class="c1">// Print out an operand for an inline asm expression.</span>
<span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintAsmOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNum</span><span class="p">,</span>
                                     <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                                     <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Does this asm operand have a single letter operand modifier?</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExtraCode</span> <span class="o">&amp;&amp;</span> <span class="n">ExtraCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ExtraCode</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span> <span class="o">!=</span> <span class="mi">0</span><span class="p">)</span> <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Unknown modifier.</span>

    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNum</span><span class="p">);</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">ExtraCode</span><span class="p">[</span><span class="mi">0</span><span class="p">])</span> <span class="p">{</span>
    <span class="nl">default:</span>
      <span class="c1">// See if this is a generic print operand</span>
      <span class="k">return</span> <span class="n">AsmPrinter</span><span class="o">::</span><span class="n">PrintAsmOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span><span class="n">OpNum</span><span class="p">,</span><span class="n">AsmVariant</span><span class="p">,</span><span class="n">ExtraCode</span><span class="p">,</span><span class="n">O</span><span class="p">);</span>
    <span class="k">case</span> <span class="sc">&#39;X&#39;</span>: <span class="c1">// hex const int</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">utohexstr</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">())).</span><span class="n">lower</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;x&#39;</span>: <span class="c1">// hex const int (low 16 bits)</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;0x&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">utohexstr</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">)).</span><span class="n">lower</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;d&#39;</span>: <span class="c1">// decimal const int</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;m&#39;</span>: <span class="c1">// decimal const int minus 1</span>
      <span class="k">if</span> <span class="p">((</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="k">case</span> <span class="sc">&#39;z&#39;</span>: <span class="p">{</span>
      <span class="c1">// $0 if zero, regular printing otherwise</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">()</span> <span class="o">!=</span> <span class="n">MachineOperand</span><span class="o">::</span><span class="n">MO_Immediate</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="kt">int64_t</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Val</span><span class="p">)</span>
        <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">Val</span><span class="p">;</span>
      <span class="k">else</span>
        <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;$0&quot;</span><span class="p">;</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">printOperand</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">OpNum</span><span class="p">,</span> <span class="n">O</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                           <span class="kt">unsigned</span> <span class="n">OpNum</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">AsmVariant</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">ExtraCode</span><span class="p">,</span>
                                           <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="c1">// Currently we are expecting either no ExtraCode or &#39;D&#39;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ExtraCode</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// Unknown modifier.</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNum</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;unexpected inline asm memory operand&quot;</span><span class="p">);</span>
  <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;($&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">())</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>

  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">printOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">opNum</span><span class="p">,</span>
                                  <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">O</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="n">opNum</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="n">closeP</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span>
    <span class="n">closeP</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getTargetFlags</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GPREL</span><span class="o">:</span>    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%gp_rel(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_CALL</span><span class="o">:</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%call16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT16</span><span class="o">:</span>    <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got16(&quot;</span><span class="p">;</span>  <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT</span><span class="o">:</span>      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got(&quot;</span><span class="p">;</span>    <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_ABS_HI</span><span class="o">:</span>   <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%hi(&quot;</span><span class="p">;</span>     <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_ABS_LO</span><span class="o">:</span>   <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%lo(&quot;</span><span class="p">;</span>     <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_HI16</span><span class="o">:</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got_hi16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_LO16</span><span class="o">:</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%got_lo16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getType</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_Register</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="sc">&#39;$&#39;</span>
        <span class="o">&lt;&lt;</span> <span class="n">StringRef</span><span class="p">(</span><span class="n">Cpu0InstPrinter</span><span class="o">::</span><span class="n">getRegisterName</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getReg</span><span class="p">())).</span><span class="n">lower</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_Immediate</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_MachineBasicBlock</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">MO</span><span class="p">.</span><span class="n">getMBB</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">();</span>
      <span class="k">return</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_GlobalAddress</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">getSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getGlobal</span><span class="p">());</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_BlockAddress</span><span class="o">:</span> <span class="p">{</span>
      <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">BA</span> <span class="o">=</span> <span class="n">GetBlockAddressSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getBlockAddress</span><span class="p">());</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">BA</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ExternalSymbol</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">GetExternalSymbolSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getSymbolName</span><span class="p">());</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_JumpTableIndex</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">getPrivateGlobalPrefix</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;JTI&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">getFunctionNumber</span><span class="p">()</span>
        <span class="o">&lt;&lt;</span> <span class="sc">&#39;_&#39;</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getIndex</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ConstantPoolIndex</span><span class="o">:</span>
      <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="n">MAI</span><span class="o">-&gt;</span><span class="n">getPrivateGlobalPrefix</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;CPI&quot;</span>
        <span class="o">&lt;&lt;</span> <span class="n">getFunctionNumber</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;_&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getIndex</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getOffset</span><span class="p">())</span>
        <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;+&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MO</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="nl">default:</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;&lt;unknown operand type&gt;&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">closeP</span><span class="p">)</span> <span class="n">O</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;)&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MachineLocation</span>
<span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">getDebugValueLocation</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Handles frame addresses emitted in Cpu0InstrInfo::emitFrameIndexDebugValue.</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">==</span> <span class="mi">4</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid no. of machine operands!&quot;</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Unexpected MachineOperand types&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="nf">MachineLocation</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getReg</span><span class="p">(),</span>
                         <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">());</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">PrintDebugValueComment</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">,</span>
                                           <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// TODO: implement</span>
  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;PrintDebugValueComment()&quot;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// Force static initialization.</span>
<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmPrinter</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterAsmPrinter</span><span class="o">&lt;</span><span class="n">Cpu0AsmPrinter</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>The dynamic register mechanism is a good idea, right.</p>
<p>Add the following code to Cpu0ISelLowering.cpp.</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>

  <span class="c1">// Set up the register classes</span>
  <span class="n">addRegisterClass</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">);</span>

<span class="c1">//- Set .align 2</span>
<span class="c1">// It will emit .align 2 later</span>
  <span class="n">setMinFunctionAlignment</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>

<span class="c1">// must, computeRegisterProperties - Once all of the register classes are</span>
<span class="c1">//  added, this allows us to compute derived properties we expose.</span>
  <span class="n">computeRegisterProperties</span><span class="p">();</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Add the following code to Cpu0MachineFunction.h since the Cpu0AsmPrinter.cpp
will call getEmitNOAT().</p>
<p class="rubric">lbdex/Chapter3_2/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">EmitNOAT</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="p">...</span>
    <span class="n">EmitNOAT</span><span class="p">(</span><span class="nb">false</span><span class="p">),</span>
    <span class="p">...</span>
    <span class="p">{}</span>

  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">getEmitNOAT</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">EmitNOAT</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setEmitNOAT</span><span class="p">()</span> <span class="p">{</span> <span class="n">EmitNOAT</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span> <span class="p">}</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Beyond add these new .cpp files to CMakeLists.txt, please remember to add
subdirectory InstPrinter, enable asmprinter, add libraries AsmPrinter and
Cpu0AsmPrinter to LLVMBuild.txt as follows,</p>
<p class="rubric">lbdex/Chapter3_2/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>
<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenMCCodeEmitter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="n">emitter</span> <span class="o">-</span><span class="n">mc</span><span class="o">-</span><span class="n">emitter</span><span class="p">)</span>

<span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmWriter</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="k">asm</span><span class="o">-</span><span class="n">writer</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="n">Cpu0AsmPrinter</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="n">Cpu0MCInstLower</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
<span class="p">...</span>
<span class="n">add_subdirectory</span><span class="p">(</span><span class="n">InstPrinter</span><span class="p">)</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_2/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//  LLVMBuild.txt</span>
<span class="p">[</span><span class="n">common</span><span class="p">]</span>
<span class="n">subdirectories</span> <span class="o">=</span>
  <span class="n">InstPrinter</span>
  <span class="p">...</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="p">...</span>
<span class="cp"># Please enable asmprinter</span>
<span class="n">has_asmprinter</span> <span class="o">=</span> <span class="mi">1</span>
<span class="p">...</span>

<span class="p">[</span><span class="n">component_1</span><span class="p">]</span>
<span class="cp"># Add AsmPrinter Cpu0AsmPrinter</span>
<span class="n">required_libraries</span> <span class="o">=</span>
                     <span class="n">AsmPrinter</span>
                     <span class="p">...</span>
                     <span class="n">Cpu0AsmPrinter</span>
                     <span class="p">...</span>
</pre></div>
</div>
<p>Now, run Chapter3_2/Cpu0 for AsmPrinter support, will get error message as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
/Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc: target does not
support generation of this file <span class="nb">type</span>!
</pre></div>
</div>
<p>The <tt class="docutils literal"><span class="pre">llc</span></tt> fails to compile IR code into machine code since we didn&#8217;t implement
class Cpu0DAGToDAGISel. Before the implementation, we will introduce the LLVM
Code Generation Sequence, DAG, and LLVM instruction selection in next 3
sections.</p>
</div>
<div class="section" id="llvm-code-generation-sequence">
<h2>LLVM Code Generation Sequence<a class="headerlink" href="#llvm-code-generation-sequence" title="Permalink to this headline">¶</a></h2>
<p>Following diagram came from tricore_llvm.pdf.</p>
<div class="figure align-center" id="backendstructure-f5">
<img alt="_images/5.png" src="_images/5.png" />
<p class="caption">Figure 5: tricore_llvm.pdf: Code generation sequence. On the path from LLVM code to
assembly code, numerous passes are run through and several data structures
are used to represent the intermediate results.</p>
</div>
<p>LLVM is a Static Single Assignment (SSA) based representation.
LLVM provides an infinite virtual registers which can hold values of primitive
type (integral, floating point, or pointer values).
So, every operand can save in different virtual register in llvm SSA
representation.
Comment is “;” in llvm representation.
Following is the llvm SSA instructions.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">store</span> <span class="n">i32</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>  <span class="p">;</span> <span class="n">store</span> <span class="n">i32</span> <span class="n">type</span> <span class="n">of</span> <span class="mi">0</span> <span class="n">to</span> <span class="k">virtual</span> <span class="k">register</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">a</span> <span class="n">is</span>
            <span class="p">;</span>  <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span>
<span class="n">store</span> <span class="n">i32</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span> <span class="p">;</span> <span class="n">store</span> <span class="o">%</span><span class="n">b</span> <span class="n">contents</span> <span class="n">to</span> <span class="o">%</span><span class="n">c</span> <span class="n">point</span> <span class="n">to</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span> <span class="n">isi32</span> <span class="n">type</span> <span class="k">virtual</span>
            <span class="p">;</span>  <span class="k">register</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span> <span class="n">is</span> <span class="n">pointer</span> <span class="n">type</span> <span class="n">which</span> <span class="n">point</span> <span class="n">to</span> <span class="n">i32</span> <span class="n">value</span><span class="p">.</span>
<span class="o">%</span><span class="n">a1</span> <span class="o">=</span> <span class="n">load</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>    <span class="p">;</span> <span class="n">load</span> <span class="n">the</span> <span class="n">memory</span> <span class="n">value</span> <span class="n">where</span> <span class="o">%</span><span class="n">a</span> <span class="n">point</span> <span class="n">to</span> <span class="n">and</span> <span class="n">assign</span> <span class="n">the</span>
            <span class="p">;</span>  <span class="n">memory</span> <span class="n">value</span> <span class="n">to</span> <span class="o">%</span><span class="n">a1</span>
<span class="o">%</span><span class="n">a3</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a2</span><span class="p">,</span> <span class="mi">1</span>  <span class="p">;</span> <span class="n">add</span> <span class="o">%</span><span class="n">a2</span> <span class="n">and</span> <span class="mi">1</span> <span class="n">and</span> <span class="n">save</span> <span class="n">to</span> <span class="o">%</span><span class="n">a3</span>
</pre></div>
</div>
<p>We explain the code generation process as below.
If you don&#8217;t feel comfortable, please check tricore_llvm.pdf section 4.2 first.
You can  read “The LLVM Target-Independent Code Generator” from here <a class="footnote-reference" href="#id7" id="id3">[3]</a>
and “LLVM Language Reference Manual” from here <a class="footnote-reference" href="#id8" id="id4">[4]</a>
before go ahead, but we think read section
4.2 of tricore_llvm.pdf is enough.
We suggest you read the web site documents as above only when you are still not
quite understand, even if you have read the articles of this section and
next 2 sections for DAG and Instruction Selection.</p>
<ol class="arabic simple">
<li>Instruction Selection</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, transfer the llvm opcode into machine opcode, but the operand</span>
<span class="c1">//  still is llvm virtual operand.</span>
    <span class="n">store</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span> <span class="c1">// store 0 of i16 type to where virtual register %a</span>
               <span class="c1">//  point to</span>
<span class="o">=&gt;</span>  <span class="n">addiu</span> <span class="n">i16</span> <span class="mi">0</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">a</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Scheduling and Formation</li>
</ol>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// In this stage, reorder the instructions sequence for optimization in</span>
<span class="c1">//  instructions cycle or in register pressure.</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span> <span class="c1">// st %a to *(%b+5)</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span>

<span class="c1">// Transfer above instructions order as follows. In RISC like Mips the ld %c use</span>
<span class="c1">//  the previous instruction st %c, must wait more than 1</span>
<span class="c1">// cycles. Meaning the ld cannot follow st immediately.</span>
<span class="o">=&gt;</span>  <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
<span class="c1">// If without reorder instructions, a instruction nop which do nothing must be</span>
<span class="c1">//  filled, contribute one instruction cycle more than optimization. (Actually,</span>
<span class="c1">//  Mips is scheduled with hardware dynamically and will insert nop between st</span>
<span class="c1">//  and ld instructions if compiler didn&#39;t insert nop.)</span>
    <span class="n">st</span> <span class="n">i32</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="n">i16</span><span class="o">*</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i16</span> <span class="mi">5</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>
    <span class="n">nop</span>
    <span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">ld</span> <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="n">i16</span> <span class="mi">0</span>

<span class="c1">// Minimum register pressure</span>
<span class="c1">//  Suppose %c is alive after the instructions basic block (meaning %c will be</span>
<span class="c1">//  used after the basic block), %a and %b are not alive after that.</span>
<span class="c1">// The following no reorder version need 3 registers at least</span>
    <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>

<span class="c1">// The reorder version need 2 registers only (by allocate %a and %b in the same</span>
<span class="c1">//  register)</span>
<span class="o">=&gt;</span> <span class="o">%</span><span class="n">a</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">1</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">1</span>
    <span class="o">%</span><span class="n">b</span> <span class="o">=</span> <span class="n">add</span> <span class="n">i32</span> <span class="mi">2</span><span class="p">,</span> <span class="n">i32</span> <span class="mi">0</span>
    <span class="n">st</span> <span class="o">%</span><span class="n">b</span><span class="p">,</span>  <span class="n">i32</span><span class="o">*</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="mi">2</span>
</pre></div>
</div>
<ol class="arabic" start="3">
<li><p class="first">SSA-based Machine Code Optimization</p>
<blockquote>
<div><p>For example, common expression remove, shown in next section DAG.</p>
</div></blockquote>
</li>
<li><p class="first">Register Allocation</p>
<blockquote>
<div><p>Allocate real register for virtual register.</p>
</div></blockquote>
</li>
<li><p class="first">Prologue/Epilogue Code Insertion</p>
<blockquote>
<div><p>Explain in section Add Prologue/Epilogue functions</p>
</div></blockquote>
</li>
<li><p class="first">Late Machine Code Optimizations</p>
<blockquote>
<div><p>Any “last-minute” peephole optimizations of the final machine code can be
applied during this phase.
For example, replace x = x * 2 by x = x &lt; 1 for integer operand.</p>
</div></blockquote>
</li>
<li><dl class="first docutils">
<dt>Code Emission</dt>
<dd><p class="first last">Finally, the completed machine code is emitted. For static compilation,
the end result is an assembly code file; for JIT compilation, the opcodes
of the machine instructions are written into memory.</p>
</dd>
</dl>
</li>
</ol>
<p>The llvm code generation sequence also can be obtained by
<tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt> as the following. The first 4 code generation
sequences from <a class="pageref" href="#backendstructure-f5">Figure  5</a> are in the
<strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> of the <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt>
displayed. The order of Peephole Optimizations and Prologue/Epilogue Insertion
is inconsistent in them (please check the * in the following).
No need to be bothered since the the LLVM is under development and changed from
time to time.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc --help-hidden
OVERVIEW: llvm system compiler

USAGE: llc <span class="o">[</span>options<span class="o">]</span> &lt;input bitcode&gt;

OPTIONS:
...
  -debug-pass                             - Print PassManager debugging <span class="nv">information</span>
    <span class="o">=</span>None                                 -   disable debug <span class="nv">output</span>
    <span class="o">=</span>Arguments                            -   print pass arguments to pass to <span class="s1">&#39;opt&#39;</span>
    <span class="o">=</span>Structure                            -   print pass structure before run<span class="o">()</span>
    <span class="o">=</span>Executions                           -   print pass name before it is <span class="nv">executed</span>
    <span class="o">=</span>Details                              -   print pass details when it is executed

118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>llc -march<span class="o">=</span>mips -debug-pass<span class="o">=</span>Structure ch3.bc
...
Target Library Information
Target Transform Info
Data Layout
Target Pass Configuration
No Alias Analysis <span class="o">(</span>always returns <span class="s1">&#39;may&#39;</span> <span class="nb">alias</span><span class="o">)</span>
Type-Based Alias Analysis
Basic Alias Analysis <span class="o">(</span>stateless AA impl<span class="o">)</span>
Create Garbage Collector Module Metadata
Machine Module Information
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Natural Loop Information
      Loop Pass Manager
        Canonicalize natural loops
      Scalar Evolution Analysis
      Loop Pass Manager
        Canonicalize natural loops
        Induction Variable Users
        Loop Strength Reduction
      Lower Garbage Collection Instructions
      Remove unreachable blocks from the CFG
      Exception handling preparation
      Optimize <span class="k">for </span>code generation
      Insert stack protectors
      Preliminary module verification
      Dominator Tree Construction
      Module Verifier
      Machine Function Analysis
      Natural Loop Information
      Branch Probability Analysis
    * MIPS DAG-&gt;DAG Pattern Instruction Selection
      Expand ISel Pseudo-instructions
      Tail Duplication
      Optimize machine instruction PHIs
      MachineDominator Tree Construction
      Slot index numbering
      Merge disjoint stack slots
      Local Stack Slot Allocation
      Remove dead machine instructions
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Machine Loop Invariant Code Motion
      Machine Common Subexpression Elimination
      Machine code sinking
    * Peephole Optimizations
      Process Implicit Definitions
      Remove unreachable machine basic blocks
      Live Variable Analysis
      Eliminate PHI nodes <span class="k">for </span>register allocation
      Two-Address instruction pass
      Slot index numbering
      Live Interval Analysis
      Debug Variable Analysis
      Simple Register Coalescing
      Live Stack Slot Analysis
      Calculate spill weights
      Virtual Register Map
      Live Register Matrix
      Bundle Machine CFG Edges
      Spill Code Placement Analysis
    * Greedy Register Allocator
      Virtual Register Rewriter
      Stack Slot Coloring
      Machine Loop Invariant Code Motion
    * Prologue/Epilogue Insertion &amp; Frame Finalization
      Control Flow Optimizer
      Tail Duplication
      Machine Copy Propagation Pass
    * Post-RA pseudo instruction expansion pass
      MachineDominator Tree Construction
      Machine Natural Loop Construction
      Post RA top-down list latency scheduler
      Analyze Machine Code For Garbage Collection
      Machine Block Frequency Analysis
      Branch Probability Basic Block Placement
      Mips Delay Slot Filler
      Mips Long Branch
      MachineDominator Tree Construction
      Machine Natural Loop Construction
    * Mips Assembly Printer
      Delete Garbage Collector Information
</pre></div>
</div>
</div>
<div class="section" id="dag-directed-acyclic-graph">
<h2>DAG (Directed Acyclic Graph)<a class="headerlink" href="#dag-directed-acyclic-graph" title="Permalink to this headline">¶</a></h2>
<p>Many important techniques for local optimization begin by transforming a basic
block into DAG. For example, the basic block code and it&#8217;s corresponding DAG as
<a class="pageref" href="#backendstructure-f6">Figure  6</a>.</p>
<div class="figure align-center" id="backendstructure-f6">
<img alt="_images/6.png" src="_images/6.png" />
<p class="caption">Figure 6: DAG example</p>
</div>
<p>If b is not live on exit from the block, then we can do common expression
remove to get the following code.</p>
<div class="highlight-c++"><pre>a = b + c
d = a – d
c = d + c</pre>
</div>
<p>As you can imagine, the common expression remove can apply in IR or machine
code.</p>
<p>DAG like a tree which opcode is the node and operand (register and
const/immediate/offset) is leaf.
It can also be represented by list as prefix order in tree.
For example, (+ b, c), (+ b, 1) is IR DAG representation.</p>
</div>
<div class="section" id="instruction-selection">
<h2>Instruction Selection<a class="headerlink" href="#instruction-selection" title="Permalink to this headline">¶</a></h2>
<p>In back end, we need to translate IR code into machine code at Instruction
Selection Process as <a class="pageref" href="#backendstructure-f7">Figure  7</a>.</p>
<div class="figure align-center" id="backendstructure-f7">
<img alt="_images/7.png" src="_images/7.png" />
<p class="caption">Figure 7: IR and it&#8217;s corresponding machine instruction</p>
</div>
<p>For machine instruction selection, the better solution is represent IR and
machine instruction by DAG.
In <a class="pageref" href="#backendstructure-f8">Figure  8</a>, we skip the register leaf.
The rj + rk is IR DAG representation (for symbol notation, not llvm SSA form).
ADD is machine instruction.</p>
<div class="figure align-center" id="backendstructure-f8">
<img alt="_images/8.png" src="_images/8.png" />
<p class="caption">Figure 8: Instruction DAG representation</p>
</div>
<p>The IR DAG and machine instruction DAG can also represented as list.
For example, (+ ri, rj), (- ri, 1) are lists for IR DAG; (ADD ri, rj),
(SUBI ri, 1) are lists for machine instruction DAG.</p>
<p>Now, let&#8217;s recall the ADDiu instruction defined on Cpu0InstrInfo.td in the
previous chapter. List them again as follows,</p>
<p class="rubric">lbdex/Chapter2/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Format L instruction class in Cpu0 : &lt;|opcode|ra|rb|cx|&gt;</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">class</span> <span class="nc">FL</span><span class="o">&lt;</span><span class="n">bits</span><span class="o">&lt;</span><span class="mi">8</span><span class="o">&gt;</span> <span class="n">op</span><span class="p">,</span> <span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="p">,</span>
         <span class="n">InstrItinClass</span> <span class="n">itin</span><span class="o">&gt;:</span> <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">itin</span><span class="p">,</span> <span class="n">FrmL</span><span class="o">&gt;</span>
<span class="p">{</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">ra</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">4</span><span class="o">&gt;</span>  <span class="n">rb</span><span class="p">;</span>
  <span class="n">bits</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span> <span class="n">imm16</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">op</span><span class="p">;</span>

  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">23</span><span class="o">-</span><span class="mi">20</span><span class="p">}</span> <span class="o">=</span> <span class="n">ra</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">19</span><span class="o">-</span><span class="mi">16</span><span class="p">}</span> <span class="o">=</span> <span class="n">rb</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Inst</span><span class="p">{</span><span class="mi">15</span><span class="o">-</span><span class="mi">0</span><span class="p">}</span>  <span class="o">=</span> <span class="n">imm16</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Arithmetic and logical instructions with 2 register operands.
class ArithLogicI&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  Operand Od, PatLeaf imm_type, RegisterClass RC&gt; :
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set GPROut:$ra, (OpNode RC:$rb, imm_type:$imm16))], IIAlu&gt; {
  let isReMaterializable = 1;
}
...
def ADDiu   : ArithLogicI&lt;0x09, "addiu", add, simm16, immSExt16, CPURegs&gt;;</pre>
</div>
<p><a class="pageref" href="#backendstructure-f9">Figure  9</a> shows how the pattern match work in the IR
node <strong>add</strong> and instruction <strong>ADDiu</strong> defined in Cpu0InstrInfo.td. This example
IR node &#8220;add %a, 5&#8221;, will be translated to &#8220;addiu $r1, 5&#8221; after %a allcated to
register $r1 in regiter allocation stage since the IR
pattern[(set RC:$ra, (OpNode RC:$rb, imm_type:$imm16))] is set in ADDiu and the
2nd operand is signed immediate which matched &#8220;%a, 5&#8221;. In addition to pattern
match, the .td also set assembly string &#8220;addiu&#8221; and op code 0x09.
With this information, the LLVM TableGen will generate instruction both in
assembly and binary automatically (the binary instruction in obj file of ELF
format which will be shown at later chapter).
Similarly, the machine instruction DAG node LD and ST can be got from IR DAG
node <strong>load</strong> and <strong>store</strong>.</p>
<div class="figure align-center" id="backendstructure-f9">
<img alt="_images/9.png" src="_images/9.png" />
<p class="caption">Figure 9: Pattern match for ADDiu instruction and IR node add</p>
</div>
<p>Some cpu/fpu (floating point processor) has multiply-and-add floating point
instruction, fmadd.
It can be represented by DAG list (fadd (fmul ra, rc), rb).
For this implementation, we can assign fmadd DAG pattern to instruction td as
follows,</p>
<div class="highlight-c++"><pre>def FMADDS : AForm_1&lt;59, 29,
          (ops F4RC:$FRT, F4RC:$FRA, F4RC:$FRC, F4RC:$FRB),
          "fmadds $FRT, $FRA, $FRC, $FRB",
          [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
                       F4RC:$FRB))]&gt;;</pre>
</div>
<p>Similar with ADDiu, [(set F4RC:$FRT, (fadd (fmul F4RC:$FRA, F4RC:$FRC),
F4RC:$FRB))] is the pattern which include node <strong>fmul</strong> and node <strong>fadd</strong>.</p>
<p>Now, for the following basic block notation IR and llvm SSA IR code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">d</span> <span class="o">=</span> <span class="n">a</span> <span class="o">*</span> <span class="n">c</span>
<span class="n">e</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">b</span>
<span class="p">...</span>

<span class="o">%</span><span class="n">d</span> <span class="o">=</span> <span class="n">fmul</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span>
<span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fadd</span> <span class="o">%</span><span class="n">d</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>The llvm SelectionDAG Optimization Phase (is part of Instruction Selection
Process) prefered to translate this 2 IR DAG node (fmul %a, %c) (fadd %d, %b)
into one machine instruction DAG node (<strong>fmadd</strong> %a, %c, %b), than translate
them into 2 machine instruction nodes <strong>fmul</strong> and <strong>fadd</strong>.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="o">%</span><span class="n">e</span> <span class="o">=</span> <span class="n">fmadd</span> <span class="o">%</span><span class="n">a</span><span class="p">,</span> <span class="o">%</span><span class="n">c</span><span class="p">,</span> <span class="o">%</span><span class="n">b</span>
<span class="p">...</span>
</pre></div>
</div>
<p>As you can see, the IR notation representation is easier to read then llvm SSA
IR form.
So, we  use the notation form in this book sometimes.</p>
<p>For the following basic block code,</p>
<div class="highlight-c++"><pre>a = b + c   // in notation IR form
d = a – d
%e = fmadd %a, %c, %b // in llvm SSA IR form</pre>
</div>
<p>We can apply <a class="pageref" href="#backendstructure-f8">Figure  8</a> Instruction Tree Patterns to get the
following machine code,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">load</span>  <span class="n">rb</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">8</span><span class="p">);</span> <span class="c1">// assume b allocate in sp+8, sp is stack point register</span>
<span class="n">load</span>  <span class="n">rc</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">16</span><span class="p">);</span>
<span class="n">add</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rb</span><span class="p">,</span> <span class="n">rc</span><span class="p">;</span>
<span class="n">load</span>  <span class="n">rd</span><span class="p">,</span> <span class="n">M</span><span class="p">(</span><span class="n">sp</span><span class="o">+</span><span class="mi">24</span><span class="p">);</span>
<span class="n">sub</span> <span class="n">rd</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rd</span><span class="p">;</span>
<span class="n">fmadd</span> <span class="n">re</span><span class="p">,</span> <span class="n">ra</span><span class="p">,</span> <span class="n">rc</span><span class="p">,</span> <span class="n">rb</span><span class="p">;</span>
</pre></div>
</div>
</div>
<div class="section" id="add-cpu0dagtodagisel-class">
<h2>Add Cpu0DAGToDAGISel class<a class="headerlink" href="#add-cpu0dagtodagisel-class" title="Permalink to this headline">¶</a></h2>
<p>The IR DAG to machine instruction DAG transformation is introduced in the
previous section.
Now, let&#8217;s check what IR DAG nodes the file ch3.bc has. List ch3.ll as follows,</p>
<div class="highlight-c++"><pre>// ch3.ll
define i32 @main() nounwind uwtable {
%1 = alloca i32, align 4
store i32 0, i32* %1
ret i32 0
}</pre>
</div>
<p>As above, ch3.ll use the IR DAG node <strong>store</strong>, <strong>ret</strong>. Actually, it also use
<strong>add</strong> for sp (stack point) register adjust.
So, the definitions in Cpu0InstrInfo.td as follows is enough.
IR DAG is defined in file  include/llvm/Target/TargetSelectionDAG.td.</p>
<p class="rubric">lbdex/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">/// Load and Store Instructions</span>
<span class="c1">///  aligned</span>
<span class="n">defm</span> <span class="n">LD</span>     <span class="o">:</span> <span class="n">LoadM32</span><span class="o">&lt;</span><span class="mh">0x01</span><span class="p">,</span>  <span class="s">&quot;ld&quot;</span><span class="p">,</span>  <span class="n">load_a</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">defm</span> <span class="n">ST</span>     <span class="o">:</span> <span class="n">StoreM32</span><span class="o">&lt;</span><span class="mh">0x02</span><span class="p">,</span> <span class="s">&quot;st&quot;</span><span class="p">,</span>  <span class="n">store_a</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">/// Arithmetic Instructions (ALU Immediate)</span>
<span class="c1">// IR &quot;add&quot; defined in include/llvm/Target/TargetSelectionDAG.td, line 315 (def add).</span>
<span class="n">def</span> <span class="n">ADDiu</span>   <span class="o">:</span> <span class="n">ArithLogicI</span><span class="o">&lt;</span><span class="mh">0x09</span><span class="p">,</span> <span class="s">&quot;addiu&quot;</span><span class="p">,</span> <span class="n">add</span><span class="p">,</span> <span class="n">simm16</span><span class="p">,</span> <span class="n">immSExt16</span><span class="p">,</span> <span class="n">CPURegs</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">let</span> <span class="n">isReturn</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isTerminator</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hasDelaySlot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isBarrier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hasCtrlDep</span><span class="o">=</span><span class="mi">1</span> <span class="n">in</span>
<span class="n">def</span> <span class="n">RetLR</span> <span class="o">:</span> <span class="n">Cpu0Pseudo</span><span class="o">&lt;</span><span class="p">(</span><span class="n">outs</span><span class="p">),</span> <span class="p">(</span><span class="n">ins</span><span class="p">),</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">Cpu0Ret</span><span class="p">)]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">RET</span>     <span class="o">:</span> <span class="n">RetBase</span><span class="o">&lt;</span><span class="n">GPROut</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Add class Cpu0DAGToDAGISel (Cpu0ISelDAGToDAG.cpp) to CMakeLists.txt, and add
following fragment to Cpu0TargetMachine.cpp,</p>
<p class="rubric">lbdex/Chapter3_3/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(...</span>
  <span class="p">...</span>
  <span class="n">Cpu0ISelDAGToDAG</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>The following code in Cpu0TargetMachine.cpp will create a pass in instruction
selection stage.</p>
<p class="rubric">lbdex/Chapter3_3/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">addInstSelector</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">};</span>
<span class="p">}</span> <span class="c1">// namespace</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Install an instruction selector pass using</span>
<span class="c1">// the ISelDag to gen Cpu0 code.</span>
<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addInstSelector</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - addInstSelector()</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_3/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0ISelDAGToDAG.cpp - A Dag to Dag Inst Selector for Cpu0 --------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This file defines an instruction selector for the CPU0 target.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;cpu0-isel&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><pre>#include "Cpu0RegisterInfo.h"
#include "Cpu0Subtarget.h"
#include "Cpu0TargetMachine.h"
#include "MCTargetDesc/Cpu0BaseInfo.h"
#include "llvm/IR/GlobalValue.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/Intrinsics.h"
#include "llvm/Support/CFG.h"
#include "llvm/IR/Type.h"
#include "llvm/CodeGen/MachineConstantPool.h"
#include "llvm/CodeGen/MachineFunction.h"
#include "llvm/CodeGen/MachineFrameInfo.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/CodeGen/MachineRegisterInfo.h"
#include "llvm/CodeGen/SelectionDAGISel.h"
#include "llvm/CodeGen/SelectionDAGNodes.h"
#include "llvm/Target/TargetMachine.h"
#include "llvm/Support/Debug.h"
#include "llvm/Support/ErrorHandling.h"
#include "llvm/Support/raw_ostream.h"
using namespace llvm;

//===----------------------------------------------------------------------===//
// Instruction Selector Implementation
//===----------------------------------------------------------------------===//

//===----------------------------------------------------------------------===//
// Cpu0DAGToDAGISel - CPU0 specific code to select CPU0 machine
// instructions for SelectionDAG operations.
//===----------------------------------------------------------------------===//
namespace {

class Cpu0DAGToDAGISel : public SelectionDAGISel {

  /// TM - Keep a reference to Cpu0TargetMachine.
  Cpu0TargetMachine &amp;TM;

  /// Subtarget - Keep a pointer to the Cpu0Subtarget around so that we can
  /// make the right decision when generating code for different targets.
  const Cpu0Subtarget &amp;Subtarget;

public:
  explicit Cpu0DAGToDAGISel(Cpu0TargetMachine &amp;tm) :
  SelectionDAGISel(tm),
  TM(tm), Subtarget(tm.getSubtarget&lt;Cpu0Subtarget&gt;()) {}

  // Pass Name
  virtual const char *getPassName() const {
    return "CPU0 DAG-&gt;DAG Pattern Instruction Selection";
  }

  virtual bool runOnMachineFunction(MachineFunction &amp;MF);

private:
  // Include the pieces autogenerated from the target description.
  #include "Cpu0GenDAGISel.inc"

  /// getTargetMachine - Return a reference to the TargetMachine, casted
  /// to the target-specific type.
  const Cpu0TargetMachine &amp;getTargetMachine() {
    return static_cast&lt;const Cpu0TargetMachine &amp;&gt;(TM);
  }

  /// getInstrInfo - Return a reference to the TargetInstrInfo, casted
  /// to the target-specific type.
  const Cpu0InstrInfo *getInstrInfo() {
    return getTargetMachine().getInstrInfo();
  }

  SDNode *getGlobalBaseReg();

</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre>                                         <span class="n">EVT</span> <span class="n">Ty</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">HasLo</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">HasHi</span><span class="p">);</span>

  <span class="n">SDNode</span> <span class="o">*</span><span class="nf">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">N</span><span class="p">);</span>
  <span class="c1">// Complex Pattern.</span>
  <span class="kt">bool</span> <span class="nf">SelectAddr</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Parent</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">N</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Base</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Offset</span><span class="p">);</span>
  <span class="c1">// getImm - Return a target constant with the specified value.</span>
  <span class="kr">inline</span> <span class="n">SDValue</span> <span class="nf">getImm</span><span class="p">(</span><span class="k">const</span> <span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Imm</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getValueType</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">virtual</span> <span class="kt">bool</span> <span class="nf">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span>
                                            <span class="kt">char</span> <span class="n">ConstraintCode</span><span class="p">,</span>
                                            <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">);</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">Ret</span> <span class="o">=</span> <span class="n">SelectionDAGISel</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">Ret</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// ComplexPattern used on Cpu0InstrInfo</span>
<span class="c1">/// Used on Cpu0 Load/Store instructions</span>
<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span>
<span class="n">SelectAddr</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Parent</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Addr</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Base</span><span class="p">,</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Offset</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">EVT</span> <span class="n">ValTy</span> <span class="o">=</span> <span class="n">Addr</span><span class="p">.</span><span class="n">getValueType</span><span class="p">();</span>

  <span class="c1">// If Parent is an unaligned f32 load or store, select a (base + index)</span>
  <span class="c1">// floating point load/store instruction (luxc1 or suxc1).</span>
  <span class="k">const</span> <span class="n">LSBaseSDNode</span><span class="o">*</span> <span class="n">LS</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Parent</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">LS</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">LSBaseSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Parent</span><span class="p">)))</span> <span class="p">{</span>
    <span class="n">EVT</span> <span class="n">VT</span> <span class="o">=</span> <span class="n">LS</span><span class="o">-&gt;</span><span class="n">getMemoryVT</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">VT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span> <span class="o">/</span> <span class="mi">8</span> <span class="o">&gt;</span> <span class="n">LS</span><span class="o">-&gt;</span><span class="n">getAlignment</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">getTargetLowering</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">allowsUnalignedMemoryAccesses</span><span class="p">(</span><span class="n">VT</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;Unaligned loads/stores not supported for this type.&quot;</span><span class="p">);</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">VT</span> <span class="o">==</span> <span class="n">MVT</span><span class="o">::</span><span class="n">f32</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// if Address is FI, get the TargetFrameIndex.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">FrameIndexSDNode</span> <span class="o">*</span><span class="n">FIN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">FrameIndexSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Addr</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Base</span>   <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetFrameIndex</span><span class="p">(</span><span class="n">FIN</span><span class="o">-&gt;</span><span class="n">getIndex</span><span class="p">(),</span> <span class="n">ValTy</span><span class="p">);</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ValTy</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Base</span>   <span class="o">=</span> <span class="n">Addr</span><span class="p">;</span>
  <span class="n">Offset</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">ValTy</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - SelectAddr</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Opcode</span> <span class="o">=</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Dump information about the Node being selected</span>
  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Selecting: &quot;</span><span class="p">;</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">);</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If we have a custom node, we already have selected!</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Node</span><span class="o">-&gt;</span><span class="n">isMachineOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;== &quot;</span><span class="p">;</span> <span class="n">Node</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">);</span> <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">NULL</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">///</span>
  <span class="c1">// Instruction Selection not handled by the auto-generated</span>
  <span class="c1">// tablegen selection should be handled here.</span>
  <span class="c1">///</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">switch</span><span class="p">(</span><span class="n">Opcode</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">Constant</span><span class="o">:</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">ConstantSDNode</span> <span class="o">*</span><span class="n">CN</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ConstantSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>
    <span class="kt">unsigned</span> <span class="n">Size</span> <span class="o">=</span> <span class="n">CN</span><span class="o">-&gt;</span><span class="n">getValueSizeInBits</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Size</span> <span class="o">==</span> <span class="mi">32</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// Select the default instruction</span>
  <span class="n">SDNode</span> <span class="o">*</span><span class="n">ResNode</span> <span class="o">=</span> <span class="n">SelectCode</span><span class="p">(</span><span class="n">Node</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;=&gt; &quot;</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ResNode</span> <span class="o">==</span> <span class="nb">NULL</span> <span class="o">||</span> <span class="n">ResNode</span> <span class="o">==</span> <span class="n">Node</span><span class="p">)</span>
    <span class="n">DEBUG</span><span class="p">(</span><span class="n">Node</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">));</span>
  <span class="k">else</span>
    <span class="nf">DEBUG</span><span class="p">(</span><span class="n">ResNode</span><span class="o">-&gt;</span><span class="n">dump</span><span class="p">(</span><span class="n">CurDAG</span><span class="p">));</span>
  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">ResNode</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// lbd document - mark - inlineasm begin</span>
<span class="kt">bool</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span>
<span class="n">SelectInlineAsmMemoryOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">SDValue</span> <span class="o">&amp;</span><span class="n">Op</span><span class="p">,</span> <span class="kt">char</span> <span class="n">ConstraintCode</span><span class="p">,</span>
                             <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutOps</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ConstraintCode</span> <span class="o">==</span> <span class="sc">&#39;m&#39;</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;unexpected asm memory constraint&quot;</span><span class="p">);</span>
  <span class="n">OutOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// createCpu0ISelDag - This pass converts a legalized DAG into a</span>
<span class="c1">/// CPU0-specific DAG, ready for instruction scheduling.</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0ISelDag</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Cpu0DAGToDAGISel</span><span class="p">(</span><span class="n">TM</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Chapter3_3 adding the following code in Cpu0InstInfo.cpp to enable debug
information which called by llvm at proper time.</p>
<p class="rubric">lbdex/Chapter3_3/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0InstrInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenInstrInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="n">MachineInstr</span><span class="o">*</span> <span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                                 <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">Offset</span><span class="p">,</span>
                                                 <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                                 <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_3/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MachineInstr</span><span class="o">*</span>
<span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">emitFrameIndexDebugValue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIx</span><span class="p">,</span>
                                        <span class="kt">uint64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="k">const</span> <span class="n">MDNode</span> <span class="o">*</span><span class="n">MDPtr</span><span class="p">,</span>
                                        <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstrBuilder</span> <span class="n">MIB</span> <span class="o">=</span> <span class="n">BuildMI</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">DBG_VALUE</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FrameIx</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">).</span><span class="n">addMetadata</span><span class="p">(</span><span class="n">MDPtr</span><span class="p">);</span>
  <span class="k">return</span> <span class="o">&amp;*</span><span class="n">MIB</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - emitFrameIndexDebugValue</span>
</pre></div>
</div>
<p>Build Chapter3_3 and run with it, finding the error message in Chapter3_2 is
gone. The new error message for Chapter3_3 as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc -o
ch3.cpu0.s
...
LLVM ERROR: Cannot <span class="k">select</span>: 0x7f80f182d310: <span class="nv">ch</span> <span class="o">=</span> &lt;&lt;Unknown Target Node <span class="c">#190&gt;&gt;</span>
...
  0x7f80f182d210: <span class="nv">i32</span> <span class="o">=</span> Register %LR <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>
</pre></div>
</div>
</div>
<div class="section" id="handle-return-register-lr">
<h2>Handle return register lr<a class="headerlink" href="#handle-return-register-lr" title="Permalink to this headline">¶</a></h2>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0 Pseudo Instructions Format</span>
<span class="k">class</span> <span class="nc">Cpu0Pseudo</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">list</span><span class="o">&lt;</span><span class="n">dag</span><span class="o">&gt;</span> <span class="n">pattern</span><span class="o">&gt;:</span>
      <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="n">pattern</span><span class="p">,</span> <span class="n">IIPseudo</span><span class="p">,</span> <span class="n">Pseudo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">isCodeGenOnly</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">isPseudo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">isReturn</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isTerminator</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hasDelaySlot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isBarrier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hasCtrlDep</span><span class="o">=</span><span class="mi">1</span> <span class="n">in</span>
  <span class="n">def</span> <span class="n">RetLR</span> <span class="o">:</span> <span class="n">Cpu0Pseudo</span><span class="o">&lt;</span><span class="p">(</span><span class="n">outs</span><span class="p">),</span> <span class="p">(</span><span class="n">ins</span><span class="p">),</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">Cpu0Ret</span><span class="p">)]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">/// Expand Pseudo instructions into real backend instructions</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">expandPostRAPseudo</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="nl">private:</span>
  <span class="kt">void</span> <span class="n">ExpandRetLR</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                   <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_4/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0InstrInfo::expandPostRAPseudo</span>
<span class="c1">/// Expand Pseudo instructions into real backend instructions</span>
<span class="kt">bool</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">expandPostRAPseudo</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span> <span class="o">=</span> <span class="o">*</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MI</span><span class="o">-&gt;</span><span class="n">getDesc</span><span class="p">().</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">RetLR</span><span class="o">:</span>
    <span class="n">ExpandRetLR</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MI</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">RET</span><span class="p">);</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">MBB</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">MI</span><span class="p">);</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">ExpandRetLR</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                                <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">(),</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">)).</span><span class="n">addReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>To handle IR ret, these code in Cpu0InstrInfo.td do things as below.</p>
<p>1. Declare a pseudo node Cpu0::RetLR to take care the IR Cpu0ISD::Ret by the
following code,</p>
<p class="rubric">lbdex/Chapter3_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Return</span>
<span class="n">def</span> <span class="n">Cpu0Ret</span> <span class="o">:</span> <span class="n">SDNode</span><span class="o">&lt;</span><span class="s">&quot;Cpu0ISD::Ret&quot;</span><span class="p">,</span> <span class="n">SDTNone</span><span class="p">,</span>
                     <span class="p">[</span><span class="n">SDNPHasChain</span><span class="p">,</span> <span class="n">SDNPOptInGlue</span><span class="p">,</span> <span class="n">SDNPVariadic</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">let</span> <span class="n">isReturn</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isTerminator</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hasDelaySlot</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">isBarrier</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">hasCtrlDep</span><span class="o">=</span><span class="mi">1</span> <span class="n">in</span>
  <span class="n">def</span> <span class="n">RetLR</span> <span class="o">:</span> <span class="n">Cpu0Pseudo</span><span class="o">&lt;</span><span class="p">(</span><span class="n">outs</span><span class="p">),</span> <span class="p">(</span><span class="n">ins</span><span class="p">),</span> <span class="s">&quot;&quot;</span><span class="p">,</span> <span class="p">[(</span><span class="n">Cpu0Ret</span><span class="p">)]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<ol class="arabic simple" start="2">
<li>Create Cpu0ISD::Ret node in LowerReturn() which is called when meet function
return as code in function LowerReturn() of Cpu0ISelLowering.cpp.</li>
<li>After instruction selection, the Cpu0::Ret is replaced by Cpu0::RetLR
as below. This effect came from &#8220;def RetLR&#8221; as step 1.</li>
</ol>
<div class="highlight-bash"><div class="highlight"><pre><span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;entry&#39;</span>
Selecting: 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x1ea3f50, 0x1ea3e50,
0x1ea3f50:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>27<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret
0x1ea3f50, 0x1ea3e50, 0x1ea3f50:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>27<span class="o">]</span>

  Morphed node: 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> RetLR 0x1ea3e50, 0x1ea3f50, 0x1ea3f50:1
...
ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> RetLR 0x1ea3e50, 0x1ea3f50, 0x1ea3f50:1
...
<span class="o">=====</span> Instruction selection ends:
Selected selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 28 nodes:
...
    0x1ea3e50: &lt;multiple use&gt;
    0x1ea3f50: &lt;multiple use&gt;
    0x1ea3f50: &lt;multiple use&gt;
  0x1ea4050: <span class="nv">ch</span> <span class="o">=</span> RetLR 0x1ea3e50, 0x1ea3f50, 0x1ea3f50:1
</pre></div>
</div>
<ol class="arabic simple" start="4">
<li>Expand the Cpu0::RetLR into instruction <strong>ret $lr</strong> in &#8220;Post-RA pseudo
instruction expansion pass&#8221; stage by the code in Chapter3_4/Cpu0InstrInfo.cpp
as above. This stage is after the register allocation, so we can replace the
V0 ($r2) by LR ($lr) without any side effect.</li>
<li>Print assembly or obj according the information (those *.inc generated by
TableGen from *.td) generated by the following code at &#8220;Cpu0 Assembly
Printer&#8221; stage.</li>
</ol>
<p class="rubric">lbdex/Chapter2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>
let isBranch=1, isTerminator=1, isBarrier=1, imm16=0, hasDelaySlot = 1,
    isIndirectBranch = 1 in
class JumpFR&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra),
     !strconcat(instr_asm, "\t$ra"), [(brind RC:$ra)], IIBranch&gt; {
  let rb = 0;
  let imm16 = 0;
}

// Return instruction
class RetBase&lt;RegisterClass RC&gt;: JumpFR&lt;0x3c, "ret", RC&gt; {
  let isReturn = 1;
  let isCodeGenOnly = 1;
  let hasCtrlDep = 1;
  let hasExtraSrcRegAllocReq = 1;
}
</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">RET</span>     <span class="o">:</span> <span class="n">RetBase</span><span class="o">&lt;</span><span class="n">GPROut</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<table border="1" class="docutils">
<caption>Handle return register lr</caption>
<colgroup>
<col width="56%" />
<col width="44%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Write Code</td>
<td>Declare a pseudo node Cpu0::RetLR</td>
</tr>
<tr class="row-odd"><td><ul class="first last simple">
<li></li>
</ul>
</td>
<td>for IR Cpu0::Ret;</td>
</tr>
<tr class="row-even"><td>Before CPU0 DAG-&gt;DAG Pattern Instruction Selection</td>
<td>Create Cpu0ISD::Ret DAG</td>
</tr>
<tr class="row-odd"><td>Instruction selection</td>
<td>Cpu0::Ret is replaced by Cpu0::RetLR</td>
</tr>
<tr class="row-even"><td>Post-RA pseudo instruction expansion pass</td>
<td>Cpu0::RetLR -&gt; ret $lr</td>
</tr>
<tr class="row-odd"><td>Cpu0 Assembly Printer</td>
<td>Print according &#8220;def RET&#8221;</td>
</tr>
</tbody>
</table>
<p>Build Chapter3_4 and run with it, finding the error message in Chapter3_3 is
gone. The new error message for Chapter3_4 as follows,</p>
<div class="highlight-bash"><pre>118-165-78-230:InputFiles Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march=cpu0 -relocation-model=pic -filetype=asm ch3.bc -o
ch3.cpu0.s
...
Target didn't implement TargetInstrInfo::storeRegToStackSlot!
...
1.  Running pass 'Function Pass Manager' on module 'ch3.bc'.
2.  Running pass 'Prologue/Epilogue Insertion &amp; Frame Finalization' on function
'@main' ...</pre>
</div>
</div>
<div class="section" id="add-prologue-epilogue-functions">
<h2>Add Prologue/Epilogue functions<a class="headerlink" href="#add-prologue-epilogue-functions" title="Permalink to this headline">¶</a></h2>
<p>Following came from tricore_llvm.pdf section “4.4.2 Non-static Register
Information ”.</p>
<p>For some target architectures, some aspects of the target architecture’s
register set are dependent upon variable factors and have to be determined at
runtime.
As a consequence, they cannot be generated statically from a TableGen
description – although that would be possible for the bulk of them in the case
of the TriCore backend.
Among them are the following points:</p>
<ul class="simple">
<li>Callee-saved registers. Normally, the ABI specifies a set of registers that a
function must save on entry and restore on return if their contents are
possibly modified during execution.</li>
<li>Reserved registers. Although the set of unavailable registers is already
defined in the TableGen file, TriCoreRegisterInfo contains a method that marks
all non-allocatable register numbers in a bit vector.</li>
</ul>
<p>The following methods are implemented:</p>
<ul class="simple">
<li>emitPrologue() inserts prologue code at the beginning of a function. Thanks
to TriCore’s context model, this is a trivial task as it is not required to
save any registers manually. The only thing that has to be done is reserving
space for the function’s stack frame by decrementing the stack pointer.
In addition, if the function needs a frame pointer, the frame register %a14 is
set to the old value of the stack pointer beforehand.</li>
<li>emitEpilogue() is intended to emit instructions to destroy the stack frame
and restore all previously saved registers before returning from a function.
However, as %a10 (stack pointer), %a11 (return address), and %a14 (frame
pointer, if any) are all part of the upper context, no epilogue code is needed
at all. All cleanup operations are performed implicitly by the ret instruction.</li>
<li>eliminateFrameIndex() is called for each instruction that references a word
of data in a stack slot. All previous passes of the code generator have been
addressing stack slots through an abstract frame index and an immediate offset.
The purpose of this function is to translate such a reference into a
register–offset pair. Depending on whether the machine function that contains
the instruction has a fixed or a variable stack frame, either the stack pointer
%a10 or the frame pointer %a14 is used as the base register.
The offset is computed accordingly.
<a class="pageref" href="#backendstructure-f10">Figure  10</a> demonstrates for both cases how a stack slot
is addressed.</li>
</ul>
<p>If the addressing mode of the affected instruction cannot handle the address
because the offset is too large (the offset field has 10 bits for the BO
addressing mode and 16 bits for the BOL mode), a sequence of instructions is
emitted that explicitly computes the effective address.
Interim results are put into an unused address register.
If none is available, an already occupied address register is scavenged.
For this purpose, LLVM’s framework offers a class named RegScavenger that
takes care of all the details.</p>
<div class="figure align-center" id="backendstructure-f10">
<img alt="_images/10.png" src="_images/10.png" />
<p class="caption">Figure 10: Addressing of a variable a located on the stack.
If the stack frame has a variable size, slot must be addressed relative to
the frame pointer</p>
</div>
<p>We will explain the Prologue and Epilogue further by example code.
So for the following llvm IR code, Cpu0 back end will emit the corresponding
machine instructions as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
  %1 <span class="o">=</span> alloca i32, align 4
  store i32 0, i32* %1
  ret i32 0
<span class="o">}</span>

  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main//static void expandLargeImm<span class="se">\\</span>n
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>LLVM get the stack size by parsing IR and counting how many virtual registers
is assigned to local variables. After that, it call emitPrologue().
This function will emit machine instructions to adjust sp (stack pointer
register) for local variables since we don&#8217;t use fp (frame pointer register).
For our example, it will emit the instructions,</p>
<div class="highlight-c++"><pre>addiu $sp, $sp, -8</pre>
</div>
<p>The  emitEpilogue will emit “addiu  $sp, $sp, 8”, where 8 is the stack size.</p>
<p>Since Instruction Selection and Register Allocation occurs before
Prologue/Epilogue Code Insertion, eliminateFrameIndex() is called after machine
instruction and real register allocated.
It translate the frame index of local variable (%1 and %2 in the following
example) into stack offset according the frame index order upward (stack grow
up downward from high address to low address, 0($sp) is the top, 52($sp) is the
bottom) as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>define i32 @main<span class="o">()</span> nounwind uwtable <span class="o">{</span>
     %1 <span class="o">=</span> alloca i32, align 4
     %2 <span class="o">=</span> alloca i32, align 4
    ...
    store i32 0, i32* %1
    store i32 5, i32* %2, align 4
    ...
    ret i32 <span class="nv">0</span>

<span class="o">=</span>&gt; <span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -56
<span class="nv">$tmp1</span>:
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$3</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %1 is the first frame index <span class="nb">local </span>variable, so allocate
                    // in 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>   // %2 is the second frame index <span class="nb">local </span>variable, so
                    // allocate in 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ...
  ret <span class="nv">$lr</span>
</pre></div>
</div>
<p>The Prologue and Epilogue functions as follows,</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">/// emitProlog/emitEpilog - These methods insert prolog and epilog code into</span>
  <span class="c1">/// the function.</span>
  <span class="kt">void</span> <span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="kt">void</span> <span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">processFunctionBeforeCalleeSavedScan</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                          <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0AnalyzeImmediate.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Build an instruction sequence to load an immediate that is too large to fit</span>
<span class="c1">// in 16-bit and add the result to Reg.</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">expandLargeImm</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Reg</span><span class="p">,</span> <span class="kt">int64_t</span> <span class="n">Imm</span><span class="p">,</span> 
                           <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">&amp;</span> <span class="n">MBB</span><span class="p">,</span>
                           <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">LUi</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZEROReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ATReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">;</span>
  <span class="n">Cpu0AnalyzeImmediate</span> <span class="n">AnalyzeImm</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Seq</span> <span class="o">=</span>
    <span class="n">AnalyzeImm</span><span class="p">.</span><span class="n">Analyze</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="mi">32</span><span class="p">,</span> <span class="nb">false</span> <span class="cm">/* LastInstrIsADDiu */</span><span class="p">);</span>
  <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">InstSeq</span><span class="o">::</span><span class="n">const_iterator</span> <span class="n">Inst</span> <span class="o">=</span> <span class="n">Seq</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>

  <span class="c1">// The first instruction can be a LUi, which is different from other</span>
  <span class="c1">// instructions (ADDiu, ORI and SLL) in that it does not have a register</span>
  <span class="c1">// operand.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">Opc</span> <span class="o">==</span> <span class="n">LUi</span><span class="p">)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">LUi</span><span class="p">),</span> <span class="n">ATReg</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">SignExtend64</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">ImmOpnd</span><span class="p">));</span>
  <span class="k">else</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">Opc</span><span class="p">),</span> <span class="n">ATReg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZEROReg</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">SignExtend64</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">ImmOpnd</span><span class="p">));</span>

  <span class="c1">// Build the remaining instructions in Seq.</span>
  <span class="k">for</span> <span class="p">(</span><span class="o">++</span><span class="n">Inst</span><span class="p">;</span> <span class="n">Inst</span> <span class="o">!=</span> <span class="n">Seq</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">Inst</span><span class="p">)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">Opc</span><span class="p">),</span> <span class="n">ATReg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ATReg</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="n">SignExtend64</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Inst</span><span class="o">-&gt;</span><span class="n">ImmOpnd</span><span class="p">));</span>

  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">II</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">Reg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ATReg</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - expandLargeImm</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span>   <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">front</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span>    <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span>
    <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0InstrInfo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">MBBI</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="n">MBBI</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">()</span> <span class="o">:</span> <span class="n">DebugLoc</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>
  <span class="c1">// First, compute final stack size.</span>
  <span class="kt">unsigned</span> <span class="n">StackAlign</span> <span class="o">=</span> <span class="n">getStackAlignment</span><span class="p">();</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">LocalVarAreaOffset</span> <span class="o">=</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getMaxCallFrameSize</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">StackSize</span> <span class="o">=</span>  <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">LocalVarAreaOffset</span><span class="p">,</span> <span class="n">StackAlign</span><span class="p">)</span> <span class="o">+</span>
     <span class="n">RoundUpToAlignment</span><span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">(),</span> <span class="n">StackAlign</span><span class="p">);</span>

   <span class="c1">// Update stack size</span>
  <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setStackSize</span><span class="p">(</span><span class="n">StackSize</span><span class="p">);</span>

  <span class="c1">// No need to allocate space on the stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">StackSize</span> <span class="o">==</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">adjustsStack</span><span class="p">())</span> <span class="k">return</span><span class="p">;</span>

  <span class="n">MachineModuleInfo</span> <span class="o">&amp;</span><span class="n">MMI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getMMI</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">MCRegisterInfo</span> <span class="o">*</span><span class="n">MRI</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">getRegisterInfo</span><span class="p">();</span>
  <span class="n">MachineLocation</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">;</span>

  <span class="c1">// Adjust stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="o">-</span><span class="n">StackSize</span><span class="p">))</span> <span class="c1">// addiu sp, sp, (-stacksize)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="o">-</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span> <span class="c1">// Expand immediate that doesn&#39;t fit in 16-bit.</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setEmitNOAT</span><span class="p">();</span>
    <span class="n">expandLargeImm</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="o">-</span><span class="n">StackSize</span><span class="p">,</span> <span class="n">TII</span><span class="p">,</span> <span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="c1">// emit &quot;.cfi_def_cfa_offset StackSize&quot;</span>
  <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">AdjustSPLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
          <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">AdjustSPLabel</span><span class="p">);</span>
  <span class="n">MMI</span><span class="p">.</span><span class="n">addFrameInst</span><span class="p">(</span>
      <span class="n">MCCFIInstruction</span><span class="o">::</span><span class="n">createDefCfaOffset</span><span class="p">(</span><span class="n">AdjustSPLabel</span><span class="p">,</span> <span class="o">-</span><span class="n">StackSize</span><span class="p">));</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="c1">// Find the instruction past the last instruction that saves a callee-saved</span>
    <span class="c1">// register to the stack.</span>
    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">++</span><span class="n">MBBI</span><span class="p">;</span>

    <span class="c1">// Iterate over list of callee-saved registers and emit .cfi_offset</span>
    <span class="c1">// directives.</span>
    <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">CSLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
            <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">CSLabel</span><span class="p">);</span>

    <span class="k">for</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;::</span><span class="n">const_iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span>
           <span class="n">E</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">E</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">int64_t</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getFrameIdx</span><span class="p">());</span>
      <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getReg</span><span class="p">();</span>
      <span class="p">{</span>
        <span class="c1">// Reg is in CPURegs.</span>
        <span class="n">MMI</span><span class="p">.</span><span class="n">addFrameInst</span><span class="p">(</span><span class="n">MCCFIInstruction</span><span class="o">::</span><span class="n">createOffset</span><span class="p">(</span>
            <span class="n">CSLabel</span><span class="p">,</span> <span class="n">MRI</span><span class="o">-&gt;</span><span class="n">getDwarfRegNum</span><span class="p">(</span><span class="n">Reg</span><span class="p">,</span> <span class="mi">1</span><span class="p">),</span> <span class="n">Offset</span><span class="p">));</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>
  
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">getLastNonDebugInstr</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span>            <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">Cpu0InstrInfo</span> <span class="o">&amp;</span><span class="n">TII</span> <span class="o">=</span>
    <span class="o">*</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="k">const</span> <span class="n">Cpu0InstrInfo</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getInstrInfo</span><span class="p">());</span>
  <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">MBBI</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">SP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">unsigned</span> <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// Get the number of bytes from FrameInfo</span>
  <span class="kt">uint64_t</span> <span class="n">StackSize</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">StackSize</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Adjust stack.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">StackSize</span><span class="p">))</span> <span class="c1">// addiu sp, sp, (stacksize)</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="n">StackSize</span><span class="p">);</span>
  <span class="k">else</span> <span class="p">{</span> <span class="c1">// Expand immediate that doesn&#39;t fit in 16-bit.</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setEmitNOAT</span><span class="p">();</span>
    <span class="n">expandLargeImm</span><span class="p">(</span><span class="n">SP</span><span class="p">,</span> <span class="n">StackSize</span><span class="p">,</span> <span class="n">TII</span><span class="p">,</span> <span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0AnalyzeImmediate.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0AnalyzeImmediate.h - Analyze Immediates ------------*- C++ -*--===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#ifndef CPU0_ANALYZE_IMMEDIATE_H</span>
<span class="cp">#define CPU0_ANALYZE_IMMEDIATE_H</span>

<span class="cp">#include &quot;llvm/ADT/SmallVector.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/DataTypes.h&quot;</span>

<span class="k">namespace</span> <span class="n">llvm</span> <span class="p">{</span>

  <span class="k">class</span> <span class="nc">Cpu0AnalyzeImmediate</span> <span class="p">{</span>
  <span class="nl">public:</span>
    <span class="k">struct</span> <span class="n">Inst</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="n">ImmOpnd</span><span class="p">;</span>
      <span class="n">Inst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Opc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">ImmOpnd</span><span class="p">);</span>
    <span class="p">};</span>
    <span class="k">typedef</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">Inst</span><span class="p">,</span> <span class="mi">7</span> <span class="o">&gt;</span> <span class="n">InstSeq</span><span class="p">;</span>

    <span class="c1">/// Analyze - Get an instrucion sequence to load immediate Imm. The last</span>
    <span class="c1">/// instruction in the sequence must be an ADDiu if LastInstrIsADDiu is</span>
    <span class="c1">/// true;</span>
    <span class="k">const</span> <span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Analyze</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">LastInstrIsADDiu</span><span class="p">);</span>
  <span class="nl">private:</span>
    <span class="k">typedef</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">InstSeq</span><span class="p">,</span> <span class="mi">5</span><span class="o">&gt;</span> <span class="n">InstSeqLs</span><span class="p">;</span>

    <span class="c1">/// AddInstr - Add I to all instruction sequences in SeqLs.</span>
    <span class="kt">void</span> <span class="nf">AddInstr</span><span class="p">(</span><span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Inst</span> <span class="o">&amp;</span><span class="n">I</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLsADDiu - Get instrucion sequences which end with an ADDiu to</span>
    <span class="c1">/// load immediate Imm</span>
    <span class="kt">void</span> <span class="nf">GetInstSeqLsADDiu</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLsORi - Get instrucion sequences which end with an ORi to</span>
    <span class="c1">/// load immediate Imm</span>
    <span class="kt">void</span> <span class="nf">GetInstSeqLsORi</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLsSHL - Get instrucion sequences which end with a SHL to</span>
    <span class="c1">/// load immediate Imm</span>
    <span class="kt">void</span> <span class="nf">GetInstSeqLsSHL</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// GetInstSeqLs - Get instrucion sequences to load immediate Imm.</span>
    <span class="kt">void</span> <span class="nf">GetInstSeqLs</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">);</span>

    <span class="c1">/// ReplaceADDiuSHLWithLUi - Replace an ADDiu &amp; SHL pair with a LUi.</span>
    <span class="kt">void</span> <span class="nf">ReplaceADDiuSHLWithLUi</span><span class="p">(</span><span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Seq</span><span class="p">);</span>

    <span class="c1">/// GetShortestSeq - Find the shortest instruction sequence in SeqLs and</span>
    <span class="c1">/// return it in Insts.</span>
    <span class="kt">void</span> <span class="nf">GetShortestSeq</span><span class="p">(</span><span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Insts</span><span class="p">);</span>

    <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">;</span>
    <span class="kt">unsigned</span> <span class="n">ADDiu</span><span class="p">,</span> <span class="n">ORi</span><span class="p">,</span> <span class="n">SHL</span><span class="p">,</span> <span class="n">LUi</span><span class="p">;</span>
    <span class="n">InstSeq</span> <span class="n">Insts</span><span class="p">;</span>
  <span class="p">};</span>
<span class="p">}</span>

<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0AnalyzeImmediate.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0AnalyzeImmediate.cpp - Analyze Immediates ---------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="cp">#include &quot;Cpu0AnalyzeImmediate.h&quot;</span>
<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/MathExtras.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">Inst</span><span class="o">::</span><span class="n">Inst</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">O</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">I</span><span class="p">)</span> <span class="o">:</span> <span class="n">Opc</span><span class="p">(</span><span class="n">O</span><span class="p">),</span> <span class="n">ImmOpnd</span><span class="p">(</span><span class="n">I</span><span class="p">)</span> <span class="p">{}</span>

<span class="c1">// Add I to the instruction sequences.</span>
<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">AddInstr</span><span class="p">(</span><span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">,</span> <span class="k">const</span> <span class="n">Inst</span> <span class="o">&amp;</span><span class="n">I</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Add an instruction seqeunce consisting of just I.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">SeqLs</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">SeqLs</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">InstSeq</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">I</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">InstSeqLs</span><span class="o">::</span><span class="n">iterator</span> <span class="n">Iter</span> <span class="o">=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">Iter</span> <span class="o">!=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">Iter</span><span class="p">)</span>
    <span class="n">Iter</span><span class="o">-&gt;</span><span class="n">push_back</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                             <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GetInstSeqLs</span><span class="p">((</span><span class="n">Imm</span> <span class="o">+</span> <span class="mh">0x8000ULL</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffff0000ULL</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">,</span> <span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffffULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLsORi</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                           <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffffffffffff0000ULL</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">ORi</span><span class="p">,</span> <span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffffULL</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLsSHL</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                           <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">Shamt</span> <span class="o">=</span> <span class="n">countTrailingZeros</span><span class="p">(</span><span class="n">Imm</span><span class="p">);</span>
  <span class="n">GetInstSeqLs</span><span class="p">(</span><span class="n">Imm</span> <span class="o">&gt;&gt;</span> <span class="n">Shamt</span><span class="p">,</span> <span class="n">RemSize</span> <span class="o">-</span> <span class="n">Shamt</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">SHL</span><span class="p">,</span> <span class="n">Shamt</span><span class="p">));</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetInstSeqLs</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">RemSize</span><span class="p">,</span>
                                        <span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">uint64_t</span> <span class="n">MaskedImm</span> <span class="o">=</span> <span class="n">Imm</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mh">0xffffffffffffffffULL</span> <span class="o">&gt;&gt;</span> <span class="p">(</span><span class="mi">64</span> <span class="o">-</span> <span class="n">Size</span><span class="p">));</span>

  <span class="c1">// Do nothing if Imm is 0.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MaskedImm</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// A single ADDiu will do if RemSize &lt;= 16.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RemSize</span> <span class="o">&lt;=</span> <span class="mi">16</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">AddInstr</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Inst</span><span class="p">(</span><span class="n">ADDiu</span><span class="p">,</span> <span class="n">MaskedImm</span><span class="p">));</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">// Shift if the lower 16-bit is cleared.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="p">(</span><span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">GetInstSeqLsSHL</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
    <span class="k">return</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>

  <span class="c1">// If bit 15 is cleared, it doesn&#39;t make a difference whether the last</span>
  <span class="c1">// instruction is an ADDiu or ORi. In that case, do not call GetInstSeqLsORi.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Imm</span> <span class="o">&amp;</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">InstSeqLs</span> <span class="n">SeqLsORi</span><span class="p">;</span>
    <span class="n">GetInstSeqLsORi</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">RemSize</span><span class="p">,</span> <span class="n">SeqLsORi</span><span class="p">);</span>
    <span class="n">SeqLs</span><span class="p">.</span><span class="n">insert</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">.</span><span class="n">end</span><span class="p">(),</span> <span class="n">SeqLsORi</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">SeqLsORi</span><span class="p">.</span><span class="n">end</span><span class="p">());</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="c1">// Replace a ADDiu &amp; SHL pair with a LUi.</span>
<span class="c1">// e.g. the following two instructions</span>
<span class="c1">//  ADDiu 0x0111</span>
<span class="c1">//  SHL 18</span>
<span class="c1">// are replaced with</span>
<span class="c1">//  LUi 0x444</span>
<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">ReplaceADDiuSHLWithLUi</span><span class="p">(</span><span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Seq</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Check if the first two instructions are ADDiu and SHL and the shift amount</span>
  <span class="c1">// is at least 16.</span>
  <span class="k">if</span> <span class="p">((</span><span class="n">Seq</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">Seq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Opc</span> <span class="o">!=</span> <span class="n">ADDiu</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">Seq</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">Opc</span> <span class="o">!=</span> <span class="n">SHL</span><span class="p">)</span> <span class="o">||</span> <span class="p">(</span><span class="n">Seq</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ImmOpnd</span> <span class="o">&lt;</span> <span class="mi">16</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Sign-extend and shift operand of ADDiu and see if it still fits in 16-bit.</span>
  <span class="kt">int64_t</span> <span class="n">Imm</span> <span class="o">=</span> <span class="n">SignExtend64</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Seq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ImmOpnd</span><span class="p">);</span>
  <span class="kt">int64_t</span> <span class="n">ShiftedImm</span> <span class="o">=</span> <span class="p">(</span><span class="kt">uint64_t</span><span class="p">)</span><span class="n">Imm</span> <span class="o">&lt;&lt;</span> <span class="p">(</span><span class="n">Seq</span><span class="p">[</span><span class="mi">1</span><span class="p">].</span><span class="n">ImmOpnd</span> <span class="o">-</span> <span class="mi">16</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">ShiftedImm</span><span class="p">))</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Replace the first instruction and erase the second.</span>
  <span class="n">Seq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">Opc</span> <span class="o">=</span> <span class="n">LUi</span><span class="p">;</span>
  <span class="n">Seq</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">ImmOpnd</span> <span class="o">=</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)(</span><span class="n">ShiftedImm</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">);</span>
  <span class="n">Seq</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">Seq</span><span class="p">.</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">GetShortestSeq</span><span class="p">(</span><span class="n">InstSeqLs</span> <span class="o">&amp;</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">InstSeq</span> <span class="o">&amp;</span><span class="n">Insts</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">InstSeqLs</span><span class="o">::</span><span class="n">iterator</span> <span class="n">ShortestSeq</span> <span class="o">=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="c1">// The length of an instruction sequence is at most 7.</span>
  <span class="kt">unsigned</span> <span class="n">ShortestLength</span> <span class="o">=</span> <span class="mi">8</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">InstSeqLs</span><span class="o">::</span><span class="n">iterator</span> <span class="n">S</span> <span class="o">=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span> <span class="n">S</span> <span class="o">!=</span> <span class="n">SeqLs</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">ReplaceADDiuSHLWithLUi</span><span class="p">(</span><span class="o">*</span><span class="n">S</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;=</span> <span class="mi">7</span><span class="p">);</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;</span> <span class="n">ShortestLength</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">ShortestSeq</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
      <span class="n">ShortestLength</span> <span class="o">=</span> <span class="n">S</span><span class="o">-&gt;</span><span class="n">size</span><span class="p">();</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="n">Insts</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
  <span class="n">Insts</span><span class="p">.</span><span class="n">append</span><span class="p">(</span><span class="n">ShortestSeq</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">(),</span> <span class="n">ShortestSeq</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">());</span>
<span class="p">}</span>

<span class="k">const</span> <span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">InstSeq</span>
<span class="o">&amp;</span><span class="n">Cpu0AnalyzeImmediate</span><span class="o">::</span><span class="n">Analyze</span><span class="p">(</span><span class="kt">uint64_t</span> <span class="n">Imm</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">Size</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="n">LastInstrIsADDiu</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">this</span><span class="o">-&gt;</span><span class="n">Size</span> <span class="o">=</span> <span class="n">Size</span><span class="p">;</span>

  <span class="n">ADDiu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">;</span>
  <span class="n">ORi</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">;</span>
  <span class="n">SHL</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SHL</span><span class="p">;</span>
  <span class="n">LUi</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">;</span>

  <span class="n">InstSeqLs</span> <span class="n">SeqLs</span><span class="p">;</span>

  <span class="c1">// Get the list of instruction sequences.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LastInstrIsADDiu</span> <span class="o">|</span> <span class="o">!</span><span class="n">Imm</span><span class="p">)</span>
    <span class="n">GetInstSeqLsADDiu</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="nf">GetInstSeqLs</span><span class="p">(</span><span class="n">Imm</span><span class="p">,</span> <span class="n">Size</span><span class="p">,</span> <span class="n">SeqLs</span><span class="p">);</span>

  <span class="c1">// Set Insts to the shortest instruction sequence.</span>
  <span class="n">GetShortestSeq</span><span class="p">(</span><span class="n">SeqLs</span><span class="p">,</span> <span class="n">Insts</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">Insts</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- If no eliminateFrameIndex(), it will hang on run. </span>
<span class="c1">// pure virtual method</span>
<span class="c1">// FrameIndex represent objects inside a abstract stack.</span>
<span class="c1">// We must replace FrameIndex with an stack/frame pointer</span>
<span class="c1">// direct reference.</span>
<span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">FIOperandNum</span><span class="p">,</span> <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineInstr</span> <span class="o">&amp;</span><span class="n">MI</span> <span class="o">=</span> <span class="o">*</span><span class="n">II</span><span class="p">;</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MI</span><span class="p">.</span><span class="n">getParent</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="k">while</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">isFI</span><span class="p">())</span> <span class="p">{</span>
    <span class="o">++</span><span class="n">i</span><span class="p">;</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">i</span> <span class="o">&lt;</span> <span class="n">MI</span><span class="p">.</span><span class="n">getNumOperands</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
           <span class="s">&quot;Instr doesn&#39;t have FrameIndex operand!&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">Function : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getName</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">;</span>
        <span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="n">MI</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">FrameIndex</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">getIndex</span><span class="p">();</span>
  <span class="kt">uint64_t</span> <span class="n">stackSize</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getStackSize</span><span class="p">();</span>
  <span class="kt">int64_t</span> <span class="n">spOffset</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">);</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;FrameIndex : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">FrameIndex</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;spOffset   : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">spOffset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span>
               <span class="o">&lt;&lt;</span> <span class="s">&quot;stackSize  : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">stackSize</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">CalleeSavedInfo</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">CSI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">MinCSFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MinCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
    <span class="n">MaxCSFI</span> <span class="o">=</span> <span class="n">CSI</span><span class="p">[</span><span class="n">CSI</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">].</span><span class="n">getFrameIdx</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="c1">// The following stack frame objects are always referenced relative to $sp:</span>
  <span class="c1">//  1. Outgoing arguments.</span>
  <span class="c1">//  2. Pointer to dynamically allocated stack space.</span>
  <span class="c1">//  3. Locations for callee-saved registers.</span>
  <span class="c1">// Everything else is referenced relative to whatever register</span>
  <span class="c1">// getFrameRegister() returns.</span>
  <span class="kt">unsigned</span> <span class="n">FrameReg</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">FrameIndex</span> <span class="o">&gt;=</span> <span class="n">MinCSFI</span> <span class="o">&amp;&amp;</span> <span class="n">FrameIndex</span> <span class="o">&lt;=</span> <span class="n">MaxCSFI</span><span class="p">))</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>

  <span class="c1">// Calculate final offset.</span>
  <span class="c1">// - There is no need to change the offset if the frame object is one of the</span>
  <span class="c1">//   following: an outgoing argument, pointer to a dynamically allocated</span>
  <span class="c1">//   stack space or a $gp restore location,</span>
  <span class="c1">// - If the frame object is any of the following, its offset must be adjusted</span>
  <span class="c1">//   by adding the size of the stack:</span>
  <span class="c1">//   incoming argument, callee-saved register location or local variable.</span>
  <span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">stackSize</span><span class="p">;</span>

  <span class="n">Offset</span>    <span class="o">+=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>

  <span class="n">DEBUG</span><span class="p">(</span><span class="n">errs</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;Offset     : &quot;</span> <span class="o">&lt;&lt;</span> <span class="n">Offset</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;</span><span class="se">\n</span><span class="s">&quot;</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;&lt;---------&gt;</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>

  <span class="c1">// If MI is not a debug value, make sure Offset fits in the 16-bit immediate</span>
  <span class="c1">// field.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MI</span><span class="p">.</span><span class="n">isDebugValue</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
	<span class="n">assert</span><span class="p">(</span><span class="s">&quot;(!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset))&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="p">).</span><span class="n">ChangeToRegister</span><span class="p">(</span><span class="n">FrameReg</span><span class="p">,</span> <span class="nb">false</span><span class="p">);</span>
  <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">ChangeToImmediate</span><span class="p">(</span><span class="n">Offset</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">// pure virtual method</span>
</pre></div>
</div>
<p>Add these instructions to Cpu0InstrInfo.td which used in Prologue and Epilogue
functions.</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def shamt       : Operand&lt;i32&gt;;

// Unsigned Operand
def uimm16      : Operand&lt;i32&gt; {
  let PrintMethod = "printUnsignedImm";
}
...
// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
  return getImm(N, N-&gt;getZExtValue() &amp; 0xffff);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xffff);
}]&gt;; // lbd document - mark - def HI16
...
// Node immediate fits as 16-bit zero extended on target immediate.
// The LO16 param means that only the lower 16 bits of the node
// immediate are caught.
// e.g. addiu, sltiu
def immZExt16  : PatLeaf&lt;(imm), [{
  if (N-&gt;getValueType(0) == MVT::i32)
    return (uint32_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
  else
    return (uint64_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
}], LO16&gt;;

// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
def immLow16Zero : PatLeaf&lt;(imm), [{
  int64_t Val = N-&gt;getSExtValue();
  return isInt&lt;32&gt;(Val) &amp;&amp; !(Val &amp; 0xffff);
}]&gt;;

// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;
...
// Arithmetic and logical instructions with 3 register operands.
class ArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set GPROut:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;  // e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
...
// Shifts
class shift_rotate_imm&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
                       RegisterClass RC&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, ImmOpnd:$shamt),
     !strconcat(instr_asm, "\t$ra, $rb, $shamt"),
     [(set GPROut:$ra, (OpNode RC:$rb, PF:$shamt))], IIAlu&gt; {
  let rc = 0;
  let shamt = shamt;
}

// 32-bit shift instructions.
class shift_rotate_imm32&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                         SDNode OpNode&gt;:
  shift_rotate_imm&lt;op, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs&gt;;

// Load Upper Imediate
class LoadUpper&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC, Operand Imm&gt;:
  FL&lt;op, (outs RC:$ra), (ins Imm:$imm16),
     !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu&gt; {
  let rb = 0;
  let neverHasSideEffects = 1;
  let isReMaterializable = 1;
} // lbd document - mark - class LoadUpper
...
def ORi     : ArithLogicI&lt;0x0d, "ori", or, uimm16, immZExt16, CPURegs&gt;;
def LUi     : LoadUpper&lt;0x0f, "lui", CPURegs, uimm16&gt;;

/// Arithmetic Instructions (3-Operand, R-Type)
def ADDu    : ArithLogicR&lt;0x11, "addu", add, IIAlu, CPURegs, 1&gt;;

/// Shift Instructions
def SHL     : shift_rotate_imm32&lt;0x1e, 0x00, "shl", shl&gt;;
...
def : Pat&lt;(i32 immZExt16:$in),
          (ORi ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immLow16Zero:$in),
          (LUi (HI16 imm:$in))&gt;;

// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
          (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</pre>
</div>
<p class="rubric">lbdex/Chapter3_5/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(...</span>
  <span class="p">...</span>
  <span class="n">Cpu0AnalyzeImmediate</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p>After add these Prologue and Epilogue functions, and build with Chapter3_5/.
Now we are ready to compile our example code ch3.bc into cpu0 assembly code.
Following is the command and output file ch3.cpu0.s,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
  ...
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch3.bc&quot;</span>
  .text
  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp2</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>To see how the <strong>&#8216;DAG-&gt;DAG Pattern Instruction Selection&#8217;</strong> work in llc, let&#8217;s
compile with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> option and see what happens.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
Args: /Users/Jonathan/llvm/test/cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0
-relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3.bc -o -
...
Optimized legalized selection DAG: BB#0 <span class="s1">&#39;main:&#39;</span>
SelectionDAG has 8 nodes:
  0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

  0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>

      0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

      0x7fbe4082d010: &lt;multiple use&gt;
      0x7fbe4082d110: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>

      0x7fbe4082d210: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>3<span class="o">]</span>

    0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668, 0x7fbe4082d010, 0x7fbe4082d110,
    0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

    0x7fbe4082d410: &lt;multiple use&gt;
    0x7fbe4082d010: &lt;multiple use&gt;
  0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
  0x7fbe4082d010 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

    0x7fbe4082d510: &lt;multiple use&gt;
    0x7fbe4082d410: &lt;multiple use&gt;
    0x7fbe4082d510: &lt;multiple use&gt;
  0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fbe4082d510, 0x7fbe4082d410,
  0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>


<span class="o">=====</span> Instruction selection begins: BB#0 <span class="s1">&#39;&#39;</span>
Selecting: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret 0x7fbe4082d510, 0x7fbe4082d410,
0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> Cpu0ISD::Ret
0x7fbe4082d510, 0x7fbe4082d410, 0x7fbe4082d510:1 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>7<span class="o">]</span>

  Morphed node: 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> RET 0x7fbe4082d410, 0x7fbe4082d510,
  0x7fbe4082d510:1

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d610: <span class="nv">ch</span> <span class="o">=</span> RET 0x7fbe4082d410, 0x7fbe4082d510, 0x7fbe4082d510:1

Selecting: 0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
0x7fbe4082d010 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>6<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe4082d510: ch,glue <span class="o">=</span> CopyToReg 0x7fbe4082d310, 0x7fbe4082d410,
0x7fbe4082d010

Selecting: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668, 0x7fbe4082d010,
0x7fbe4082d110, 0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> store 0x7fbe40410668,
0x7fbe4082d010, 0x7fbe4082d110, 0x7fbe4082d210&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>5<span class="o">]</span>

  Initial Opcode index to 166
  Morphed node: 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> ST 0x7fbe4082d010, 0x7fbe4082d710,
  0x7fbe4082d810, 0x7fbe40410668&lt;Mem:ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d310: <span class="nv">ch</span> <span class="o">=</span> ST 0x7fbe4082d010, 0x7fbe4082d710, 0x7fbe4082d810,
0x7fbe40410668&lt;Mem:ST4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

Selecting: 0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>4<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe4082d410: <span class="nv">i32</span> <span class="o">=</span> Register %V0

Selecting: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Starting pattern match on root node: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span>
Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>1<span class="o">]</span>

  Initial Opcode index to 1201
  Morphed node: 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbe4082d110, 0x7fbe4082d810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

ISEL: Match <span class="nb">complete</span>!
<span class="o">=</span>&gt; 0x7fbe4082d010: <span class="nv">i32</span> <span class="o">=</span> ADDiu 0x7fbe4082d110, 0x7fbe4082d810 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

Selecting: 0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>0<span class="o">]</span>

<span class="o">=</span>&gt; 0x7fbe40410668: <span class="nv">ch</span> <span class="o">=</span> EntryToken <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

<span class="o">=====</span> Instruction selection ends:
</pre></div>
</div>
<p>Summary above translation into Table: Chapter 3 .bc IR instructions.</p>
<table border="1" class="docutils">
<caption>Chapter 3 .bc IR instructions</caption>
<colgroup>
<col width="40%" />
<col width="47%" />
<col width="14%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">.bc</th>
<th class="head">Optimized legalized selection DAG</th>
<th class="head">Cpu0</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>constant 0</td>
<td>constant 0</td>
<td>addiu</td>
</tr>
<tr class="row-odd"><td>store</td>
<td>store</td>
<td>st</td>
</tr>
<tr class="row-even"><td>ret</td>
<td>Cpu0ISD::Ret</td>
<td>ret</td>
</tr>
</tbody>
</table>
<p>From above <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug</span></tt> display, we see the <strong>store</strong> and <strong>ret</strong> are
translated into <strong>store</strong> and <strong>Cpu0ISD::Ret</strong> in stage Optimized legalized
selection DAG, and then translated into Cpu0 instructions <strong>st</strong> and <strong>ret</strong>
finally.
Since store use <strong>constant 0</strong> (<strong>store i32 0, i32* %1</strong> in this example), the
constant 0 will be translated into <strong>&#8220;addiu $2, $zero, 0&#8221;</strong> via the following
pattern defined in Cpu0InstrInfo.td.</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Small immediates
def : Pat&lt;(i32 immSExt16:$in),
          (ADDiu ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immZExt16:$in),
          (ORi ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immLow16Zero:$in),
          (LUi (HI16 imm:$in))&gt;;

// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
          (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</pre>
</div>
<p>At this point, we have translated the very simple main() function with return 0
single instruction. The Cpu0AnalyzeImmediate.cpp defined as above and the
Cpu0InstrInfo.td instructions add as below, which takes care
the 32 bits stack size adjustments.</p>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def shamt       : Operand&lt;i32&gt;;

// Unsigned Operand
def uimm16      : Operand&lt;i32&gt; {
  let PrintMethod = "printUnsignedImm";
}
...
// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
  return getImm(N, N-&gt;getZExtValue() &amp; 0xffff);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xffff);
}]&gt;;
...
// Node immediate fits as 16-bit zero extended on target immediate.
// The LO16 param means that only the lower 16 bits of the node
// immediate are caught.
// e.g. addiu, sltiu
def immZExt16  : PatLeaf&lt;(imm), [{
  if (N-&gt;getValueType(0) == MVT::i32)
    return (uint32_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
  else
    return (uint64_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
}], LO16&gt;;

// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
def immLow16Zero : PatLeaf&lt;(imm), [{
  int64_t Val = N-&gt;getSExtValue();
  return isInt&lt;32&gt;(Val) &amp;&amp; !(Val &amp; 0xffff);
}]&gt;;

// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;
...
// Arithmetic and logical instructions with 3 register operands.
class ArithLogicR&lt;bits&lt;8&gt; op, string instr_asm, SDNode OpNode,
                  InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set RC:$ra, (OpNode RC:$rb, RC:$rc))], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;  // e.g. add rb rc =  add rc rb
  let isReMaterializable = 1;
}
...

// Shifts
class shift_rotate_imm&lt;bits&lt;8&gt; op, bits&lt;4&gt; isRotate, string instr_asm,
                       SDNode OpNode, PatFrag PF, Operand ImmOpnd,
                       RegisterClass RC&gt;:
  FA&lt;op, (outs RC:$ra), (ins RC:$rb, ImmOpnd:$shamt),
     !strconcat(instr_asm, "\t$ra, $rb, $shamt"),
     [(set RC:$ra, (OpNode RC:$rb, PF:$shamt))], IIAlu&gt; {
  let rc = isRotate;
  let shamt = shamt;
}

// 32-bit shift instructions.
class shift_rotate_imm32&lt;bits&lt;8&gt; func, bits&lt;4&gt; isRotate, string instr_asm,
                         SDNode OpNode&gt;:
  shift_rotate_imm&lt;func, isRotate, instr_asm, OpNode, immZExt5, shamt, CPURegs&gt;;

// Load Upper Imediate
class LoadUpper&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC, Operand Imm&gt;:
  FL&lt;op, (outs RC:$ra), (ins Imm:$imm16),
     !strconcat(instr_asm, "\t$ra, $imm16"), [], IIAlu&gt; {
  let rb = 0;
  let neverHasSideEffects = 1;
  let isReMaterializable = 1;
}
...
def ORi     : ArithLogicI&lt;0x0d, "ori", or, uimm16, immZExt16, CPURegs&gt;;
def LUi     : LoadUpper&lt;0x0f, "lui", CPURegs, uimm16&gt;;

/// Arithmetic Instructions (3-Operand, R-Type)
def ADDu    : ArithLogicR&lt;0x11, "addu", add, IIAlu, CPURegs, 1&gt;;

/// Shift Instructions
def SHL     : shift_rotate_imm32&lt;0x1e, 0x00, "shl", shl&gt;;
...

// Small immediates
...
def : Pat&lt;(i32 immZExt16:$in),
          (ORi ZERO, imm:$in)&gt;;
def : Pat&lt;(i32 immLow16Zero:$in),
          (LUi (HI16 imm:$in))&gt;;

// Arbitrary immediates
def : Pat&lt;(i32 imm:$imm),
          (ORi (LUi (HI16 imm:$imm)), (LO16 imm:$imm))&gt;;</pre>
</div>
<p>The Cpu0AnalyzeImmediate.cpp written in recursive with a little complicate in
logic. Anyway, the recursive
skills is used in the front end compile book, you should fimiliar with it.
Instead tracking the code, listing the stack size and the instructions
generated in Table: Cpu0 stack adjustment instructions before replace addiu and
shl with lui instruction as follows (Cpu0 stack adjustment instructions after
replace addiu and shl with lui instruction as below),</p>
<table border="1" class="docutils">
<caption>Cpu0 stack adjustment instructions before replace addiu and shl with lui instruction</caption>
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stack size range</th>
<th class="head">ex. stack size</th>
<th class="head">Cpu0 Prologue instructions</th>
<th class="head">Cpu0 Epilogue instructions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0 ~ 0x7ff8</td>
<td><ul class="first last simple">
<li>0x7ff8</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, -32760;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, 32760;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>0x8000 ~ 0xfff8</td>
<td><ul class="first last simple">
<li>0x8000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, -32768;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 1;</li>
<li>shl $1, $1, 16;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>x10000 ~ 0xfffffff8</td>
<td><ul class="first last simple">
<li>0x7ffffff8</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 8;</li>
<li>shl $1, $1, 28;</li>
<li>addiu $1, $1, 8;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, 8;</li>
<li>shl $1, $1, 28;</li>
<li>addiu $1, $1, -8;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>x10000 ~ 0xfffffff8</td>
<td><ul class="first last simple">
<li>0x90008000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -9;</li>
<li>shl $1, $1, 28;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $1, $zero, -28671;</li>
<li>shl $1, $1, 16</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Since the Cpu0 stack is 8 bytes alignment, the 0x7ff9 to 0x7fff is impossible
existing.</p>
<p>Assume sp = 0xa0008000 and stack size = 0x90008000, then (0xa0008000 -
0x90008000) =&gt; 0x10000000. Verify with the Cpu0 Prologue instructions as
follows,</p>
<ol class="arabic simple">
<li>&#8220;addiu       $1, $zero, -9&#8221; =&gt; ($1 = 0 + 0xfffffff7) =&gt; $1 = 0xfffffff7.</li>
<li>&#8220;shl $1, $1, 28;&#8221; =&gt; $1 = 0x70000000.</li>
<li>&#8220;addiu       $1, $1, -32768&#8221; =&gt; $1 = (0x70000000 + 0xffff8000) =&gt; $1 = 0x6fff8000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0xa0008000 + 0x6fff8000) =&gt; $sp = 0x10000000.</li>
</ol>
<p>Verify with the Cpu0 Epilogue instructions with sp = 0x10000000 and stack size =
0x90008000 as follows,</p>
<ol class="arabic simple">
<li>&#8220;addiu       $1, $zero, -28671&#8221; =&gt; ($1 = 0 + 0xffff9001) =&gt; $1 = 0xffff9001.</li>
<li>&#8220;shl $1, $1, 16;&#8221; =&gt; $1 = 0x90010000.</li>
<li>&#8220;addiu       $1, $1, -32768&#8221; =&gt; $1 = (0x90010000 + 0xffff8000) =&gt; $1 = 0x90008000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0x10000000 + 0x90008000) =&gt; $sp = 0xa0008000.</li>
</ol>
<p>The Cpu0AnalyzeImmediate::GetShortestSeq() will call Cpu0AnalyzeImmediate::
ReplaceADDiuSHLWithLUi() to replace addiu and shl with single instruction lui
only. The effect as the following table.</p>
<table border="1" class="docutils">
<caption>Cpu0 stack adjustment instructions after replace addiu and shl with lui instruction</caption>
<colgroup>
<col width="19%" />
<col width="15%" />
<col width="33%" />
<col width="33%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">stack size range</th>
<th class="head">ex. stack size</th>
<th class="head">Cpu0 Prologue instructions</th>
<th class="head">Cpu0 Epilogue instructions</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>0x8000 ~ 0xfff8</td>
<td><ul class="first last simple">
<li>0x8000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>addiu $sp, $sp, -32768;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>ori     $1, $zero, 32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>x10000 ~ 0xfffffff8</td>
<td><ul class="first last simple">
<li>0x7ffffff8</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lui $1, 32768;</li>
<li>addiu $1, $1, 8;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lui     $1, 32767;</li>
<li>ori     $1, $1, 65528</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>x10000 ~ 0xfffffff8</td>
<td><ul class="first last simple">
<li>0x90008000</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lui $1, 28671;</li>
<li>ori $1, $1, 32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
<td><ul class="first last simple">
<li>lui $1, 36865;</li>
<li>addiu $1, $1, -32768;</li>
<li>addu $sp, $sp, $1;</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>Assume sp = 0xa0008000 and stack size = 0x90008000, then (0xa0008000 -
0x90008000) =&gt; 0x10000000. Verify with the Cpu0 Prologue instructions as
follows,</p>
<ol class="arabic simple">
<li>&#8220;lui $1, 28671&#8221; =&gt; $1 = 0x6fff0000.</li>
<li>&#8220;ori $1, $1, 32768&#8221; =&gt; $1 = (0x6fff0000 + 0x00008000) =&gt; $1 = 0x6fff8000.</li>
<li>&#8220;addu        $sp, $sp, $1&#8221; =&gt; $sp = (0xa0008000 + 0x6fff8000) =&gt; $sp = 0x10000000.</li>
</ol>
<p>Verify with the Cpu0 Epilogue instructions with sp = 0x10000000 and stack size =
0x90008000 as follows,</p>
<ol class="arabic simple">
<li>&#8220;lui $1, 36865&#8221; =&gt; $1 = 0x90010000.</li>
<li>&#8220;addiu $1, $1, -32768&#8221; =&gt; $1 = (0x90010000 + 0xffff8000) =&gt; $1 = 0x90008000.</li>
<li>&#8220;addu $sp, $sp, $1&#8221; =&gt; $sp = (0x10000000 + 0x90008000) =&gt; $sp = 0xa0008000.</li>
</ol>
</div>
<div class="section" id="lowerreturn">
<h2>LowerReturn<a class="headerlink" href="#lowerreturn" title="Permalink to this headline">¶</a></h2>
<p class="rubric">lbdex/InputFiles/ch3_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">5</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">b</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>      <span class="c1">// c = 7</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="n">b</span> <span class="o">+</span> <span class="mi">1</span><span class="p">;</span>      <span class="c1">// d = 3</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">c</span><span class="o">+</span><span class="n">d</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter3_5 with ch3_2.cpp will get the following incorrect result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch3_2.cpp -emit-llvm -o ch3_2.bc
118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3_2.bc
-o -
  ...
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch3_2.bc&quot;</span>
        .text
        .globl        main
        .align        2
        .type main,@function
        .ent  main                    <span class="c"># @main</span>
main:
        .frame        <span class="nv">$fp</span>,24,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
        st    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 2
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>  // <span class="nv">$2</span> is 1
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  main
<span class="nv">$tmp1</span>:
        .size main, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-main
</pre></div>
</div>
<p>To correct the return value, the following code add to Chapter3_6.</p>
<p class="rubric">lbdex/Chapter3_6/Cpu0CallingConv.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">RetCC_Cpu0EABI</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="c1">// i32 are returned in registers V0, V1, A0, A1</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToReg</span><span class="o">&lt;</span><span class="p">[</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">]</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">RetCC_Cpu0</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="n">CCDelegateTo</span><span class="o">&lt;</span><span class="n">RetCC_Cpu0EABI</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span> <span class="c1">// lbd document - mark - def RetCC_Cpu0</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_6/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span><span class="p">,</span>
                                 <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                                 <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="k">virtual</span> <span class="kt">void</span> <span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span><span class="p">,</span>
                                  <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_6/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- st SrcReg, MMO(FI)</span>
<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span>
<span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - storeRegToStackSlot</span>

<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span> <span class="c1">// lbd document - mark - before loadRegFromStackSlot</span>
<span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                     <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - loadRegFromStackSlot</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_6/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                                <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

  <span class="c1">// CCValAssign - represent the assignment of</span>
  <span class="c1">// the return value to a location</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>

  <span class="c1">// CCState - Info about the registers and stack slot.</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
		 <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">RVLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>

  <span class="c1">// Analize return values.</span>
  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeReturn</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">RetCC_Cpu0</span><span class="p">);</span>

  <span class="n">SDValue</span> <span class="n">Flag</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">RetOps</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>

  <span class="c1">// Copy the result values into the output registers.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isRegLoc</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Can only return in registers!&quot;</span><span class="p">);</span>

    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocReg</span><span class="p">(),</span> <span class="n">OutVals</span><span class="p">[</span><span class="n">i</span><span class="p">],</span> <span class="n">Flag</span><span class="p">);</span>

    <span class="c1">// Guarantee that all emitted copies are stuck together with flags.</span>
    <span class="n">Flag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">RetOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocReg</span><span class="p">(),</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocVT</span><span class="p">()));</span>
  <span class="p">}</span>

<span class="cp">#if 1 </span><span class="c1">// structure return begin. Without this, it will use $3 instead of $2 </span>
  <span class="c1">// as return register. The cpu0 ABIs for returning structs by value requires </span>
  <span class="c1">// that we copy the sret argument into $v0 for the return. We saved the </span>
  <span class="c1">// argument into a virtual register in the entry block, so now we copy the </span>
  <span class="c1">// value out and into $v0.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasStructRetAttr</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span>      <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
    <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;sret virtual register not created in the entry block&quot;</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>

    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">,</span> <span class="n">Val</span><span class="p">,</span> <span class="n">Flag</span><span class="p">);</span>
    <span class="n">Flag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">RetOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// structure return end</span>

  <span class="n">RetOps</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">;</span>  <span class="c1">// Update chain.</span>

  <span class="c1">// Add the flag if we have it.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Flag</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span>
    <span class="n">RetOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Flag</span><span class="p">);</span>

  <span class="c1">// Return on Cpu0 is always a &quot;ret $lr&quot;</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Ret</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">RetOps</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">RetOps</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_6/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// SRetReturnReg - Some subtargets require that sret lowering includes</span>
<span class="c1">/// returning the value of the returned struct in a register. This field</span>
<span class="c1">/// holds the virtual register into which the sret argument is passed.</span>
<span class="kt">unsigned</span> <span class="n">SRetReturnReg</span><span class="p">;</span>
<span class="p">...</span>
  <span class="n">SRetReturnReg</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
<span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">getSRetReturnReg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">SRetReturnReg</span><span class="p">;</span> <span class="p">}</span>
<span class="kt">void</span> <span class="n">setSRetReturnReg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Reg</span><span class="p">)</span> <span class="p">{</span> <span class="n">SRetReturnReg</span> <span class="o">=</span> <span class="n">Reg</span><span class="p">;</span> <span class="p">}</span>
</pre></div>
</div>
<p>Function LowerReturn() of Cpu0ISelLowering.cpp handle return variable correctly.
Create Cpu0ISD::Ret node in LowerReturn() which is called when meet function
return as above code in Chapter3_6/Cpu0ISelLowering.cpp. More specific, it
create DAGs (Cpu0ISD::Ret (CopyToReg %X, %V0, %Y), %V0, Flag). Since the the
V0 register is assigned in CopyToReg and Cpu0ISD::Ret use V0, the CopyToReg
with V0 register will live out and won&#8217;t be removed in any later optimization
step. Remember, if use &#8220;return DAG.getNode(Cpu0ISD::Ret, DL, MVT::Other,
Chain, DAG.getRegister(Cpu0::LR, MVT::i32));&#8221; instead of &#8220;return DAG.getNode
(Cpu0ISD::Ret, DL, MVT::Other, &amp;RetOps[0], RetOps.size());&#8221; the V0 register
won&#8217;t be live out, the previous DAG (CopyToReg %X, %V0, %Y) will be removed
in later optimization stage. Then the result is same with Chapter3_5
which the return value is error.</p>
<p>Run Chapter3_6 with ch3_2.cpp, to get the following correct result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-12:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm -debug ch3_2.bc
-o -
  ...
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch3_2.bc&quot;</span>
        .text
        .globl        main
        .align        2
        .type main,@function
        .ent  main                    <span class="c"># @main</span>
main:
        .frame        <span class="nv">$fp</span>,24,<span class="nv">$lr</span>
        .mask         0x00000000,0
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
        st    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 2
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span> // <span class="nv">$2</span> <span class="o">=</span> 3
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span> // <span class="nv">$3</span> <span class="o">=</span> 7
        addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span> // <span class="nv">$2</span> <span class="o">=</span> 7+3
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  main
<span class="nv">$tmp1</span>:
        .size main, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-main
</pre></div>
</div>
</div>
<div class="section" id="data-operands-dags">
<h2>Data operands DAGs<a class="headerlink" href="#data-operands-dags" title="Permalink to this headline">¶</a></h2>
<p>From above or compiler book, you can see all the OP code are the internal nodes
in DAGs and operands are the leaf of DAGs.
At least in most cases, the data operands are leaves of DAGs, not internal
nodes. To develop your backend, you can copy the
related data operands DAGs node from other backend since the IR data nodes are
take cared by all the backend. Few readers stuck on the data DAGs nodes defined
in Cpu0InstrInfo.td but we think it is needless. The rest of books will let you
know the other IR OP code DAGs nodes and how to translate them into Cpu0 backend
machine OP code DAGs. About the data DAGs nodes, you can understand some of them
from the Cpu0InstrInfo.td with spending a little more time to think or guess
about it.
Some data DAGs we know more, some we know a little and some remains unknown but
it&#8217;s OK for us.
List some of data DAGs we understand and have met until now as follows,</p>
<p class="rubric">include/llvm/TargetSelectionDAG.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// PatLeaf&#39;s are pattern fragments that have no operands.  This is just a helper</span>
<span class="c1">// to define immediates and other common things concisely.</span>
<span class="k">class</span> <span class="nc">PatLeaf</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">frag</span><span class="p">,</span> <span class="n">code</span> <span class="n">pred</span> <span class="o">=</span> <span class="p">[{}],</span> <span class="n">SDNodeXForm</span> <span class="n">xform</span> <span class="o">=</span> <span class="n">NOOP_SDNodeXForm</span><span class="o">&gt;</span>
 <span class="o">:</span> <span class="n">PatFrag</span><span class="o">&lt;</span><span class="p">(</span><span class="n">ops</span><span class="p">),</span> <span class="n">frag</span><span class="p">,</span> <span class="n">pred</span><span class="p">,</span> <span class="n">xform</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_5/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Signed Operand
def simm16      : Operand&lt;i32&gt; {
  let DecoderMethod= "DecodeSimm16";
}

def shamt       : Operand&lt;i32&gt;;

// Unsigned Operand
def uimm16      : Operand&lt;i32&gt; {
  let PrintMethod = "printUnsignedImm";
}

// Address operand
def mem : Operand&lt;i32&gt; {
  let PrintMethod = "printMemOperand";
  let MIOperandInfo = (ops CPURegs, simm16);
  let EncoderMethod = "getMemEncoding";
}

// Transformation Function - get the lower 16 bits.
def LO16 : SDNodeXForm&lt;imm, [{
  return getImm(N, N-&gt;getZExtValue() &amp; 0xffff);
}]&gt;;

// Transformation Function - get the higher 16 bits.
def HI16 : SDNodeXForm&lt;imm, [{
  return getImm(N, (N-&gt;getZExtValue() &gt;&gt; 16) &amp; 0xffff);
}]&gt;; // lbd document - mark - def HI16

// Node immediate fits as 16-bit sign extended on target immediate.
// e.g. addi, andi
def immSExt16  : PatLeaf&lt;(imm), [{ return isInt&lt;16&gt;(N-&gt;getSExtValue()); }]&gt;;

// Node immediate fits as 16-bit zero extended on target immediate.
// The LO16 param means that only the lower 16 bits of the node
// immediate are caught.
// e.g. addiu, sltiu
def immZExt16  : PatLeaf&lt;(imm), [{
  if (N-&gt;getValueType(0) == MVT::i32)
    return (uint32_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
  else
    return (uint64_t)N-&gt;getZExtValue() == (unsigned short)N-&gt;getZExtValue();
}], LO16&gt;;

// Immediate can be loaded with LUi (32-bit int with lower 16-bit cleared).
def immLow16Zero : PatLeaf&lt;(imm), [{
  int64_t Val = N-&gt;getSExtValue();
  return isInt&lt;32&gt;(Val) &amp;&amp; !(Val &amp; 0xffff);
}]&gt;;

// shamt field must fit in 5 bits.
def immZExt5 : ImmLeaf&lt;i32, [{return Imm == (Imm &amp; 0x1f);}]&gt;;

// Cpu0 Address Mode! SDNode frameindex could possibily be a match
// since load and store instructions from stack used it.
def addr : ComplexPattern&lt;iPTR, 2, "SelectAddr", [frameindex], [SDNPWantParent]&gt;;

//===----------------------------------------------------------------------===//
// Pattern fragment for load/store
//===----------------------------------------------------------------------===//

class AlignedLoad&lt;PatFrag Node&gt; :
  PatFrag&lt;(ops node:$ptr), (Node node:$ptr), [{
  LoadSDNode *LD = cast&lt;LoadSDNode&gt;(N);
  return LD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= LD-&gt;getAlignment();
}]&gt;;

class AlignedStore&lt;PatFrag Node&gt; :
  PatFrag&lt;(ops node:$val, node:$ptr), (Node node:$val, node:$ptr), [{
  StoreSDNode *SD = cast&lt;StoreSDNode&gt;(N);
  return SD-&gt;getMemoryVT().getSizeInBits()/8 &lt;= SD-&gt;getAlignment();
}]&gt;;

// Load/Store PatFrags.
def load_a          : AlignedLoad&lt;load&gt;;
def store_a         : AlignedStore&lt;store&gt;;</pre>
</div>
<p>The immSExt16 is a data leaf DAG node and it will return true if its value is
in the range of signed 16 bits integer. The load_a, store_a and others are
similar.
The addr is a data node from iPTR and belong to ComplexPattern.
It will call SelectAddr() function
in Cpu0ISelDAGToDAG.cpp which return variables, Base and Offset, for code
generation (IR to machine instruction DAG translation).
The simm16, ...,  inherited from Operand&lt;i32&gt; because Cpu0 is 32 bits.
For C type of int, it&#8217;s 32-bits in Cpu0 and we can check if it is in 16-bits range
for L type of instruction format immediate value. For example, IR
&#8220;add %0, %1, +0x7fff&#8221; is in range of Cpu0 L type instruction &#8220;addiu $2, $3, 0x7fff&#8221;
while &#8220;add %0, %1, +0x8000&#8221; is out of range.</p>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this Chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>Summary the functions for llvm backend stages as the following table.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-200:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch3.bc
-debug-pass<span class="o">=</span>Structure -o -
...
Machine Branch Probability Analysis
  ModulePass Manager
    FunctionPass Manager
      ...
      CPU0 DAG-&gt;DAG Pattern Instruction Selection
        Initial selection DAG
        Optimized lowered selection DAG
        Type-legalized selection DAG
        Optimized <span class="nb">type</span>-legalized selection DAG
        Legalized selection DAG
        Optimized legalized selection DAG
        Instruction selection
        Selected selection DAG
        Scheduling
      ...
      Greedy Register Allocator
      ...
      Post-RA pseudo instruction expansion pass
      ...
      Cpu0 Assembly Printer
</pre></div>
</div>
<table border="1" class="docutils">
<caption>functions for llvm backend stage</caption>
<colgroup>
<col width="54%" />
<col width="46%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Stage</th>
<th class="head">Function</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Before CPU0 DAG-&gt;DAG Pattern Instruction Selection</td>
<td><ul class="first last simple">
<li>Cpu0TargetLowering::LowerFormalArguments</li>
<li>Cpu0TargetLowering::LowerReturn</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Instruction selection</td>
<td><ul class="first last simple">
<li>Cpu0DAGToDAGISel::Select</li>
</ul>
</td>
</tr>
<tr class="row-even"><td>Prologue/Epilogue Insertion &amp; Frame Finalization</td>
<td><ul class="first last simple">
<li>Cpu0FrameLowering.cpp</li>
<li>Cpu0RegisterInfo::eliminateFrameIndex()</li>
</ul>
</td>
</tr>
<tr class="row-odd"><td>Cpu0 Assembly Printer</td>
<td><ul class="first last simple">
<li>Cpu0AsmPrinter.cpp, Cpu0MCInstLower.cpp</li>
<li>Cpu0InstPrinter.cpp</li>
</ul>
</td>
</tr>
</tbody>
</table>
<p>We add a pass in Instruction Section stage in section &#8220;Add Cpu0DAGToDAGISel
class&#8221;. You can embed your code into other pass like that. Please check
CodeGen/Passes.h for the information. Remember the pass is called according
the function unit as the <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-debug-pass=Structure</span></tt> indicated.</p>
<p>We have finished a simple assembler for cpu0 which only support <strong>ld</strong>,
<strong>st</strong>, <strong>addiu</strong>, <strong>ori</strong>, <strong>lui</strong>, <strong>addu</strong>, <strong>shl</strong> and <strong>ret</strong> 8
instructions.</p>
<p>We are satisfied with this result.
But you may think “After so many codes we program, and just get these 8
instructions”.
The point is we have created a frame work for cpu0 target machine (please
look back the llvm back end structure class inherit tree early in this
chapter).
Until now, we have over 3000 lines of source code with comments which include
files *.cpp, *.h, *.td, CMakeLists.txt and LLVMBuild.txt.
It can be counted by command <tt class="docutils literal"><span class="pre">wc</span> <span class="pre">`find</span> <span class="pre">dir</span> <span class="pre">-name</span> <span class="pre">*.cpp`</span></tt> for files *.cpp,
*.h, *.td, *.txt.
LLVM front end tutorial have 700 lines of source code without comments totally.
Don&#8217;t feel down with this result.
In reality, write a back end is warm up slowly but run fast.
Clang has over 500,000 lines of source code with comments in clang/lib
directory which include C++ and Obj C support.
Mips back end has only 15,000 lines with comments.
Even the complicate X86 CPU which CISC outside and RISC inside (micro
instruction), has only 45,000 lines with comments.
In next chapter, we will show you that add a new instruction support is as easy
as 123.</p>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine">http://llvm.org/docs/WritingAnLLVMBackend.html#target-machine</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id7" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://llvm.org/docs/CodeGenerator.html">http://llvm.org/docs/CodeGenerator.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id8" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://llvm.org/docs/LangRef.html">http://llvm.org/docs/LangRef.html</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="llvmstructure.html">Cpu0 Instruction Set and LLVM Target Description</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="otherinst.html">Arithmetic and logic lsupport</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>