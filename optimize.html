<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Backend Optimization &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Backend Optimization</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="backend-optimization">
<span id="sec-optimize"></span><h1>Backend Optimization<a class="headerlink" href="#backend-optimization" title="Permalink to this headline">¶</a></h1>
<p>This chapter introduce how to do backend optimization in LLVM first.
Next we do optimization via extend instruction sets in hardware level to
do optimization in a way of creating an efficient RISC CPU which aims to C/C++
high level language.</p>
<div class="section" id="cpu0-backend-optimization-remove-useless-jmp">
<h2>Cpu0 backend Optimization: Remove useless JMP<a class="headerlink" href="#cpu0-backend-optimization-remove-useless-jmp" title="Permalink to this headline">¶</a></h2>
<p>LLVM uses functional pass both in code generation and optimization.
Following the 3 tiers of compiler architecture, LLVM did much optimization in
middle tier of LLVM IR, SSA form.
Beyond middle tier optimization, there are opportunities in
optimization which depend on backend features.
Mips fill delay slot is an example of backend optimization used in pipeline
RISC machine.
You can migrate from Mips if your backend is a pipeline RISC with
delay slot.
In this section, we apply the &#8220;delete useless jmp&#8221; in Cpu0
backend optimization.
This algorithm is simple and effective as a perfect tutorial in optimization.
Through this example, you can understand how to add an optimization pass and
coding your complicate optimization algorithm on your backend in real project.</p>
<p>Chapter12_1/ supports &#8220;delete useless jmp&#8221; optimization algorithm which add
codes as follows,</p>
<p class="rubric">lbdex/Chapter12_1/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="p">...</span>
  <span class="n">Cpu0DelUselessJMP</span><span class="p">.</span><span class="n">cpp</span>
  <span class="p">...</span>
  <span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_1/Cpu0.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
  <span class="n">FunctionPass</span> <span class="o">*</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_1/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0PassConfig</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetPassConfig</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">addPreEmitPass</span><span class="p">();</span>
<span class="p">};</span>
<span class="p">...</span>
<span class="c1">// Implemented by targets that want to run passes immediately before</span>
<span class="c1">// machine code is emitted. return true if -print-machineinstrs should</span>
<span class="c1">// print out the code after the passes.</span>
<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addPreEmitPass</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">getCpu0TargetMachine</span><span class="p">();</span>
  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">TM</span><span class="p">));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_1/Cpu0DelUselessJMP.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0DelUselessJMP.cpp - Cpu0 DelJmp -------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// Simple pass to fills delay slots with useful instructions.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;del-jmp&quot;</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/CommandLine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetMachine.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/SmallSet.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Statistic.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="n">STATISTIC</span><span class="p">(</span><span class="n">NumDelJmp</span><span class="p">,</span> <span class="s">&quot;Number of useless jmp deleted&quot;</span><span class="p">);</span>

<span class="k">static</span> <span class="n">cl</span><span class="o">::</span><span class="n">opt</span><span class="o">&lt;</span><span class="kt">bool</span><span class="o">&gt;</span> <span class="n">EnableDelJmp</span><span class="p">(</span>
  <span class="s">&quot;enable-cpu0-del-useless-jmp&quot;</span><span class="p">,</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">init</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">desc</span><span class="p">(</span><span class="s">&quot;Delete useless jmp instructions: jmp 0.&quot;</span><span class="p">),</span>
  <span class="n">cl</span><span class="o">::</span><span class="n">Hidden</span><span class="p">);</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">DelJmp</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionPass</span> <span class="p">{</span>

    <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">*</span><span class="n">TII</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
    <span class="n">DelJmp</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">MachineFunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">),</span> <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span> <span class="n">TII</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">getInstrInfo</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;Cpu0 Del Useless jmp&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">runOnMachineBasicBlock</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBBN</span><span class="p">);</span>
    <span class="kt">bool</span> <span class="nf">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
      <span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">EnableDelJmp</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">MachineFunction</span><span class="o">::</span><span class="n">iterator</span> <span class="n">FJ</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">FJ</span> <span class="o">!=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="n">FJ</span><span class="o">++</span><span class="p">;</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">FJ</span> <span class="o">==</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">())</span>
          <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
        <span class="k">for</span> <span class="p">(</span><span class="n">MachineFunction</span><span class="o">::</span><span class="n">iterator</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">FE</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
             <span class="n">FJ</span> <span class="o">!=</span> <span class="n">FE</span><span class="p">;</span> <span class="o">++</span><span class="n">FI</span><span class="p">,</span> <span class="o">++</span><span class="n">FJ</span><span class="p">)</span>
          <span class="c1">// In STL style, F.end() is the dummy BasicBlock() like &#39;\0&#39; in </span>
          <span class="c1">//  C string. </span>
          <span class="c1">// FJ is the next BasicBlock of FI; When FI range from F.begin() to </span>
          <span class="c1">//  the PreviousBasicBlock of F.end() call runOnMachineBasicBlock().</span>
          <span class="n">Changed</span> <span class="o">|=</span> <span class="n">runOnMachineBasicBlock</span><span class="p">(</span><span class="o">*</span><span class="n">FI</span><span class="p">,</span> <span class="o">*</span><span class="n">FJ</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">};</span>
  <span class="kt">char</span> <span class="n">DelJmp</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// end of anonymous namespace</span>

<span class="kt">bool</span> <span class="n">DelJmp</span><span class="o">::</span>
<span class="n">runOnMachineBasicBlock</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBBN</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">begin</span><span class="p">())</span>
    <span class="n">I</span><span class="o">--</span><span class="p">;</span>	<span class="c1">// set I to the last instruction</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
    
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JMP</span> <span class="o">&amp;&amp;</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">getMBB</span><span class="p">()</span> <span class="o">==</span> <span class="o">&amp;</span><span class="n">MBBN</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// I is the instruction of &quot;jmp #offset=0&quot;, as follows,</span>
    <span class="c1">//     jmp	$BB0_3</span>
    <span class="c1">// $BB0_3:</span>
    <span class="c1">//     ld	$4, 28($sp)</span>
    <span class="o">++</span><span class="n">NumDelJmp</span><span class="p">;</span>
    <span class="n">MBB</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>	<span class="c1">// delete the &quot;JMP 0&quot; instruction</span>
    <span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>	<span class="c1">// Notify LLVM kernel Changed</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>

<span class="p">}</span>

<span class="c1">/// createCpu0DelJmpPass - Returns a pass that DelJmp in Cpu0 MachineFunctions</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0DelJmpPass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">DelJmp</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As above code, except Cpu0DelUselessJMP.cpp, other files changed for register
class DelJmp as a functional pass.
As the comment of above code, MBB is the current
block and MBBN is the next block. For each last instruction of every MBB, we
check if it is the JMP instruction as well as
its Operand is the next basic block.
By getMBB() in MachineOperand, you can get the MBB address.
For the member functions of MachineOperand, please check
include/llvm/CodeGen/MachineOperand.h
Now, let&#8217;s run Chapter12_1/ with ch12_1.cpp for explanation.</p>
<p class="rubric">lbdex/InputFiles/ch12_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_DelUselessJMP</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="mi">3</span><span class="p">;</span>
    <span class="n">b</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">b</span><span class="p">;</span>
    <span class="n">b</span><span class="o">--</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">c</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">a</span> <span class="o">=</span> <span class="n">a</span> <span class="o">+</span> <span class="n">c</span><span class="p">;</span>
    <span class="n">c</span><span class="o">++</span><span class="p">;</span>
  <span class="p">}</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu
-c ch12_1.cpp -emit-llvm -o ch12_1.bc
118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm -stats
ch12_1.bc -o -
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch12_1.bc&quot;</span>
        .text
        .globl        _Z18test_DelUselessJMPiii
        .align        2
        .type _Z18test_DelUselessJMPiii,@function
        .ent  _Z18test_DelUselessJMPiii <span class="c"># @_Z18test_DelUselessJMPiii</span>
_Z18test_DelUselessJMPiii:
        .frame        <span class="nv">$fp</span>,16,<span class="nv">$lr</span>
        .mask         0x00001000,-4
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
        st    <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
        addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
        ld    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        jne   <span class="nv">$sw</span>, <span class="nv">$BB0_2</span>
<span class="c"># BB#1:</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$3</span>, <span class="nv">$3</span>, 1
        st    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_2</span>:
        ld    <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        jne   <span class="nv">$sw</span>, <span class="nv">$BB0_4</span>
        jmp   <span class="nv">$BB0_3</span>
<span class="nv">$BB0_4</span>:
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, -1
        ld    <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        jgt   <span class="nv">$sw</span>, <span class="nv">$BB0_6</span>
        jmp   <span class="nv">$BB0_5</span>
<span class="nv">$BB0_3</span>:
        ld    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 3
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        jmp   <span class="nv">$BB0_6</span>
<span class="nv">$BB0_5</span>:
        ld    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, -1
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_6</span>:
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        ld    <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        cmp   <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        jlt   <span class="nv">$sw</span>, <span class="nv">$BB0_8</span>
<span class="c"># BB#7:</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_8</span>:
        ld    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
        ld    <span class="nv">$fp</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z18test_DelUselessJMPiii
<span class="nv">$tmp3</span>:
        .size _Z18test_DelUselessJMPiii, <span class="o">(</span><span class="nv">$tmp3</span><span class="o">)</span>-_Z18test_DelUselessJMPiii
...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
                          ... Statistics Collected ...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
 ...
 2 del-jmp        - Number of useless jmp deleted
 ...
</pre></div>
</div>
<p>The terminal display &#8220;Number of useless jmp deleted&#8221; by <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-stats</span></tt> option
because we set the &#8220;STATISTIC(NumDelJmp, &#8220;Number of useless jmp deleted&#8221;)&#8221; in
code. It deletes 2 jmp instructions from block &#8220;# BB#0&#8221; and &#8220;$BB0_6&#8221;.
You can check it by <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-enable-cpu0-del-useless-jmp=false</span></tt> option to see
the difference to non-optimization version.
If you run with ch8_1_1.cpp, will find 10 jmp instructions are deleted in 100
lines of assembly code, which meaning 10% improvement in speed and code size
<a class="footnote-reference" href="#id5" id="id1">[1]</a>.</p>
</div>
<div class="section" id="cpu0-optimization-extends-instruction-sets">
<h2>Cpu0 Optimization: Extends instruction sets<a class="headerlink" href="#cpu0-optimization-extends-instruction-sets" title="Permalink to this headline">¶</a></h2>
<p>If you compare the cpu0 and Mips instruction sets, you will find that Mips use
SLT, BEQ and set the status in explicit/general register while Cpu0 use CMP,
JEQ and set status in implicit/specific register.</p>
<p>Follow RISC principle, this section will replace CMP, JEQ with Mips style
instructions.
Mips style BEQ instructions will reduce the number of branch instructions too.
Which means optimization in speed and code size.</p>
<div class="section" id="cpu0-new-instruction-sets-table">
<h3>Cpu0 new instruction sets table<a class="headerlink" href="#cpu0-new-instruction-sets-table" title="Permalink to this headline">¶</a></h3>
<p>Add Cpu0 instructions as follows,</p>
<ul class="simple">
<li>First column F.: meaning Format.</li>
</ul>
<table border="1" class="docutils">
<caption>Cpu0 Instruction Set
      :widths: 1 4 3 11 7 10
      :header-rows: 1</caption>
<colgroup>
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
<col width="17%" />
</colgroup>
<tbody valign="top">
<tr class="row-odd"><td>F.</td>
<td>Mnemonic</td>
<td>Opcode</td>
<td>Meaning</td>
<td>Syntax</td>
<td>Operation</td>
</tr>
<tr class="row-even"><td>L</td>
<td>SLTi</td>
<td>26</td>
<td>Set less Then</td>
<td>SLTi Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb &lt; Cx)</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>SLTiu</td>
<td>27</td>
<td>SLTi unsigned</td>
<td>SLTiu Ra, Rb, Cx</td>
<td>Ra &lt;= (Rb &lt; Cx)</td>
</tr>
<tr class="row-even"><td>A</td>
<td>SLT</td>
<td>28</td>
<td>Set less Then</td>
<td>SLT Ra, Rb, Rc</td>
<td>Ra &lt;= (Rb &lt; Rc)</td>
</tr>
<tr class="row-odd"><td>A</td>
<td>SLTu</td>
<td>29</td>
<td>SLT unsigned</td>
<td>SLTu Ra, Rb, Rc</td>
<td>Ra &lt;= (Rb &lt; Rc)</td>
</tr>
<tr class="row-even"><td>L</td>
<td>BEQ</td>
<td>37</td>
<td>Jump if equal</td>
<td>BEQ Ra, Rb, Cx</td>
<td>if (Ra==Rb), PC &lt;= PC + Cx</td>
</tr>
<tr class="row-odd"><td>L</td>
<td>BNE</td>
<td>38</td>
<td>Jump if not equal</td>
<td>BNE Ra, Rb, Cx</td>
<td>if (Ra!=Rb), PC &lt;= PC + Cx</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="cpu0-code-changes">
<h3>Cpu0 code changes<a class="headerlink" href="#cpu0-code-changes" title="Permalink to this headline">¶</a></h3>
<p>Chapter12_2/ include the changes for new instruction sets as follows,</p>
<p class="rubric">lbdex/Chapter12_2/Disassembler/Cpu0Disassembler.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">DecodeStatus</span> <span class="nf">DecodeBranch16Target</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                                       <span class="kt">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                                       <span class="kt">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">);</span>
<span class="p">...</span>
<span class="k">static</span> <span class="n">DecodeStatus</span> <span class="n">DecodeBranch16Target</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span>
                                       <span class="kt">unsigned</span> <span class="n">Insn</span><span class="p">,</span>
                                       <span class="kt">uint64_t</span> <span class="n">Address</span><span class="p">,</span>
                                       <span class="k">const</span> <span class="kt">void</span> <span class="o">*</span><span class="n">Decoder</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">BranchOffset</span> <span class="o">=</span> <span class="n">fieldFromInstruction</span><span class="p">(</span><span class="n">Insn</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">16</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">BranchOffset</span> <span class="o">&gt;</span> <span class="mh">0x8fff</span><span class="p">)</span>
    <span class="n">BranchOffset</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="o">*</span><span class="p">(</span><span class="mh">0x10000</span> <span class="o">-</span> <span class="n">BranchOffset</span><span class="p">);</span>
  <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">BranchOffset</span><span class="p">));</span>
  <span class="k">return</span> <span class="n">MCDisassembler</span><span class="o">::</span><span class="n">Success</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">unsigned</span> <span class="nf">adjustFixupValue</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Kind</span><span class="p">,</span> <span class="kt">uint64_t</span> <span class="n">Value</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Add/subtract and shift</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_PC16</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_PC24</span><span class="o">:</span>
    <span class="c1">// So far we are only using this type for branches.</span>
    <span class="c1">// For branches we start 1 instruction after the branch</span>
    <span class="c1">// so the displacement will be one instruction size less.</span>
    <span class="n">Value</span> <span class="o">-=</span> <span class="mi">4</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
  <span class="k">const</span> <span class="n">MCFixupKindInfo</span> <span class="o">&amp;</span><span class="n">getFixupKindInfo</span><span class="p">(</span><span class="n">MCFixupKind</span> <span class="n">Kind</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">const</span> <span class="k">static</span> <span class="n">MCFixupKindInfo</span> <span class="n">Infos</span><span class="p">[</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">NumTargetFixupKinds</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span>
      <span class="c1">// This table *must* be in same the order of fixup_* kinds in</span>
      <span class="c1">// Cpu0FixupKinds.h.</span>
      <span class="c1">//</span>
      <span class="c1">// name                    offset  bits  flags</span>
      <span class="p">...</span>
      <span class="p">{</span> <span class="s">&quot;fixup_Cpu0_PC16&quot;</span><span class="p">,</span>         <span class="mi">0</span><span class="p">,</span>     <span class="mi">16</span><span class="p">,</span>  <span class="n">MCFixupKindInfo</span><span class="o">::</span><span class="n">FKF_IsPCRel</span> <span class="p">},</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">Cpu0ELFObjectWriter</span><span class="o">::</span><span class="n">GetRelocType</span><span class="p">(</span><span class="k">const</span> <span class="n">MCValue</span> <span class="o">&amp;</span><span class="n">Target</span><span class="p">,</span>
                                           <span class="k">const</span> <span class="n">MCFixup</span> <span class="o">&amp;</span><span class="n">Fixup</span><span class="p">,</span>
                                           <span class="kt">bool</span> <span class="n">IsPCRel</span><span class="p">,</span>
                                           <span class="kt">bool</span> <span class="n">IsRelocWithSymbol</span><span class="p">,</span>
                                           <span class="kt">int64_t</span> <span class="n">Addend</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_PC16</span><span class="o">:</span>
    <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_PC16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/MCTargetDesc/Cpu0FixupKinds.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">enum</span> <span class="n">Fixups</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// PC relative branch fixup resulting in - R_CPU0_PC16.</span>
  <span class="c1">// cpu0 PC16, e.g. beq</span>
  <span class="n">fixup_Cpu0_PC16</span><span class="p">,</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="c1">// getBranch16TargetOpValue - Return binary encoding of the branch</span>
  <span class="c1">// target operand, such as BEQ, BNE. If the machine operand</span>
  <span class="c1">// requires relocation, record the relocation and return zero.</span>
  <span class="kt">unsigned</span> <span class="n">getBranch16TargetOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>

<span class="p">...</span>
<span class="c1">/// getBranch16TargetOpValue - Return binary encoding of the branch</span>
<span class="c1">/// target operand. If the machine operand requires relocation,</span>
<span class="c1">/// record the relocation and return zero.</span>
<span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getBranch16TargetOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                       <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>

  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">OpNo</span><span class="p">);</span>

  <span class="c1">// If the destination is an immediate, we have nothing to do.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImm</span><span class="p">())</span> <span class="k">return</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isExpr</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;getBranch16TargetOpValue expects only expressions&quot;</span><span class="p">);</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getExpr</span><span class="p">();</span>
  <span class="n">Fixups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                   <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_PC16</span><span class="p">)));</span>
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - getBranch16TargetOpValue</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/MCTargetDesc/Cpu0TargetDesc.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">ParseCpu0Triple</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0&quot;</span> <span class="o">||</span> <span class="n">TheTriple</span> <span class="o">==</span> <span class="s">&quot;cpu0el&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">CPU</span> <span class="o">==</span> <span class="s">&quot;cpu032II&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Cpu0ArchFeature</span> <span class="o">=</span> <span class="s">&quot;+cpu032II&quot;</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Cpu0ArchFeature</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/Cpu0.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Subtarget features                                                    //</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">FeatureCpu032II</span>    <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;cpu032II&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0ArchVersion&quot;</span><span class="p">,</span>
         <span class="s">&quot;Cpu032II&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu032II ISA Support (use instruction slt)&quot;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">FeatureCpu032III</span>   <span class="o">:</span> <span class="n">SubtargetFeature</span><span class="o">&lt;</span><span class="s">&quot;cpu032III&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu0ArchVersion&quot;</span><span class="p">,</span>
         <span class="s">&quot;Cpu032III&quot;</span><span class="p">,</span> <span class="s">&quot;Cpu032III ISA Support (use instruction slt)&quot;</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 processors supported.</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="p">...</span>
<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032II&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032II</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="n">def</span> <span class="o">:</span> <span class="n">Proc</span><span class="o">&lt;</span><span class="s">&quot;cpu032III&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">FeatureCpu032III</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def NotCpu032II :     Predicate&lt;"!Subtarget.hasCpu032II()"&gt;,
                      AssemblerPredicate&lt;"FeatureCpu032I"&gt;;
def HasCpu032II :     Predicate&lt;"Subtarget.hasCpu032II()"&gt;,
                      AssemblerPredicate&lt;"!FeatureCpu032III"&gt;;
// !FeatureCpu032III is for disassembler in "llvm-objdump -d"

/* In Cpu0GenSubtargetInfo.inc,
namespace llvm {
namespace Cpu0 {
enum {
  FeatureCpu032I =  1ULL &lt;&lt; 0,
  FeatureCpu032II =  1ULL &lt;&lt; 1,
  FeatureCpu032III =  1ULL &lt;&lt; 2
};
}
} // End llvm namespace

static bool checkDecoderPredicate(unsigned Idx, uint64_t Bits) {
  switch (Idx) {
  default: llvm_unreachable("Invalid index!");
  case 0:
    return ((Bits &amp; Cpu0::FeatureCpu032I)); // came from "FeatureCpu032I"
  case 1:
    return (!(Bits &amp; Cpu0::FeatureCpu032III)); // came from !FeatureCpu032III"
  }
}

To let disassembler work, the function
checkDecoderPredicate(unsigned Idx, uint64_t Bits) must return true(=1).
As above code, the argument Bits always is 1. Set !FeatureCpu032III" to do
disassembler for expectation. */
...
// BEQ, BNE
def brtarget16    : Operand&lt;OtherVT&gt; {
  let EncoderMethod = "getBranch16TargetOpValue";
  let OperandType = "OPERAND_PCREL";
  let DecoderMethod = "DecodeBranch16Target";
}
...
class ArithOverflowR&lt;bits&lt;8&gt; op, string instr_asm,
                    InstrItinClass itin, RegisterClass RC, bit isComm = 0&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"), [], itin&gt; {
  let shamt = 0;
  let isCommutable = isComm;
}
class CmpInstr&lt;bits&lt;8&gt; op, string instr_asm,
               InstrItinClass itin, RegisterClass RC, RegisterClass RD,
               bit isComm = 0&gt;:
  ...
  let Predicates = [NotCpu032II];
}
// Conditional Branch, e.g. JEQ brtarget24
class CBranch24&lt;bits&lt;8&gt; op, string instr_asm, RegisterClass RC,
                   list&lt;Register&gt; UseRegs&gt;:
  FJ&lt;op, (outs), (ins RC:$ra, brtarget24:$addr),
             !strconcat(instr_asm, "\t$ra, $addr"),
             [], IIBranch&gt;, Requires&lt;[NotCpu032II]&gt; {
  ...
//  let Predicates = [HasCpu032II]; // same effect as Requires
}

// Conditional Branch, e.g. BEQ $r1, $r2, brtarget16
class CBranch16&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op, RegisterClass RC&gt;:
  FL&lt;op, (outs), (ins RC:$ra, RC:$rb, brtarget16:$imm16),
             !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
             [(brcond (i32 (cond_op RC:$ra, RC:$rb)), bb:$imm16)], IIBranch&gt;,
             Requires&lt;[HasCpu032II]&gt; {
  let isBranch = 1;
  let isTerminator = 1;
  let hasDelaySlot = 1;
  let Defs = [AT];
}

// SetCC
class SetCC_R&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op,
              RegisterClass RC&gt;:
  FA&lt;op, (outs GPROut:$ra), (ins RC:$rb, RC:$rc),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"),
     [(set GPROut:$ra, (cond_op RC:$rb, RC:$rc))],
     IIAlu&gt;, Requires&lt;[HasCpu032II]&gt; {
  let shamt = 0;
}

class SetCC_I&lt;bits&lt;8&gt; op, string instr_asm, PatFrag cond_op, Operand Od,
              PatLeaf imm_type, RegisterClass RC&gt;:
  FL&lt;op, (outs GPROut:$ra), (ins RC:$rb, Od:$imm16),
     !strconcat(instr_asm, "\t$ra, $rb, $imm16"),
     [(set GPROut:$ra, (cond_op RC:$rb, imm_type:$imm16))],
     IIAlu&gt;, Requires&lt;[HasCpu032II]&gt; {
}
...
def SLTi    : SetCC_I&lt;0x26, "slti", setlt, simm16, immSExt16, CPURegs&gt;;
def SLTiu   : SetCC_I&lt;0x27, "sltiu", setult, simm16, immSExt16, CPURegs&gt;;
def SLT     : SetCC_R&lt;0x28, "slt", setlt, CPURegs&gt;;
def SLTu    : SetCC_R&lt;0x29, "sltu", setult, CPURegs&gt;;
...
/// Jump and Branch Instructions
def BEQ     : CBranch&lt;0x37, "beq", seteq, CPURegs&gt;;
def BNE     : CBranch&lt;0x38, "bne", setne, CPURegs&gt;;
...
// brcond for slt instruction
multiclass BrcondPatsSlt&lt;RegisterClass RC, Instruction BEQOp, Instruction BNEOp,
                      Instruction SLTOp, Instruction SLTuOp, Instruction SLTiOp,
                      Instruction SLTiuOp, Register ZEROReg&gt; {
def : Pat&lt;(brcond (i32 (setne RC:$lhs, 0)), bb:$dst),
              (BNEOp RC:$lhs, ZEROReg, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (seteq RC:$lhs, 0)), bb:$dst),
              (BEQOp RC:$lhs, ZEROReg, bb:$dst)&gt;;

def : Pat&lt;(brcond (i32 (setge RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTOp RC:$lhs, RC:$rhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setuge RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTuOp RC:$lhs, RC:$rhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setge RC:$lhs, immSExt16:$rhs)), bb:$dst),
              (BEQ (SLTiOp RC:$lhs, immSExt16:$rhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setuge RC:$lhs, immSExt16:$rhs)), bb:$dst),
              (BEQ (SLTiuOp RC:$lhs, immSExt16:$rhs), ZERO, bb:$dst)&gt;;

def : Pat&lt;(brcond (i32 (setle RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTOp RC:$rhs, RC:$lhs), ZERO, bb:$dst)&gt;;
def : Pat&lt;(brcond (i32 (setule RC:$lhs, RC:$rhs)), bb:$dst),
              (BEQ (SLTuOp RC:$rhs, RC:$lhs), ZERO, bb:$dst)&gt;;

def : Pat&lt;(brcond RC:$cond, bb:$dst),
              (BNEOp RC:$cond, ZEROReg, bb:$dst)&gt;;
}

let Predicates = [NotCpu032II] in {
defm : BrcondPatsCmp&lt;CPURegs, JEQ, JNE, JLT, JGT, JLE, JGE, CMP, ZERO&gt;;
}

let Predicates = [HasCpu032II] in {
defm : BrcondPatsSlt&lt;CPURegs, BEQ, BNE, SLT, SLTu, SLTi, SLTiu, ZERO&gt;;
}
// setcc for slt instruction
multiclass SeteqPatsSlt&lt;RegisterClass RC, Instruction SLTiuOp, Instruction XOROp,
                     Instruction SLTuOp, Register ZEROReg&gt; {
// a == b
  def : Pat&lt;(seteq RC:$lhs, RC:$rhs),
                (SLTiuOp (XOROp RC:$lhs, RC:$rhs), 1)&gt;;
// a != b
  def : Pat&lt;(setne RC:$lhs, RC:$rhs),
                (SLTuOp ZEROReg, (XOROp RC:$lhs, RC:$rhs))&gt;;
}

// a &lt;= b
multiclass SetlePatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setle RC:$lhs, RC:$rhs),
// a &lt;= b is equal to (XORi (b &lt; a), 1)
                (XORi (SLTOp RC:$rhs, RC:$lhs), 1)&gt;;
  def : Pat&lt;(setule RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$rhs, RC:$lhs), 1)&gt;;
}

// a &gt; b
multiclass SetgtPatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setgt RC:$lhs, RC:$rhs),
// a &gt; b is equal to b &lt; a is equal to setlt(b, a)
                (SLTOp RC:$rhs, RC:$lhs)&gt;;
  def : Pat&lt;(setugt RC:$lhs, RC:$rhs),
                (SLTuOp RC:$rhs, RC:$lhs)&gt;;
}

// a &gt;= b
multiclass SetgePatsSlt&lt;RegisterClass RC, Instruction SLTOp, Instruction SLTuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, RC:$rhs),
// a &gt;= b is equal to b &lt;= a
                (XORi (SLTOp RC:$lhs, RC:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, RC:$rhs),
                (XORi (SLTuOp RC:$lhs, RC:$rhs), 1)&gt;;
}

multiclass SetgeImmPatsSlt&lt;RegisterClass RC, Instruction SLTiOp,
                        Instruction SLTiuOp&gt; {
  def : Pat&lt;(setge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
  def : Pat&lt;(setuge RC:$lhs, immSExt16:$rhs),
                (XORi (SLTiuOp RC:$lhs, immSExt16:$rhs), 1)&gt;;
}

let Predicates = [NotCpu032II] in {
defm : SeteqPatsCmp&lt;CPURegs&gt;;
defm : SetltPatsCmp&lt;CPURegs&gt;;
defm : SetlePatsCmp&lt;CPURegs&gt;;
defm : SetgtPatsCmp&lt;CPURegs&gt;;
defm : SetgePatsCmp&lt;CPURegs&gt;;
}

let Predicates = [HasCpu032II] in {
defm : SeteqPatsSlt&lt;CPURegs, SLTiu, XOR, SLTu, ZERO&gt;;
defm : SetlePatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgtPatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgePatsSlt&lt;CPURegs, SLT, SLTu&gt;;
defm : SetgeImmPatsSlt&lt;CPURegs, SLTi, SLTiu&gt;;
}</pre>
</div>
<p class="rubric">lbdex/Chapter12_2/Cpu0ISelDAGToDAG.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// Select instructions not customized! Used for</span>
<span class="c1">/// expanded, promoted and normal instructions</span>
<span class="n">SDNode</span><span class="o">*</span> <span class="n">Cpu0DAGToDAGISel</span><span class="o">::</span><span class="n">Select</span><span class="p">(</span><span class="n">SDNode</span> <span class="o">*</span><span class="n">Node</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">SUBE</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">ADDE</span><span class="o">:</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">const</span> <span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span> <span class="o">=</span> <span class="n">getTargetMachine</span><span class="p">();</span>
    <span class="k">const</span> <span class="n">Cpu0Subtarget</span> <span class="o">&amp;</span><span class="n">Subtarget</span> <span class="o">=</span> <span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="n">SDNode</span> <span class="o">*</span><span class="n">Carry</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Subtarget</span><span class="p">.</span><span class="n">hasCpu032II</span><span class="p">())</span>
      <span class="n">Carry</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SLTu</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
    <span class="k">else</span> <span class="p">{</span>
      <span class="n">SDNode</span> <span class="o">*</span><span class="n">StatusWord</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CMP</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span> <span class="n">Ops</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">Constant1</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getTargetConstant</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="n">VT</span><span class="p">);</span>
      <span class="n">Carry</span> <span class="o">=</span> <span class="n">CurDAG</span><span class="o">-&gt;</span><span class="n">getMachineNode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ANDi</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">VT</span><span class="p">,</span>
                                             <span class="n">SDValue</span><span class="p">(</span><span class="n">StatusWord</span><span class="p">,</span><span class="mi">0</span><span class="p">),</span> <span class="n">Constant1</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_2/Cpu0Subtarget.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0Subtarget</span> <span class="o">:</span> <span class="k">public</span> <span class="n">Cpu0GenSubtargetInfo</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">enum</span> <span class="n">Cpu0ArchEnum</span> <span class="p">{</span>
    <span class="n">Cpu032I</span>
    <span class="p">,</span> <span class="n">Cpu032II</span><span class="p">,</span>
    <span class="n">Cpu032III</span>
  <span class="p">};</span>
  <span class="p">...</span>
  <span class="kt">bool</span> <span class="n">hasCpu032I</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ArchVersion</span> <span class="o">&gt;=</span> <span class="n">Cpu032I</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">hasCpu032II</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Cpu0ArchVersion</span> <span class="o">==</span> <span class="n">Cpu032II</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>As modified as listed above, the Chapter12_1 instructions are work for cpu032I
and the added instructions in Chapter12_2 is for cpu032II.
The llc will generate cpu032I cmp, jeq,
..., instructions when <cite>llc -mcpu=cpu032I</cite> while <cite>llc -mcpu=cpu032II</cite> will
generate slt, beq when meet &#8220;if else&#8221;, &#8220;while&#8221; and &#8220;for&#8221; flow control
statements. Please notify the Cpu0ArchVersion must be initialized as the
following code, otherwise the Cpu0ArchVersion can be any value and the functions
hasCpu032I() and hasCpu032II() which support <cite>llc -mcpu=cpu032I</cite> and
<cite>llc -mcpu=cpu032II</cite> will have trouble.</p>
<p class="rubric">lbdex/Chapter3_1/Cpu0Subtarget.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0Subtarget</span><span class="o">::</span><span class="n">Cpu0Subtarget</span><span class="p">(</span><span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">TT</span><span class="p">,</span> <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">CPU</span><span class="p">,</span>
                             <span class="k">const</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="o">&amp;</span><span class="n">FS</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">little</span><span class="p">,</span>
                             <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">_RM</span><span class="p">)</span> <span class="o">:</span>
  <span class="n">Cpu0GenSubtargetInfo</span><span class="p">(</span><span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">),</span>
  <span class="n">Cpu0ArchVersion</span><span class="p">(</span><span class="n">Cpu032I</span><span class="p">),</span> <span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch12_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">test_OptSlt</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">,</span> <span class="kt">int</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">d</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">f</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">d</span> <span class="o">=</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="mi">1</span><span class="p">);</span>
  <span class="n">e</span> <span class="o">=</span> <span class="p">(</span><span class="n">b</span> <span class="o">&lt;</span> <span class="mi">2</span><span class="p">);</span>
  <span class="n">f</span> <span class="o">=</span> <span class="n">d</span> <span class="o">+</span> <span class="n">e</span><span class="p">;</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">f</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -O2
-c ch12_2.cpp -emit-llvm -o ch12_2.bc
118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch12_2.bc -o -
  ...
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  ld  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$sw</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Spill</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  cmp <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  andi  <span class="nv">$2</span>, <span class="nv">$sw</span>, 1
  ld  <span class="nv">$sw</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Reload</span>
  andi  <span class="nv">$3</span>, <span class="nv">$sw</span>, 1
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  ...
118-165-78-10:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch12_2.bc -o -
  ...
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  slti  <span class="nv">$3</span>, <span class="nv">$3</span>, 2
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  ret <span class="nv">$lr</span>
  ...
</pre></div>
</div>
<p>Run these two <cite>llc -mcpu</cite> option for Chapter12_2 with ch12_2.cpp get the
above result. Ignore the move between $sw and general purpose register in
<cite>llc -mcpu=cpu032I</cite>, the two cmp instructions in it will has hazard in
instruction reorder since both of them use $sw register while
<cite>llc -mcpu=cpu032II</cite> has not <a class="footnote-reference" href="#quantitative" id="id2">[3]</a>. The slti version can reorder as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>...
ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
slti  <span class="nv">$3</span>, <span class="nv">$3</span>, 2
ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
ret <span class="nv">$lr</span>
...
</pre></div>
</div>
</div>
<div class="section" id="cpu0-verilog-language-changes">
<h3>Cpu0 Verilog language changes<a class="headerlink" href="#cpu0-verilog-language-changes" title="Permalink to this headline">¶</a></h3>
<p class="rubric">lbdex/cpu0_verilog/cpu0IIs.v</p>
<div class="highlight-c++"><pre>`define CPU0II
// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<p>In addition to cpu0IIs.v, the &#8220;`ifdef CPU0II&#8221; in cpu0.v is added for extended
instructions, slt, beq and bne.</p>
</div>
<div class="section" id="run-the-cpu0ii">
<h3>Run the Cpu0II<a class="headerlink" href="#run-the-cpu0ii" title="Permalink to this headline">¶</a></h3>
<p>Run Chapter12_2/ with ch_run_backend.cpp to get result as below.
It match the output result as comments in ch_run_backend.cpp.</p>
<p class="rubric">lbdex/InputFiles/ch_run_backend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;ch_nolld.h&quot;</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">bool</span> <span class="n">pass</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="n">pass</span> <span class="o">=</span> <span class="n">test_nolld</span><span class="p">();</span>

  <span class="k">return</span> <span class="n">pass</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;ch_nolld.cpp&quot;</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>obj
-stats ch_run_backend.bc -o ch_run_backend.cpu0.o
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
                          ... Statistics Collected ...
<span class="o">===</span>-------------------------------------------------------------------------<span class="o">===</span>
  ...
   5 del-jmp     - Number of useless jmp deleted
  ...

118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llvm-objdump -d ch_run_backend.cpu0.o | tail -n +6| awk <span class="s1">&#39;{print &quot;/* &quot; $1</span>
<span class="s1">&quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; &quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39;</span> &gt;
../cpu0_verilog/redesign/cpu0.hex

JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/
JonathantekiiMac:cpu0_verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0IIs cpu0IIs.v
JonathantekiiMac:cpu0_verilog Jonathan<span class="nv">$ </span>./cpu0IIs
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
74
253
3
1
14
3
-126
130
-32766
32770
393307
16777222
51
2147483647
-2147483648
15
2
1
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>Run with ch8_1_1.cpp, it reduces some branches from pair instructions &#8220;CMP, JXX&#8221;
to 1 single instruction ether is BEQ or BNE, as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm
ch8_1_1.bc -o ch8_1_1.cpu0.s
118-165-77-203:InputFiles Jonathan<span class="nv">$ </span>cat ch8_1_1.cpu0.s
        .section .mdebug.abi32
        .previous
        .file <span class="s2">&quot;ch8_1_1.bc&quot;</span>
        .text
        .globl        _Z13test_control1v
        .align        2
        .type _Z13test_control1v,@function
        .ent  _Z13test_control1v      <span class="c"># @_Z13test_control1v</span>
_Z13test_control1v:
        .cfi_startproc
        .frame        <span class="nv">$fp</span>,48,<span class="nv">$lr</span>
        .mask         0x00000800,-4
        .set  noreorder
        .set  nomacro
<span class="c"># BB#0:                                 # %entry</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
<span class="nv">$tmp3</span>:
        .cfi_def_cfa_offset 48
        st    <span class="nv">$fp</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp4</span>:
        .cfi_offset 11, -4
        addu  <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
<span class="nv">$tmp5</span>:
        .cfi_def_cfa_register 11
        addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
        st    <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
        st    <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 2
        st    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 3
        st    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 4
        st    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 5
        st    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 6
        st    <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 7
        st    <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 8
        st    <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 9
        st    <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_2</span>
<span class="c"># BB#1:                                 # %if.then</span>
        ld    <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_2</span>:                                 <span class="c"># %if.end</span>
        ld    <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        beq   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_4</span>
<span class="c"># BB#3:                                 # %if.then2</span>
        ld    <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_4</span>:                                 <span class="c"># %if.end4</span>
        ld    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slti  <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_6</span>
<span class="c"># BB#5:                                 # %if.then6</span>
        ld    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_6</span>:                                 <span class="c"># %if.end8</span>
        ld    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slti  <span class="nv">$4</span>, <span class="nv">$4</span>, 0
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_8</span>
<span class="c"># BB#7:                                 # %if.then10</span>
        ld    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_8</span>:                                 <span class="c"># %if.end12</span>
        ld    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, -1
        slt   <span class="nv">$4</span>, <span class="nv">$5</span>, <span class="nv">$4</span>
        bne   <span class="nv">$4</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_10</span>
<span class="c"># BB#9:                                 # %if.then14</span>
        ld    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$4</span>, <span class="nv">$4</span>, 1
        st    <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_10</span>:                                <span class="c"># %if.end16</span>
        ld    <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slt   <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
        bne   <span class="nv">$3</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_12</span>
<span class="c"># BB#11:                                # %if.then18</span>
        ld    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$3</span>, <span class="nv">$3</span>, 1
        st    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_12</span>:                                <span class="c"># %if.end20</span>
        ld    <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slt   <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        bne   <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_14</span>
<span class="c"># BB#13:                                # %if.then22</span>
        ld    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_14</span>:                                <span class="c"># %if.end24</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slti  <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        bne   <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_16</span>
<span class="c"># BB#15:                                # %if.then26</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_16</span>:                                <span class="c"># %if.end28</span>
        ld    <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        slt   <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        beq   <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_18</span>
<span class="c"># BB#17:                                # %if.then30</span>
        ld    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_18</span>:                                <span class="c"># %if.end32</span>
        ld    <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        beq   <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$BB0_20</span>
<span class="c"># BB#19:                                # %if.then34</span>
        ld    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1
        st    <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
<span class="nv">$BB0_20</span>:                                <span class="c"># %if.end36</span>
        ld    <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        ld    <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
        ld    <span class="nv">$3</span>, 32<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        ld    <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
        addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
        addu  <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
        ld    <span class="nv">$fp</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
        addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
        ret   <span class="nv">$lr</span>
        .set  macro
        .set  reorder
        .end  _Z13test_control1v
<span class="nv">$tmp6</span>:
        .size _Z13test_control1v, <span class="o">(</span><span class="nv">$tmp6</span><span class="o">)</span>-_Z13test_control1v
        .cfi_endproc
</pre></div>
</div>
<p>The ch12_3.cpp is written in assembly for AsmParser test. You can check if it
will generate the obj.</p>
</div>
</div>
<div class="section" id="conditional-instruction">
<h2>Conditional instruction<a class="headerlink" href="#conditional-instruction" title="Permalink to this headline">¶</a></h2>
<p>Since the clang optimization level O1 or above level will generate <strong>select</strong>
and <strong>select_cc</strong> to support conditional instruction, we add this feature in
Cpu0 backend too.</p>
<p class="rubric">lbdex/InputFiles/ch12_4.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">select_1</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span> <span class="o">&lt;</span> <span class="n">b</span><span class="p">)</span>
    <span class="k">return</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="k">return</span> <span class="mi">2</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">select_2</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">a</span><span class="p">)</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">c</span> <span class="o">=</span> <span class="mi">3</span><span class="p">;</span>

  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">c</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  
  <span class="n">c</span> <span class="o">=</span> <span class="n">select_1</span><span class="p">(</span><span class="n">a</span><span class="p">,</span> <span class="n">b</span><span class="p">);</span>
  <span class="n">c</span> <span class="o">+=</span> <span class="n">select_2</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">c</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>If you run Chapter12_2 with ch12_4.cpp will get the following result.</p>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>clang -O1 -target mips-unknown-linux-gnu
-c ch12_4.cpp -emit-llvm -o ch12_4.bc
114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/
llvm-dis ch12_4.bc -o -
...
define i32 @_Z8select_1ii<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> icmp slt i32 %a, %b
  %. <span class="o">=</span> <span class="k">select </span>i1 %1, i32 1, i32 2
  ret i32 %.
<span class="o">}</span>

; Function Attrs: nounwind readnone
define i32 @_Z8select_2i<span class="o">(</span>i32 %a<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> icmp eq i32 %a, 0
  %. <span class="o">=</span> <span class="k">select </span>i1 %1, i32 3, i32 1
  ret i32 %.
<span class="o">}</span>

; Function Attrs: nounwind readnone
define i32 @_Z11test_selectii<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> tail call i32 @_Z8select_1ii<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span>
  %2 <span class="o">=</span> tail call i32 @_Z8select_2i<span class="o">(</span>i32 %a<span class="o">)</span>
  %3 <span class="o">=</span> add nsw i32 %2, %1
  ret i32 %3
<span class="o">}</span>
...

114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/
llc -march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch12_4.bc
-debug -o -
...
<span class="o">===</span> _Z8select_1ii
Initial selection DAG: BB#0 <span class="s1">&#39;_Z8select_1ii:&#39;</span>
SelectionDAG has 14 nodes:
  ...
        0x39f3fc0: <span class="nv">ch</span> <span class="o">=</span> setlt

      0x39f40c0: <span class="nv">i1</span> <span class="o">=</span> setcc 0x39f3cc0, 0x39f3ec0, 0x39f3fc0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x39f41c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt;

      0x39f42c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;2&gt;

    0x39f43c0: <span class="nv">i32</span> <span class="o">=</span> <span class="k">select </span>0x39f40c0, 0x39f41c0, 0x39f42c0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
  ...

Replacing.3 0x39f43c0: <span class="nv">i32</span> <span class="o">=</span> <span class="k">select </span>0x39f40c0, 0x39f41c0, 0x39f42c0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>

With: 0x39f47c0: <span class="nv">i32</span> <span class="o">=</span> select_cc 0x39f3cc0, 0x39f3ec0, 0x39f41c0, 0x39f42c0,
0x39f3fc0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
...
Optimized lowered selection DAG: BB#0 <span class="s1">&#39;_Z8select_1ii:&#39;</span>
SelectionDAG has 13 nodes:
  ...
      0x39f41c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt;

      0x39f42c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;2&gt;

      0x39f3fc0: <span class="nv">ch</span> <span class="o">=</span> setlt

    0x39f47c0: <span class="nv">i32</span> <span class="o">=</span> select_cc 0x39f3cc0, 0x39f3ec0, 0x39f41c0, 0x39f42c0,
    0x39f3fc0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
  ...
LLVM ERROR: Cannot <span class="k">select</span>: 0x39f47c0: <span class="nv">i32</span> <span class="o">=</span> select_cc 0x39f3cc0, 0x39f3ec0,
0x39f41c0, 0x39f42c0, 0x39f3fc0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>10<span class="o">]</span>
</pre></div>
</div>
<p>As llvm IR of ch12_4.bc as above, clang generate <strong>select</strong> IR for small
basic control block (if statement only include one assign statement).
This <strong>select</strong> IR is optimization result for CPU which has conditional
instructions support.
And from above llc command debug trace message, IR <strong>select</strong> is changed to
<strong>select_cc</strong> during DAG optimization stages.</p>
<p>Chapter12_3 support <strong>select</strong> with the following code added and changed.</p>
<p class="rubric">lbdex/Chapter12_3/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#define GET_MATCHER_IMPLEMENTATION</span>
<span class="cp">#include &quot;Cpu0GenAsmMatcher.inc&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_3/Cpu0InstInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">include</span> <span class="s">&quot;Cpu0CondMov.td&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_3/Cpu0CondMov.td</p>
<div class="highlight-c++"><pre>//===-- Cpu0CondMov.td - Describe Cpu0 Conditional Moves --*- tablegen -*--===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This is the Conditional Moves implementation.
//
//===----------------------------------------------------------------------===//

// Conditional moves:
// These instructions are expanded in
// Cpu0ISelLowering::EmitInstrWithCustomInserter if target does not have
// conditional move instructions.
// cond:int, data:int
class CondMovIntInt&lt;RegisterClass CRC, RegisterClass DRC, bits&lt;8&gt; op,
                    string instr_asm&gt; :
  FA&lt;op, (outs DRC:$ra), (ins DRC:$rb, CRC:$rc, DRC:$F),
     !strconcat(instr_asm, "\t$ra, $rb, $rc"), [], IIAlu&gt; {
  let shamt = 0;
  let Constraints = "$F = $ra";
}

// select patterns
multiclass MovzPats0Slt&lt;RegisterClass CRC, RegisterClass DRC,
                     Instruction MOVZInst, Instruction SLTOp,
                     Instruction SLTuOp, Instruction SLTiOp,
                     Instruction SLTiuOp&gt; {
  def : Pat&lt;(select (i32 (setge CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTOp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setuge CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTuOp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setge CRC:$lhs, immSExt16:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTiOp CRC:$lhs, immSExt16:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setuge CRC:$lh, immSExt16:$rh)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTiuOp CRC:$lh, immSExt16:$rh), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setle CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTOp CRC:$rhs, CRC:$lhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setule CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (SLTuOp CRC:$rhs, CRC:$lhs), DRC:$F)&gt;;
}

multiclass MovzPats1&lt;RegisterClass CRC, RegisterClass DRC,
                     Instruction MOVZInst, Instruction XOROp&gt; {
  def : Pat&lt;(select (i32 (seteq CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, (XOROp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (seteq CRC:$lhs, 0)), DRC:$T, DRC:$F),
            (MOVZInst DRC:$T, CRC:$lhs, DRC:$F)&gt;;
}

multiclass MovnPats&lt;RegisterClass CRC, RegisterClass DRC, Instruction MOVNInst,
                    Instruction XOROp&gt; {
  def : Pat&lt;(select (i32 (setne CRC:$lhs, CRC:$rhs)), DRC:$T, DRC:$F),
            (MOVNInst DRC:$T, (XOROp CRC:$lhs, CRC:$rhs), DRC:$F)&gt;;
  def : Pat&lt;(select CRC:$cond, DRC:$T, DRC:$F),
            (MOVNInst DRC:$T, CRC:$cond, DRC:$F)&gt;;
  def : Pat&lt;(select (i32 (setne CRC:$lhs, 0)),DRC:$T, DRC:$F),
            (MOVNInst DRC:$T, CRC:$lhs, DRC:$F)&gt;;
}

// Instantiation of instructions.
def MOVZ_I_I     : CondMovIntInt&lt;CPURegs, CPURegs, 0x0a, "movz"&gt;;

def MOVN_I_I     : CondMovIntInt&lt;CPURegs, CPURegs, 0x0b, "movn"&gt;;

// Instantiation of conditional move patterns.
let Predicates = [HasSlt] in {
defm : MovzPats0Slt&lt;CPURegs, CPURegs, MOVZ_I_I, SLT, SLTu, SLTi, SLTiu&gt;;
}

defm : MovzPats1&lt;CPURegs, CPURegs, MOVZ_I_I, XOR&gt;;

defm : MovnPats&lt;CPURegs, CPURegs, MOVN_I_I, XOR&gt;;

</pre>
</div>
<p class="rubric">lbdex/Chapter12_3/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span> <span class="n">lowerSELECT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter12_3/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SELECT</span><span class="p">,</span>             <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>   <span class="n">Custom</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SELECT_CC</span><span class="p">,</span>         <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">SELECT</span><span class="o">:</span>             <span class="k">return</span> <span class="n">lowerSELECT</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">lowerSELECT</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Set ISD::SELECT_CC to Expand will stop llvm optimization to merge setcc and
select into one IR select_cc <a class="footnote-reference" href="#id6" id="id3">[2]</a>. Next the LowerSELECT() return ISD::SELECT as
Op code directly. Finally the pattern define in Cpu0CondMov.td will
translate the <strong>select</strong> IR into <strong>movz</strong> or <strong>movn</strong> conditional instruction.
Let&#8217;s run Chapter12_3 with ch12_4.cpp and ch_optimize.cpp to get the following
result.
Again, the cpu032II use <strong>slt</strong> instead of <strong>cmp</strong> has a little improved in
instructions number.</p>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch12_4.bc -debug
-o -
...
<span class="o">===</span> _Z8select_1ii
Initial selection DAG: BB#0 <span class="s1">&#39;_Z8select_1ii:&#39;</span>
SelectionDAG has 14 nodes:
  ...
        0x3d87fc0: <span class="nv">ch</span> <span class="o">=</span> setlt

      0x3d880c0: <span class="nv">i1</span> <span class="o">=</span> setcc 0x3d87cc0, 0x3d87ec0, 0x3d87fc0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x3d881c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt;

      0x3d882c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;2&gt;

    0x3d883c0: <span class="nv">i32</span> <span class="o">=</span> <span class="k">select </span>0x3d880c0, 0x3d881c0, 0x3d882c0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
  ...
Optimized lowered selection DAG: BB#0 <span class="s1">&#39;_Z8select_1ii:&#39;</span>
SelectionDAG has 14 nodes:
  ...
        0x3d87fc0: <span class="nv">ch</span> <span class="o">=</span> setlt

      0x3d880c0: <span class="nv">i1</span> <span class="o">=</span> setcc 0x3d87cc0, 0x3d87ec0, 0x3d87fc0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span>

      0x3d881c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1&gt;

      0x3d882c0: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;2&gt;

    0x3d883c0: <span class="nv">i32</span> <span class="o">=</span> <span class="k">select </span>0x3d880c0, 0x3d881c0, 0x3d882c0 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>2<span class="o">]</span>
  ...

114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032I -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch12_4.bc -o -
      .section .mdebug.abi32
      .previous
      .file   <span class="s2">&quot;ch12_4.bc&quot;</span>
      .text
      .globl  _Z8select_1ii
      .align  2
      .type   _Z8select_1ii,@function
      .ent    _Z8select_1ii           <span class="c"># @_Z8select_1ii</span>
_Z8select_1ii:
      .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
      .mask   0x00000000,0
      .set    noreorder
      .set    nomacro
<span class="c"># BB#0:</span>
      ld      <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      cmp     <span class="nv">$sw</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
      andi    <span class="nv">$3</span>, <span class="nv">$sw</span>, 1
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
      addiu   <span class="nv">$4</span>, <span class="nv">$zero</span>, 1
      movn    <span class="nv">$2</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
      ret     <span class="nv">$lr</span>
      .set    macro
      .set    reorder
      .end    _Z8select_1ii
<span class="nv">$tmp0</span>:
      .size   _Z8select_1ii, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z8select_1ii

      .globl  _Z8select_2i
      .align  2
      .type   _Z8select_2i,@function
      .ent    _Z8select_2i            <span class="c"># @_Z8select_2i</span>
_Z8select_2i:
      .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
      .mask   0x00000000,0
      .set    noreorder
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
      ld      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$4</span>, <span class="nv">$zero</span>, 3
      movz    <span class="nv">$2</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
      ret     <span class="nv">$lr</span>
      .set    macro
      .set    reorder
      .end    _Z8select_2i
<span class="nv">$tmp1</span>:
      .size   _Z8select_2i, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z8select_2i

      .globl  _Z11test_selectii
      .align  2
      .type   _Z11test_selectii,@function
      .ent    _Z11test_selectii       <span class="c"># @_Z11test_selectii</span>
_Z11test_selectii:
      .frame  <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
      .mask   0x00004300,-4
      .set    noreorder
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
      st      <span class="nv">$lr</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
      st      <span class="nv">$9</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Spill</span>
      st      <span class="nv">$8</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Spill</span>
      ld      <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$9</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$9</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      jsub    _Z8select_1ii
      add     <span class="nv">$8</span>, <span class="nv">$zero</span>, <span class="nv">$2</span>
      st      <span class="nv">$9</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      jsub    _Z8select_2i
      addu    <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$8</span>
      ld      <span class="nv">$8</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Reload</span>
      ld      <span class="nv">$9</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Reload</span>
      ld      <span class="nv">$lr</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
      ret     <span class="nv">$lr</span>
      .set    macro
      .set    reorder
      .end    _Z11test_selectii
<span class="nv">$tmp4</span>:
      .size   _Z11test_selectii, <span class="o">(</span><span class="nv">$tmp4</span><span class="o">)</span>-_Z11test_selectii

114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch12_4.bc -o -
      .section .mdebug.abi32
      .previous
      .file   <span class="s2">&quot;ch12_4.bc&quot;</span>
      .text
      .globl  _Z8select_1ii
      .align  2
      .type   _Z8select_1ii,@function
      .ent    _Z8select_1ii           <span class="c"># @_Z8select_1ii</span>
_Z8select_1ii:
      .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
      .mask   0x00000000,0
      .set    noreorder
      .set    nomacro
<span class="c"># BB#0:</span>
      ld      <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      slt     <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
      addiu   <span class="nv">$4</span>, <span class="nv">$zero</span>, 1
      movn    <span class="nv">$2</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
      ret     <span class="nv">$lr</span>
      ...
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch_optimize.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;boot.cpp&quot;</span>

<span class="cp">#include &quot;print.h&quot;</span>

<span class="kt">int</span> <span class="nf">test_select</span><span class="p">(</span><span class="kt">int</span> <span class="n">a</span><span class="p">,</span> <span class="kt">int</span> <span class="n">b</span><span class="p">);</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">test_select</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">);</span> <span class="c1">// 4</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 4</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;print.cpp&quot;</span>

<span class="cp">#include &quot;ch12_4.cpp&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/build-optimize.sh</p>
<div class="highlight-c++"><pre>#!/usr/bin/env bash
OS=`uname -s`
echo "OS =" ${OS}

if [ "$OS" == "Linux" ]; then
  TOOLDIR=/usr/local/llvm/test/cmake_debug_build/bin
else
  TOOLDIR=~/llvm/test/cmake_debug_build/bin/Debug
fi

if [ "$1" != "" ] &amp;&amp; [ $1 != cpu032I ] &amp;&amp; [ $1 != cpu032II ]; then
  echo "1st argument is cpu032I (default) or cpu032II"
  exit 1
fi
if [ "$1" == "" ]; then
  CPU=cpu032I
else
  CPU=$1
fi
echo "CPU =" "${CPU}"

bash rminput.sh

clang -O1 -target mips-unknown-linux-gnu -c ch_optimize.cpp -emit-llvm -o \
ch_optimize.bc
${TOOLDIR}/llc -march=cpu0 -mcpu=${cpu} -relocation-model=static -filetype=obj \
ch_optimize.bc -o ch_optimize.cpu0.o
${TOOLDIR}/llvm-objdump -d ch_optimize.cpu0.o | tail -n +6| awk \
'{print "/* " $1 " */\t" $2 " " $3 " " $4 " " $5 "\t/* " $6"\t" $7" " $8" \
" $9" " $10 "\t*/"}' &gt; ../cpu0_verilog/cpu0.hex
</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>bash build-optimize.sh
<span class="nv">OS</span> <span class="o">=</span> Darwin
<span class="nv">CPU</span> <span class="o">=</span> cpu032I
...
114-37-150-209:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/
114-37-150-209:cpu0_verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0Is cpu0Is.v
114-37-150-209:cpu0_verilog Jonathan<span class="nv">$ </span>./cpu0Is
WARNING: ./cpu0.v:373: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for</span>
the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
2
RET to PC &lt; 0, finished!

114-37-150-209:cpu0_verilog Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../InputFiles/
114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>bash build-optimize.sh cpu032II
<span class="nv">OS</span> <span class="o">=</span> Darwin
<span class="nv">CPU</span> <span class="o">=</span> cpu032II
...
114-37-150-209:InputFiles Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../cpu0_verilog/
114-37-150-209:cpu0_verilog Jonathan<span class="nv">$ </span>iverilog -o cpu0IIs cpu0IIs.v
114-37-150-209:cpu0_verilog Jonathan<span class="nv">$ </span>./cpu0IIs
WARNING: ./cpu0.v:373: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for</span>
the requested range <span class="o">[</span>0:524287<span class="o">]</span>.
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
2
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>Compare to the non-optimize version which don&#8217;t use conditional move
instructions as the following. The clang use <strong>select</strong> IR in small basic block
to reduce the branch cost in pipeline machine since the branch will make the
pipeline stall.
But it needs the conditional instruction support <a class="footnote-reference" href="#quantitative" id="id4">[3]</a>.
If your backend has no conditional instruction and want the clang compiler with
optimization option <strong>O1</strong> level above, you can change clang to force it
generate traditional branch basic block instead of IR <strong>select</strong>.
RISC CPU came from pipeline advantage and add more and more instruction as time
passed. Compare Mips and ARM, the Mips has only <strong>movz</strong> and <strong>movn</strong> two
instructions while ARM has many. We create Cpu0 instructions as a RISC pipeline
machine as well as simple instructions for compiler toolchain tutorial.
Anyway the <strong>cmp</strong> instruction hired because many programmer used
it in pass and now (ARM use it). It match the thinking in assembly programming.
But the <strong>slt</strong> instruction is more efficient in RISC pipleline.
If you designed a backend aimed for C/C++ highlevel language, you should
consider <strong>slt</strong> instead <strong>cmp</strong>. Assembly is rare case in programming and
the assembly programmer can accept <strong>slt</strong> too since usually they are
professional.</p>
<div class="highlight-bash"><div class="highlight"><pre>114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>clang -O0 -target mips-unknown-linux-gnu
-c ch12_4.cpp -emit-llvm -o ch12_4.bc

114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/
llvm-dis ch12_4.bc -o -
...
define i32 @_Z8select_1ii<span class="o">(</span>i32 %a, i32 %b<span class="o">)</span> <span class="c">#0 {</span>
  %1 <span class="o">=</span> alloca i32, align 4
  %2 <span class="o">=</span> alloca i32, align 4
  %3 <span class="o">=</span> alloca i32, align 4
  %c <span class="o">=</span> alloca i32, align 4
  store i32 %a, i32* %2, align 4
  store i32 %b, i32* %3, align 4
  store i32 0, i32* %c, align 4
  %4 <span class="o">=</span> load i32* %2, align 4
  %5 <span class="o">=</span> load i32* %3, align 4
  %6 <span class="o">=</span> icmp slt i32 %4, %5
  br i1 %6, label %7, label %8

; &lt;label&gt;:7                                       ; <span class="nv">preds</span> <span class="o">=</span> %0
  store i32 1, i32* %1
  br label %9

; &lt;label&gt;:8                                       ; <span class="nv">preds</span> <span class="o">=</span> %0
  store i32 2, i32* %1
  br label %9

; &lt;label&gt;:9                                       ; <span class="nv">preds</span> <span class="o">=</span> %8, %7
  %10 <span class="o">=</span> load i32* %1
  ret i32 %10
<span class="o">}</span>
...

114-37-150-209:InputFiles Jonathan<span class="nv">$ </span>~/llvm/test/cmake_debug_build/bin/Debug/llc
-march<span class="o">=</span>cpu0 -mcpu<span class="o">=</span>cpu032II -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch12_4.bc -o -
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch12_4.bc&quot;</span>
  .text
  .globl  _Z8select_1ii
  .align  2
  .type _Z8select_1ii,@function
  .ent  _Z8select_1ii           <span class="c"># @_Z8select_1ii</span>
_Z8select_1ii:
  .frame  <span class="nv">$sp</span>,16,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  slt <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  beq <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$BB0_2</span>
<span class="c"># BB#1:</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jmp <span class="nv">$BB0_3</span>
<span class="nv">$BB0_2</span>:
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
<span class="nv">$BB0_3</span>:
  ld  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
</pre></div>
</div>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td>On a platform with cache and DRAM, the cache miss cost serveral tens
time of instruction cycle. The compiler engineers work in the vendor of
platform solution spend much effort try to reduce the cache miss for
speed. Reduce code size will cut down the cache miss frequency too.</td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[2]</a></td><td><a class="reference external" href="http://llvm.org/docs/WritingAnLLVMBackend.html#expand">http://llvm.org/docs/WritingAnLLVMBackend.html#expand</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="quantitative" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label">[3]</td><td><em>(<a class="fn-backref" href="#id2">1</a>, <a class="fn-backref" href="#id4">2</a>)</em> See book Computer Architecture: A Quantitative Approach (The Morgan
Kaufmann Series in Computer Architecture and Design)</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        <a class="uplink" href="index.html">Contents</a>
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>