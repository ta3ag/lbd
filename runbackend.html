<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Run backend &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.0',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="Backend Optimization" href="optimize.html" />
    <link rel="prev" title="ELF Support" href="elf.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Run backend</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="optimize.html">Backend Optimization</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="run-backend">
<span id="sec-runbackend"></span><h1>Run backend<a class="headerlink" href="#run-backend" title="Permalink to this headline">¶</a></h1>
<p>This chapter will add LLVM AsmParser support first.
With AsmParser support, we can hand code the assembly language in C/C++ file
and translate it into obj (elf format).
We can write a C++ main
function as well as the boot code by assembly hand code, and translate this
main()+bootcode() into obj file.
Combined with llvm-objdump support in last chapter,
this main()+bootcode() elf can be translated into hex file format which
include the disassemble code as comment.
Furthermore, we can design the Cpu0 with Verilog language tool and run the Cpu0
backend on PC by feed the hex file and see the Cpu0 instructions execution
result.</p>
<div class="section" id="asmparser-support">
<h2>AsmParser support<a class="headerlink" href="#asmparser-support" title="Permalink to this headline">¶</a></h2>
<p>This section list all the AsmParser code for cpu0 backend but with only a few
explanation. Please refer here <a class="footnote-reference" href="#id4" id="id1">[1]</a> for more AsmParser explanation.</p>
<p>Run Chapter10_1/ with ch11_1.cpp will get the following error message.</p>
<p class="rubric">lbdex/InputFiles/ch11_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld	$2, 8($sp)&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;st	$0, 4($sp)&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $3,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;add $3, $1, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;sub $3, $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mul $2, $1, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;div $3, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;divu $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;and $2, $1, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;or $3, $1, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;xor $1, $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mult $4, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;multu $3, $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mfhi $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mflo $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mthi $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;mtlo $2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;sra $2, $2, 2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;rol $2, $1, 3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;ror $3, $3, 4&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;shl $2, $2, 2&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;shr $2, $3, 5&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;cmp $sw, $2, $3&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jeq $sw, 20&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jne $sw, 16&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jlt $sw, -20&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jle $sw, -16&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jgt $sw, -4&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jge $sw, -12&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;swi 0x00000400&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jsub 0x000010000&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;ret $lr&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;jalr $t9&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;li $3, 0x00700000&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;la $3, 0x00800000($6)&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;la $3, 0x00900000&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-bash"><pre>JonathantekiiMac:InputFiles Jonathan$ clang -c ch11_1.cpp -emit-llvm -o
ch11_1.bc
JonathantekiiMac:InputFiles Jonathan$ /Users/Jonathan/llvm/test/cmake_debug_
build/bin/Debug/llc -march=cpu0 -relocation-model=pic -filetype=obj ch11_1.bc
-o ch11_1.cpu0.o
LLVM ERROR: Inline asm not supported by this streamer because we don't have
an asm parser for this target</pre>
</div>
<p>Since we didn&#8217;t implement cpu0 assembler, it has the error message as above.
The cpu0 can translate LLVM IR into assembly and obj directly, but it cannot
translate hand code assembly instructions into obj.
Directory AsmParser handle the assembly to obj translation.
The Chapter11_1/ include AsmParser implementation as follows,</p>
<p class="rubric">lbdex/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0AsmParser.cpp - Parse Cpu0 assembly to MCInst instructions ----===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#include &quot;MCTargetDesc/Cpu0MCTargetDesc.h&quot;</span>
<span class="cp">#include &quot;Cpu0RegisterInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/StringSwitch.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCContext.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCExpr.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCInst.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCStreamer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSubtargetInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCSymbol.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCParser/MCAsmLexer.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCParser/MCParsedAsmOperand.h&quot;</span>
<span class="cp">#include &quot;llvm/MC/MCTargetAsmParser.h&quot;</span>
<span class="cp">#include &quot;llvm/Support/TargetRegistry.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0AssemblerOptions</span> <span class="p">{</span>
<span class="nl">public:</span>
  <span class="n">Cpu0AssemblerOptions</span><span class="p">()</span><span class="o">:</span>
    <span class="n">aTReg</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span> <span class="n">reorder</span><span class="p">(</span><span class="nb">true</span><span class="p">),</span> <span class="n">macro</span><span class="p">(</span><span class="nb">true</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isReorder</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">reorder</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setReorder</span><span class="p">()</span> <span class="p">{</span><span class="n">reorder</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setNoreorder</span><span class="p">()</span> <span class="p">{</span><span class="n">reorder</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;}</span>

  <span class="kt">bool</span> <span class="n">isMacro</span><span class="p">()</span> <span class="p">{</span><span class="k">return</span> <span class="n">macro</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setMacro</span><span class="p">()</span> <span class="p">{</span><span class="n">macro</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;}</span>
  <span class="kt">void</span> <span class="n">setNomacro</span><span class="p">()</span> <span class="p">{</span><span class="n">macro</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;}</span>

<span class="nl">private:</span>
  <span class="kt">unsigned</span> <span class="n">aTReg</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">reorder</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">macro</span><span class="p">;</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>
<span class="k">class</span> <span class="nc">Cpu0AsmParser</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCTargetAsmParser</span> <span class="p">{</span>
  <span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">STI</span><span class="p">;</span>
  <span class="n">MCAsmParser</span> <span class="o">&amp;</span><span class="n">Parser</span><span class="p">;</span>
  <span class="n">Cpu0AssemblerOptions</span> <span class="n">Options</span><span class="p">;</span>


<span class="cp">#define GET_ASSEMBLER_HEADER</span>
<span class="cp">#include &quot;Cpu0GenAsmMatcher.inc&quot;</span>

  <span class="kt">bool</span> <span class="nf">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                               <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                               <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                               <span class="kt">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ParseRegister</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">StartLoc</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">EndLoc</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ParseInstruction</span><span class="p">(</span><span class="n">ParseInstructionInfo</span> <span class="o">&amp;</span><span class="n">Info</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span>
                        <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">parseMathOperation</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ParseDirective</span><span class="p">(</span><span class="n">AsmToken</span> <span class="n">DirectiveID</span><span class="p">);</span>

  <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span>
  <span class="n">parseMemOperand</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;&amp;</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">ParseOperand</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">tryParseRegister</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">tryParseRegisterOperand</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                               <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">);</span>

  <span class="kt">void</span> <span class="nf">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">expandLoadImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">expandLoadAddressImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">void</span> <span class="nf">expandLoadAddressReg</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">reportParseError</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">ErrorMsg</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">parseMemOffset</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">);</span>
  <span class="kt">bool</span> <span class="nf">parseRelocOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">);</span>

  <span class="kt">bool</span> <span class="nf">parseDirectiveSet</span><span class="p">();</span>

  <span class="kt">bool</span> <span class="nf">parseSetAtDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetNoAtDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetMacroDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetNoMacroDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetReorderDirective</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="nf">parseSetNoReorderDirective</span><span class="p">();</span>

  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">getVariantKind</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">matchRegisterName</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">);</span>

  <span class="kt">int</span> <span class="nf">matchRegisterByNumber</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="nf">getReg</span><span class="p">(</span><span class="kt">int</span> <span class="n">RC</span><span class="p">,</span><span class="kt">int</span> <span class="n">RegNo</span><span class="p">);</span>

<span class="nl">public:</span>
  <span class="n">Cpu0AsmParser</span><span class="p">(</span><span class="n">MCSubtargetInfo</span> <span class="o">&amp;</span><span class="n">sti</span><span class="p">,</span> <span class="n">MCAsmParser</span> <span class="o">&amp;</span><span class="n">parser</span><span class="p">)</span>
    <span class="o">:</span> <span class="n">MCTargetAsmParser</span><span class="p">(),</span> <span class="n">STI</span><span class="p">(</span><span class="n">sti</span><span class="p">),</span> <span class="n">Parser</span><span class="p">(</span><span class="n">parser</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// Initialize the set of available features.</span>
    <span class="n">setAvailableFeatures</span><span class="p">(</span><span class="n">ComputeAvailableFeatures</span><span class="p">(</span><span class="n">STI</span><span class="p">.</span><span class="n">getFeatureBits</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="n">MCAsmParser</span> <span class="o">&amp;</span><span class="n">getParser</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Parser</span><span class="p">;</span> <span class="p">}</span>
  <span class="n">MCAsmLexer</span> <span class="o">&amp;</span><span class="n">getLexer</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getLexer</span><span class="p">();</span> <span class="p">}</span>

<span class="p">};</span>
<span class="p">}</span>

<span class="k">namespace</span> <span class="p">{</span>

<span class="c1">/// Cpu0Operand - Instances of this class represent a parsed Cpu0 machine</span>
<span class="c1">/// instruction.</span>
<span class="k">class</span> <span class="nc">Cpu0Operand</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MCParsedAsmOperand</span> <span class="p">{</span>

  <span class="k">enum</span> <span class="n">KindTy</span> <span class="p">{</span>
    <span class="n">k_CondCode</span><span class="p">,</span>
    <span class="n">k_CoprocNum</span><span class="p">,</span>
    <span class="n">k_Immediate</span><span class="p">,</span>
    <span class="n">k_Memory</span><span class="p">,</span>
    <span class="n">k_PostIndexRegister</span><span class="p">,</span>
    <span class="n">k_Register</span><span class="p">,</span>
    <span class="n">k_Token</span>
  <span class="p">}</span> <span class="n">Kind</span><span class="p">;</span>

  <span class="n">Cpu0Operand</span><span class="p">(</span><span class="n">KindTy</span> <span class="n">K</span><span class="p">)</span> <span class="o">:</span> <span class="n">MCParsedAsmOperand</span><span class="p">(),</span> <span class="n">Kind</span><span class="p">(</span><span class="n">K</span><span class="p">)</span> <span class="p">{}</span>

  <span class="k">union</span> <span class="p">{</span>
    <span class="k">struct</span> <span class="p">{</span>
      <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">Data</span><span class="p">;</span>
      <span class="kt">unsigned</span> <span class="n">Length</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">Tok</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">Reg</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
      <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Val</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">Imm</span><span class="p">;</span>

    <span class="k">struct</span> <span class="p">{</span>
      <span class="kt">unsigned</span> <span class="n">Base</span><span class="p">;</span>
      <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Off</span><span class="p">;</span>
    <span class="p">}</span> <span class="n">Mem</span><span class="p">;</span>
  <span class="p">};</span>

  <span class="n">SMLoc</span> <span class="n">StartLoc</span><span class="p">,</span> <span class="n">EndLoc</span><span class="p">;</span>

<span class="nl">public:</span>
  <span class="kt">void</span> <span class="nf">addRegOperands</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>
    <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">getReg</span><span class="p">()));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addExpr</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">)</span> <span class="k">const</span><span class="p">{</span>
    <span class="c1">// Add as immediate when possible.  Null MCExpr = 0.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Expr</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
      <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
    <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">CE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">))</span>
      <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">CE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">()));</span>
    <span class="k">else</span>
      <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateExpr</span><span class="p">(</span><span class="n">Expr</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addImmOperands</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">getImm</span><span class="p">();</span>
    <span class="n">addExpr</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">Expr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">void</span> <span class="n">addMemOperands</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">N</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">N</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid number of operands!&quot;</span><span class="p">);</span>

    <span class="n">Inst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">getMemBase</span><span class="p">()));</span>

    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span> <span class="o">=</span> <span class="n">getMemOff</span><span class="p">();</span>
    <span class="n">addExpr</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">Expr</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">bool</span> <span class="n">isReg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Register</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isImm</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Immediate</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isToken</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Token</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isMem</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Memory</span><span class="p">;</span> <span class="p">}</span>

  <span class="n">StringRef</span> <span class="n">getToken</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Token</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nf">StringRef</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">Data</span><span class="p">,</span> <span class="n">Tok</span><span class="p">.</span><span class="n">Length</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">getReg</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Register</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Reg</span><span class="p">.</span><span class="n">RegNum</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">getImm</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Immediate</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Imm</span><span class="p">.</span><span class="n">Val</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">unsigned</span> <span class="n">getMemBase</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Memory</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Mem</span><span class="p">.</span><span class="n">Base</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">getMemOff</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">assert</span><span class="p">((</span><span class="n">Kind</span> <span class="o">==</span> <span class="n">k_Memory</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Invalid access!&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">Mem</span><span class="p">.</span><span class="n">Off</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Str</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">S</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">Op</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0Operand</span><span class="p">(</span><span class="n">k_Token</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Tok</span><span class="p">.</span><span class="n">Data</span> <span class="o">=</span> <span class="n">Str</span><span class="p">.</span><span class="n">data</span><span class="p">();</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Tok</span><span class="p">.</span><span class="n">Length</span> <span class="o">=</span> <span class="n">Str</span><span class="p">.</span><span class="n">size</span><span class="p">();</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">CreateReg</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">S</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">Op</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0Operand</span><span class="p">(</span><span class="n">k_Register</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Reg</span><span class="p">.</span><span class="n">RegNum</span> <span class="o">=</span> <span class="n">RegNum</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">CreateImm</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Val</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">S</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">Op</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0Operand</span><span class="p">(</span><span class="n">k_Immediate</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Imm</span><span class="p">.</span><span class="n">Val</span> <span class="o">=</span> <span class="n">Val</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">static</span> <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">CreateMem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">Base</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Off</span><span class="p">,</span>
                                 <span class="n">SMLoc</span> <span class="n">S</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">E</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">Op</span> <span class="o">=</span> <span class="k">new</span> <span class="n">Cpu0Operand</span><span class="p">(</span><span class="n">k_Memory</span><span class="p">);</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Mem</span><span class="p">.</span><span class="n">Base</span> <span class="o">=</span> <span class="n">Base</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">Mem</span><span class="p">.</span><span class="n">Off</span> <span class="o">=</span> <span class="n">Off</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">StartLoc</span> <span class="o">=</span> <span class="n">S</span><span class="p">;</span>
    <span class="n">Op</span><span class="o">-&gt;</span><span class="n">EndLoc</span> <span class="o">=</span> <span class="n">E</span><span class="p">;</span>
    <span class="k">return</span> <span class="n">Op</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="c1">/// getStartLoc - Get the location of the first token of this operand.</span>
  <span class="n">SMLoc</span> <span class="n">getStartLoc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">StartLoc</span><span class="p">;</span> <span class="p">}</span>
  <span class="c1">/// getEndLoc - Get the location of the last token of this operand.</span>
  <span class="n">SMLoc</span> <span class="n">getEndLoc</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">EndLoc</span><span class="p">;</span> <span class="p">}</span>

  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">print</span><span class="p">(</span><span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;unimplemented!&quot;</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">};</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="nl">default:</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
      <span class="k">return</span> <span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
    <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandLoadImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">MCInst</span> <span class="n">tmpInst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">ImmOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ImmOp</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected immediate operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">RegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>

  <span class="kt">int</span> <span class="n">ImmValue</span> <span class="o">=</span> <span class="n">ImmOp</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="n">tmpInst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span> <span class="mi">0</span> <span class="o">&lt;=</span> <span class="n">ImmValue</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&lt;=</span> <span class="mi">65535</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for 0 &lt;= j &lt;= 65535.</span>
    <span class="c1">// li d,j =&gt; ori d,$zero,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span>
              <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span> <span class="n">ImmValue</span> <span class="o">&lt;</span> <span class="mi">0</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&gt;=</span> <span class="o">-</span><span class="mi">32768</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for -32768 &lt;= j &lt; 0.</span>
    <span class="c1">// li d,j =&gt; addiu d,$zero,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">);</span> <span class="c1">//TODO:no ADDiu64 in td files?</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span>
              <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// for any other value of j that is representable as a 32-bit integer.</span>
    <span class="c1">// li d,j =&gt; lui d,hi16(j)</span>
    <span class="c1">//           ori d,d,lo16(j)</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">((</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">MCInst</span> <span class="n">tmpInst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">ImmOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ImmOp</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected immediate operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">SrcRegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">SrcRegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">DstRegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ImmValue</span> <span class="o">=</span> <span class="n">ImmOp</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">-</span><span class="mi">32768</span> <span class="o">&lt;=</span> <span class="n">ImmValue</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&lt;=</span> <span class="mi">32767</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for -32768 &lt;= j &lt; 32767.</span>
    <span class="c1">//la d,j(s) =&gt; addiu d,s,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">);</span> <span class="c1">//TODO:no ADDiu64 in td files?</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">SrcRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// for any other value of j that is representable as a 32-bit integer.</span>
    <span class="c1">// la d,j(s) =&gt; lui d,hi16(j)</span>
    <span class="c1">//              ori d,d,lo16(j)</span>
    <span class="c1">//              add d,d,s</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">((</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">DstRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">SrcRegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="n">MCInst</span> <span class="n">tmpInst</span><span class="p">;</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">ImmOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">ImmOp</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected immediate operand kind&quot;</span><span class="p">);</span>
  <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">RegOp</span> <span class="o">=</span> <span class="n">Inst</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">isReg</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;expected register operand kind&quot;</span><span class="p">);</span>
  <span class="kt">int</span> <span class="n">ImmValue</span> <span class="o">=</span> <span class="n">ImmOp</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>
  <span class="k">if</span> <span class="p">(</span> <span class="o">-</span><span class="mi">32768</span> <span class="o">&lt;=</span> <span class="n">ImmValue</span> <span class="o">&amp;&amp;</span> <span class="n">ImmValue</span> <span class="o">&lt;=</span> <span class="mi">32767</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// for -32768 &lt;= j &lt; 32767.</span>
    <span class="c1">//la d,j =&gt; addiu d,$zero,j</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDiu</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span>
              <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="c1">// for any other value of j that is representable as a 32-bit integer.</span>
    <span class="c1">// la d,j =&gt; lui d,hi16(j)</span>
    <span class="c1">//           ori d,d,lo16(j)</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">((</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">clear</span><span class="p">();</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">setOpcode</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ORi</span><span class="p">);</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegOp</span><span class="p">.</span><span class="n">getReg</span><span class="p">()));</span>
    <span class="n">tmpInst</span><span class="p">.</span><span class="n">addOperand</span><span class="p">(</span><span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">ImmValue</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">));</span>
    <span class="n">Instructions</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">tmpInst</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
                        <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                        <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
                        <span class="kt">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">MatchResult</span> <span class="o">=</span> <span class="n">MatchInstructionImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">ErrorInfo</span><span class="p">,</span>
                                              <span class="n">MatchingInlineAsm</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MatchResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_Success</span>: <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Instructions</span><span class="p">;</span>
      <span class="n">expandInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
      <span class="k">for</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span><span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">Instructions</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span><span class="o">++</span><span class="p">){</span>
        <span class="n">Out</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Instructions</span><span class="p">[</span><span class="n">i</span><span class="p">]);</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
        <span class="n">Inst</span><span class="p">.</span><span class="n">setLoc</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">);</span>
        <span class="n">Out</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Match_MissingFeature</span>:
    <span class="n">Error</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="s">&quot;instruction requires a CPU feature not currently enabled&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_InvalidOperand</span>: <span class="p">{</span>
    <span class="n">SMLoc</span> <span class="n">ErrorLoc</span> <span class="o">=</span> <span class="n">IDLoc</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ErrorInfo</span> <span class="o">!=</span> <span class="o">~</span><span class="mi">0U</span><span class="p">)</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ErrorInfo</span> <span class="o">&gt;=</span> <span class="n">Operands</span><span class="p">.</span><span class="n">size</span><span class="p">())</span>
        <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="s">&quot;too few operands for instruction&quot;</span><span class="p">);</span>

      <span class="n">ErrorLoc</span> <span class="o">=</span> <span class="p">((</span><span class="n">Cpu0Operand</span><span class="o">*</span><span class="p">)</span><span class="n">Operands</span><span class="p">[</span><span class="n">ErrorInfo</span><span class="p">])</span><span class="o">-&gt;</span><span class="n">getStartLoc</span><span class="p">();</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ErrorLoc</span> <span class="o">==</span> <span class="n">SMLoc</span><span class="p">())</span> <span class="n">ErrorLoc</span> <span class="o">=</span> <span class="n">IDLoc</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="n">ErrorLoc</span><span class="p">,</span> <span class="s">&quot;invalid operand for instruction&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">Match_MnemonicFail</span>:
    <span class="k">return</span> <span class="n">Error</span><span class="p">(</span><span class="n">IDLoc</span><span class="p">,</span> <span class="s">&quot;invalid instruction&quot;</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">matchRegisterName</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">)</span> <span class="p">{</span>

   <span class="kt">int</span> <span class="n">CC</span><span class="p">;</span>
    <span class="n">CC</span> <span class="o">=</span> <span class="n">StringSwitch</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Name</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;zero&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;at&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;v0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;v1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">V1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;a0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">A0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;a1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;t9&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;t0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">T0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;s0&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">S0</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;s1&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">S1</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;s2&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">S2</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;gp&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;fp&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;sp&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lr&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">LR</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;pc&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">PC</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">HI</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lo&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">LO</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;sw&quot;</span><span class="p">,</span>  <span class="n">Cpu0</span><span class="o">::</span><span class="n">SW</span><span class="p">)</span>
      <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">CC</span> <span class="o">!=</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="n">CC</span><span class="p">;</span>

  <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">getReg</span><span class="p">(</span><span class="kt">int</span> <span class="n">RC</span><span class="p">,</span><span class="kt">int</span> <span class="n">RegNo</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="o">*</span><span class="p">(</span><span class="n">getContext</span><span class="p">().</span><span class="n">getRegisterInfo</span><span class="p">().</span><span class="n">getRegClass</span><span class="p">(</span><span class="n">RC</span><span class="p">).</span><span class="n">begin</span><span class="p">()</span> <span class="o">+</span> <span class="n">RegNo</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">matchRegisterByNumber</span><span class="p">(</span><span class="kt">unsigned</span> <span class="n">RegNum</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RegNum</span> <span class="o">&gt;</span> <span class="mi">15</span><span class="p">)</span>
    <span class="k">return</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">return</span> <span class="nf">getReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClassID</span><span class="p">,</span> <span class="n">RegNum</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">tryParseRegister</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">RegNum</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Identifier</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">lowerCase</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">().</span><span class="n">lower</span><span class="p">();</span>
    <span class="n">RegNum</span> <span class="o">=</span> <span class="n">matchRegisterName</span><span class="p">(</span><span class="n">lowerCase</span><span class="p">);</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Integer</span><span class="p">))</span>
    <span class="n">RegNum</span> <span class="o">=</span> <span class="n">matchRegisterByNumber</span><span class="p">(</span><span class="k">static_cast</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getIntVal</span><span class="p">()),</span>
                                   <span class="n">Mnemonic</span><span class="p">.</span><span class="n">lower</span><span class="p">());</span>
    <span class="k">else</span>
      <span class="k">return</span> <span class="n">RegNum</span><span class="p">;</span>  <span class="c1">//error</span>
  <span class="k">return</span> <span class="n">RegNum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
  <span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
                          <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">){</span>

  <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">RegNo</span> <span class="o">=</span> <span class="o">-</span><span class="mi">1</span><span class="p">;</span>

    <span class="n">RegNo</span> <span class="o">=</span> <span class="n">tryParseRegister</span><span class="p">(</span><span class="n">Mnemonic</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">RegNo</span> <span class="o">==</span> <span class="o">-</span><span class="mi">1</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">()));</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat register token.</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;&amp;</span><span class="n">Operands</span><span class="p">,</span>
                                 <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// Check if the current operand has a custom associated parser, if so, try to</span>
  <span class="c1">// custom parse the operand, or fallback to the general approach.</span>
  <span class="n">OperandMatchResultTy</span> <span class="n">ResTy</span> <span class="o">=</span> <span class="n">MatchOperandParserImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Mnemonic</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ResTy</span> <span class="o">==</span> <span class="n">MatchOperand_Success</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="c1">// If there wasn&#39;t a custom match, try the generic matcher below. Otherwise,</span>
  <span class="c1">// there was a match, but an error occurred, in which case, just return that</span>
  <span class="c1">// the operand parsing failed.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">ResTy</span> <span class="o">==</span> <span class="n">MatchOperand_ParseFail</span><span class="p">)</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;unexpected token in operand&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Dollar</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// parse register</span>
    <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat dollar token.</span>
    <span class="c1">// parse register operand</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Mnemonic</span><span class="p">))</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">))</span> <span class="p">{</span>
        <span class="c1">// check if it is indexed addressing operand</span>
        <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="s">&quot;(&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">));</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat parenthesis</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Dollar</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat dollar</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Mnemonic</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">getLexer</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">RParen</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

        <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
        <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="s">&quot;)&quot;</span><span class="p">,</span> <span class="n">S</span><span class="p">));</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
      <span class="p">}</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// maybe it is a symbol reference</span>
    <span class="n">StringRef</span> <span class="n">Identifier</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">parseIdentifier</span><span class="p">(</span><span class="n">Identifier</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">Sym</span> <span class="o">=</span> <span class="n">getContext</span><span class="p">().</span><span class="n">GetOrCreateSymbol</span><span class="p">(</span><span class="s">&quot;$&quot;</span> <span class="o">+</span> <span class="n">Identifier</span><span class="p">);</span>

    <span class="c1">// Otherwise create a symbol ref.</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Res</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Sym</span><span class="p">,</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_None</span><span class="p">,</span>
                                                <span class="n">getContext</span><span class="p">());</span>

    <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">Res</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Identifier</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">LParen</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Minus</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Plus</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Integer</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">String</span><span class="o">:</span> <span class="p">{</span>
     <span class="c1">// quoted label names</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span><span class="p">;</span>
    <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getParser</span><span class="p">().</span><span class="n">parseExpression</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
    <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>
    <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Percent</span><span class="o">:</span> <span class="p">{</span>
    <span class="c1">// it is a symbol reference or constant expression</span>
    <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span><span class="p">;</span>
    <span class="n">SMLoc</span> <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span> <span class="c1">// start location of the operand</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">parseRelocOperand</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

    <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// case AsmToken::Percent</span>
  <span class="p">}</span> <span class="c1">// switch(getLexer().getKind())</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseRelocOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat % token</span>
  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token, operation</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Identifier</span><span class="p">))</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

  <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">Str</span> <span class="o">=</span> <span class="n">Tok</span><span class="p">.</span><span class="n">getIdentifier</span><span class="p">().</span><span class="n">str</span><span class="p">();</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat identifier</span>
  <span class="c1">// now make expression from the rest of the operand</span>
  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span><span class="p">;</span>
  <span class="n">SMLoc</span> <span class="n">EndLoc</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">while</span> <span class="p">(</span><span class="mi">1</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat &#39;(&#39; token</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">Percent</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat % token</span>
        <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">nextTok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">nextTok</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Identifier</span><span class="p">))</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
        <span class="n">Str</span> <span class="o">+=</span> <span class="s">&quot;(%&quot;</span><span class="p">;</span>
        <span class="n">Str</span> <span class="o">+=</span> <span class="n">nextTok</span><span class="p">.</span><span class="n">getIdentifier</span><span class="p">();</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat identifier</span>
        <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">!=</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">)</span>
          <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
      <span class="p">}</span> <span class="k">else</span>
        <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getParser</span><span class="p">().</span><span class="n">parseParenExpression</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span><span class="n">EndLoc</span><span class="p">))</span>
      <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">()</span> <span class="o">==</span> <span class="n">AsmToken</span><span class="o">::</span><span class="n">RParen</span><span class="p">)</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// eat &#39;)&#39; token</span>

  <span class="p">}</span> <span class="k">else</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span> <span class="c1">// parenthesis must follow reloc operand</span>

  <span class="c1">// Check the type of the expression</span>
  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCConstantExpr</span> <span class="o">*</span><span class="n">MCE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCConstantExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// it&#39;s a constant, evaluate lo or hi value</span>
    <span class="kt">int</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">MCE</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Str</span> <span class="o">==</span> <span class="s">&quot;lo&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="n">Val</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Str</span> <span class="o">==</span> <span class="s">&quot;hi&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Val</span> <span class="o">=</span> <span class="p">(</span><span class="n">Val</span> <span class="o">&amp;</span> <span class="mh">0xffff0000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Res</span> <span class="o">=</span> <span class="n">MCConstantExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Val</span><span class="p">,</span> <span class="n">getContext</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="k">const</span> <span class="n">MCSymbolRefExpr</span> <span class="o">*</span><span class="n">MSRE</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// it&#39;s a symbol, create symbolic expression from symbol</span>
    <span class="n">StringRef</span> <span class="n">Symbol</span> <span class="o">=</span> <span class="n">MSRE</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">().</span><span class="n">getName</span><span class="p">();</span>
    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">VK</span> <span class="o">=</span> <span class="n">getVariantKind</span><span class="p">(</span><span class="n">Str</span><span class="p">);</span>
    <span class="n">Res</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="n">Symbol</span><span class="p">,</span><span class="n">VK</span><span class="p">,</span><span class="n">getContext</span><span class="p">());</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">ParseRegister</span><span class="p">(</span><span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">StartLoc</span><span class="p">,</span>
                                  <span class="n">SMLoc</span> <span class="o">&amp;</span><span class="n">EndLoc</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">StartLoc</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
  <span class="n">RegNo</span> <span class="o">=</span> <span class="n">tryParseRegister</span><span class="p">(</span><span class="s">&quot;&quot;</span><span class="p">);</span>
  <span class="n">EndLoc</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
  <span class="k">return</span> <span class="p">(</span><span class="n">RegNo</span> <span class="o">==</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseMemOffset</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*&amp;</span><span class="n">Res</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">SMLoc</span> <span class="n">S</span><span class="p">;</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Integer</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Minus</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Plus</span><span class="o">:</span>
    <span class="k">return</span> <span class="p">(</span><span class="n">getParser</span><span class="p">().</span><span class="n">parseExpression</span><span class="p">(</span><span class="n">Res</span><span class="p">));</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">Percent</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">parseRelocOperand</span><span class="p">(</span><span class="n">Res</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">AsmToken</span>:<span class="o">:</span><span class="n">LParen</span><span class="o">:</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>  <span class="c1">// it&#39;s probably assuming 0</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// eg, 12($sp) or 12(la)</span>
<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseMemOperand</span><span class="p">(</span>
               <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">IdVal</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">SMLoc</span> <span class="n">S</span><span class="p">;</span>
  <span class="c1">// first operand is the offset</span>
  <span class="n">S</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">parseMemOffset</span><span class="p">(</span><span class="n">IdVal</span><span class="p">))</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>

  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">LParen</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Cpu0Operand</span> <span class="o">*</span><span class="n">Mnemonic</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Operands</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Mnemonic</span><span class="o">-&gt;</span><span class="n">getToken</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;la&quot;</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span><span class="o">-</span><span class="mi">1</span><span class="p">);</span>
      <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
      <span class="k">return</span> <span class="n">MatchOperand_Success</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;&#39;(&#39; expected&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat &#39;(&#39; token.</span>

  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok1</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok1</span><span class="p">.</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Dollar</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat &#39;$&#39; token.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">tryParseRegisterOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span><span class="s">&quot;&quot;</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;unexpected token in operand&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
    <span class="p">}</span>

  <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;unexpected token in operand&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok2</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span> <span class="c1">// get next token</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Tok2</span><span class="p">.</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">RParen</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Error</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">(),</span> <span class="s">&quot;&#39;)&#39; expected&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="n">MatchOperand_ParseFail</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SMLoc</span> <span class="n">E</span> <span class="o">=</span> <span class="n">SMLoc</span><span class="o">::</span><span class="n">getFromPointer</span><span class="p">(</span><span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">().</span><span class="n">getLoc</span><span class="p">().</span><span class="n">getPointer</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">);</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Eat &#39;)&#39; token.</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">IdVal</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="n">IdVal</span> <span class="o">=</span> <span class="n">MCConstantExpr</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">getContext</span><span class="p">());</span>

  <span class="c1">// now replace register operand with the mem operand</span>
  <span class="n">Cpu0Operand</span><span class="o">*</span> <span class="n">op</span> <span class="o">=</span> <span class="k">static_cast</span><span class="o">&lt;</span><span class="n">Cpu0Operand</span><span class="o">*&gt;</span><span class="p">(</span><span class="n">Operands</span><span class="p">.</span><span class="n">back</span><span class="p">());</span>
  <span class="kt">int</span> <span class="n">RegNo</span> <span class="o">=</span> <span class="n">op</span><span class="o">-&gt;</span><span class="n">getReg</span><span class="p">();</span>
  <span class="c1">// remove register from operands</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">pop_back</span><span class="p">();</span>
  <span class="c1">// and add memory operand</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateMem</span><span class="p">(</span><span class="n">RegNo</span><span class="p">,</span> <span class="n">IdVal</span><span class="p">,</span> <span class="n">S</span><span class="p">,</span> <span class="n">E</span><span class="p">));</span>
  <span class="k">delete</span> <span class="n">op</span><span class="p">;</span>
  <span class="k">return</span> <span class="n">MatchOperand_Success</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">getVariantKind</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Symbol</span><span class="p">)</span> <span class="p">{</span>

  <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span> <span class="n">VK</span>
                   <span class="o">=</span> <span class="n">StringSwitch</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VariantKind</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Symbol</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;hi&quot;</span><span class="p">,</span>          <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lo&quot;</span><span class="p">,</span>          <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_ABS_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;gp_rel&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPREL</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;call16&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got&quot;</span><span class="p">,</span>         <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tlsgd&quot;</span><span class="p">,</span>       <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TLSGD</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tlsldm&quot;</span><span class="p">,</span>      <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TLSLDM</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;dtprel_hi&quot;</span><span class="p">,</span>   <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_DTPREL_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;dtprel_lo&quot;</span><span class="p">,</span>   <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_DTPREL_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;gottprel&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOTTPREL</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tprel_hi&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TPREL_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;tprel_lo&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_TPREL_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got_disp&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_DISP</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got_page&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_PAGE</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;got_ofst&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_OFST</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;hi(%neg(%gp_rel&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_HI</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Case</span><span class="p">(</span><span class="s">&quot;lo(%neg(%gp_rel&quot;</span><span class="p">,</span>    <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GPOFF_LO</span><span class="p">)</span>
    <span class="p">.</span><span class="n">Default</span><span class="p">(</span><span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_None</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">VK</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">parseMathOperation</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                   <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="p">{</span>
  <span class="c1">// split the format</span>
  <span class="kt">size_t</span> <span class="n">Start</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">),</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">rfind</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
  <span class="n">StringRef</span> <span class="n">Format1</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span> <span class="n">Next</span><span class="p">);</span>
  <span class="c1">// and add the first format to the operands</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">Format1</span><span class="p">,</span> <span class="n">NameLoc</span><span class="p">));</span>
  <span class="c1">// now for the second format</span>
  <span class="n">StringRef</span> <span class="n">Format2</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">Next</span><span class="p">,</span> <span class="n">StringRef</span><span class="o">::</span><span class="n">npos</span><span class="p">);</span>
  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">Format2</span><span class="p">,</span> <span class="n">NameLoc</span><span class="p">));</span>

  <span class="c1">// set the format for the first register</span>
<span class="c1">//  setFpFormat(Format1);</span>

  <span class="c1">// Read the remaining operands.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Read the first operand.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Comma</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>

    <span class="p">}</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>  <span class="c1">// Eat the comma.</span>

    <span class="c1">// Parse and remember the operand.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">ParseInstruction</span><span class="p">(</span><span class="n">ParseInstructionInfo</span> <span class="o">&amp;</span><span class="n">Info</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">Name</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">NameLoc</span><span class="p">,</span>
                 <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">)</span> <span class="p">{</span>

  <span class="c1">// Create the leading tokens for the mnemonic, split by &#39;.&#39; characters.</span>
  <span class="kt">size_t</span> <span class="n">Start</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">Next</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">find</span><span class="p">(</span><span class="sc">&#39;.&#39;</span><span class="p">);</span>
  <span class="n">StringRef</span> <span class="n">Mnemonic</span> <span class="o">=</span> <span class="n">Name</span><span class="p">.</span><span class="n">slice</span><span class="p">(</span><span class="n">Start</span><span class="p">,</span> <span class="n">Next</span><span class="p">);</span>

  <span class="n">Operands</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Cpu0Operand</span><span class="o">::</span><span class="n">CreateToken</span><span class="p">(</span><span class="n">Mnemonic</span><span class="p">,</span> <span class="n">NameLoc</span><span class="p">));</span>

  <span class="c1">// Read the remaining operands.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Read the first operand.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
      <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">is</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">Comma</span><span class="p">)</span> <span class="p">)</span> <span class="p">{</span>
      <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>  <span class="c1">// Eat the comma.</span>

      <span class="c1">// Parse and remember the operand.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">ParseOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Name</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
        <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
        <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
      <span class="p">}</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="s">&quot;unexpected token in argument list&quot;</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">reportParseError</span><span class="p">(</span><span class="n">StringRef</span> <span class="n">ErrorMsg</span><span class="p">)</span> <span class="p">{</span>
   <span class="n">SMLoc</span> <span class="n">Loc</span> <span class="o">=</span> <span class="n">getLexer</span><span class="p">().</span><span class="n">getLoc</span><span class="p">();</span>
   <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
   <span class="k">return</span> <span class="nf">Error</span><span class="p">(</span><span class="n">Loc</span><span class="p">,</span> <span class="n">ErrorMsg</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetReorderDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
  <span class="c1">// if this is not the end of the statement, report error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;unexpected token in statement&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Options</span><span class="p">.</span><span class="n">setReorder</span><span class="p">();</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetNoReorderDirective</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
    <span class="c1">// if this is not the end of the statement, report error</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
      <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;unexpected token in statement&quot;</span><span class="p">);</span>
      <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="n">Options</span><span class="p">.</span><span class="n">setNoreorder</span><span class="p">();</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetMacroDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
  <span class="c1">// if this is not the end of the statement, report error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;unexpected token in statement&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Options</span><span class="p">.</span><span class="n">setMacro</span><span class="p">();</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseSetNoMacroDirective</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
  <span class="c1">// if this is not the end of the statement, report error</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">getLexer</span><span class="p">().</span><span class="n">isNot</span><span class="p">(</span><span class="n">AsmToken</span><span class="o">::</span><span class="n">EndOfStatement</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Options</span><span class="p">.</span><span class="n">isReorder</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">reportParseError</span><span class="p">(</span><span class="s">&quot;`noreorder&#39; must be set before `nomacro&#39;&quot;</span><span class="p">);</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">Options</span><span class="p">.</span><span class="n">setNomacro</span><span class="p">();</span>
  <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span> <span class="c1">// Consume the EndOfStatement</span>
  <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
<span class="p">}</span>
<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">parseDirectiveSet</span><span class="p">()</span> <span class="p">{</span>

  <span class="c1">// get next token</span>
  <span class="k">const</span> <span class="n">AsmToken</span> <span class="o">&amp;</span><span class="n">Tok</span> <span class="o">=</span> <span class="n">Parser</span><span class="p">.</span><span class="n">getTok</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;reorder&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetReorderDirective</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;noreorder&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetNoReorderDirective</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;macro&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetMacroDirective</span><span class="p">();</span>
  <span class="p">}</span> <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">Tok</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;nomacro&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseSetNoMacroDirective</span><span class="p">();</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">ParseDirective</span><span class="p">(</span><span class="n">AsmToken</span> <span class="n">DirectiveID</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.ent&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.end&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">Lex</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.frame&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.set&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">parseDirectiveSet</span><span class="p">();</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.fmask&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.mask&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">DirectiveID</span><span class="p">.</span><span class="n">getString</span><span class="p">()</span> <span class="o">==</span> <span class="s">&quot;.gpword&quot;</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// ignore this directive for now</span>
    <span class="n">Parser</span><span class="p">.</span><span class="n">eatToEndOfStatement</span><span class="p">();</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>

<span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">void</span> <span class="n">LLVMInitializeCpu0AsmParser</span><span class="p">()</span> <span class="p">{</span>
  <span class="n">RegisterMCAsmParser</span><span class="o">&lt;</span><span class="n">Cpu0AsmParser</span><span class="o">&gt;</span> <span class="n">X</span><span class="p">(</span><span class="n">TheCpu0Target</span><span class="p">);</span>
  <span class="n">RegisterMCAsmParser</span><span class="o">&lt;</span><span class="n">Cpu0AsmParser</span><span class="o">&gt;</span> <span class="n">Y</span><span class="p">(</span><span class="n">TheCpu0elTarget</span><span class="p">);</span>
<span class="p">}</span>

<span class="cp">#define GET_REGISTER_MATCHER</span>
<span class="cp">#define GET_MATCHER_IMPLEMENTATION</span>
<span class="cp">#include &quot;Cpu0GenAsmMatcher.inc&quot;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter11_1/AsmParser/CMakeLists.txt</p>
<div class="highlight-c++"><pre>include_directories( ${CMAKE_CURRENT_BINARY_DIR}/.. ${CMAKE_CURRENT_SOURCE_DIR}/.. )
add_llvm_library(LLVMCpu0AsmParser
  Cpu0AsmParser.cpp
  )

add_dependencies(LLVMCpu0AsmParser Cpu0CommonTableGen)
</pre>
</div>
<p class="rubric">lbdex/Chapter11_1/AsmParser/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">;</span><span class="o">===-</span> <span class="p">.</span><span class="o">/</span><span class="n">lib</span><span class="o">/</span><span class="n">Target</span><span class="o">/</span><span class="n">Mips</span><span class="o">/</span><span class="n">AsmParser</span><span class="o">/</span><span class="n">LLVMBuild</span><span class="p">.</span><span class="n">txt</span> <span class="o">----------------*-</span> <span class="n">Conf</span> <span class="o">-*--===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span>                     <span class="n">The</span> <span class="n">LLVM</span> <span class="n">Compiler</span> <span class="n">Infrastructure</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">file</span> <span class="n">is</span> <span class="n">distributed</span> <span class="n">under</span> <span class="n">the</span> <span class="n">University</span> <span class="n">of</span> <span class="n">Illinois</span> <span class="n">Open</span> <span class="n">Source</span>
<span class="p">;</span> <span class="n">License</span><span class="p">.</span> <span class="n">See</span> <span class="n">LICENSE</span><span class="p">.</span><span class="n">TXT</span> <span class="k">for</span> <span class="n">details</span><span class="p">.</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">This</span> <span class="n">is</span> <span class="n">an</span> <span class="n">LLVMBuild</span> <span class="n">description</span> <span class="n">file</span> <span class="k">for</span> <span class="n">the</span> <span class="n">components</span> <span class="n">in</span> <span class="k">this</span> <span class="n">subdirectory</span><span class="p">.</span>
<span class="p">;</span>
<span class="p">;</span> <span class="n">For</span> <span class="n">more</span> <span class="n">information</span> <span class="n">on</span> <span class="n">the</span> <span class="n">LLVMBuild</span> <span class="n">system</span><span class="p">,</span> <span class="n">please</span> <span class="n">see</span><span class="o">:</span>
<span class="p">;</span>
<span class="p">;</span>   <span class="n">http</span><span class="o">:</span><span class="c1">//llvm.org/docs/LLVMBuild.html</span>
<span class="p">;</span>
<span class="p">;</span><span class="o">===------------------------------------------------------------------------===</span><span class="p">;</span>

<span class="p">[</span><span class="n">component_0</span><span class="p">]</span>
<span class="n">type</span> <span class="o">=</span> <span class="n">Library</span>
<span class="n">name</span> <span class="o">=</span> <span class="n">Cpu0AsmParser</span>
<span class="n">parent</span> <span class="o">=</span> <span class="n">Mips</span>
<span class="n">required_libraries</span> <span class="o">=</span> <span class="n">MC</span> <span class="n">MCParser</span> <span class="n">Support</span> <span class="n">MipsDesc</span> <span class="n">MipsInfo</span>
<span class="n">add_to_library_groups</span> <span class="o">=</span> <span class="n">Cpu0</span>
</pre></div>
</div>
<p>The Cpu0AsmParser.cpp contains one thousand lines of code which do the assembly
language parsing. You can understand it with a little patient only.
To let file directory of AsmParser be built, modify CMakeLists.txt and
LLVMBuild.txt as follows,</p>
<p class="rubric">lbdex/Chapter11_1/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">tablegen</span><span class="p">(</span><span class="n">LLVM</span> <span class="n">Cpu0GenAsmMatcher</span><span class="p">.</span><span class="n">inc</span> <span class="o">-</span><span class="n">gen</span><span class="o">-</span><span class="k">asm</span><span class="o">-</span><span class="n">matcher</span><span class="p">)</span>
<span class="p">...</span>
<span class="n">add_subdirectory</span><span class="p">(</span><span class="n">AsmParser</span><span class="p">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter11_1/LLVMBuild.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">subdirectories</span> <span class="o">=</span>
  <span class="n">AsmParser</span>
<span class="p">...</span>
<span class="n">has_asmparser</span> <span class="o">=</span> <span class="mi">1</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter11_1/Cpu0.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">Cpu0AsmParser</span> <span class="o">:</span> <span class="n">AsmParser</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">ShouldEmitMatchRegisterName</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">def</span> <span class="n">Cpu0AsmParserVariant</span> <span class="o">:</span> <span class="n">AsmParserVariant</span> <span class="p">{</span>
  <span class="kt">int</span> <span class="n">Variant</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Recognize hard coded registers.</span>
  <span class="n">string</span> <span class="n">RegisterPrefix</span> <span class="o">=</span> <span class="s">&quot;$&quot;</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// def Cpu0AsmParserVariant</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">Cpu0</span> <span class="o">:</span> <span class="n">Target</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">let</span> <span class="n">AssemblyParsers</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParser</span><span class="p">];</span>
  <span class="p">...</span>
  <span class="n">let</span> <span class="n">AssemblyParserVariants</span> <span class="o">=</span> <span class="p">[</span><span class="n">Cpu0AsmParserVariant</span><span class="p">];</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter11_1/Cpu0InstrFormats.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Pseudo-instructions for alternate assembly syntax (never used by codegen).</span>
<span class="c1">// These are aliases that require C++ handling to convert to the target</span>
<span class="c1">// instruction, while InstAliases can be handled directly by tblgen.</span>
<span class="k">class</span> <span class="nc">Cpu0AsmPseudoInst</span><span class="o">&lt;</span><span class="n">dag</span> <span class="n">outs</span><span class="p">,</span> <span class="n">dag</span> <span class="n">ins</span><span class="p">,</span> <span class="n">string</span> <span class="n">asmstr</span><span class="o">&gt;:</span>
  <span class="n">Cpu0Inst</span><span class="o">&lt;</span><span class="n">outs</span><span class="p">,</span> <span class="n">ins</span><span class="p">,</span> <span class="n">asmstr</span><span class="p">,</span> <span class="p">[],</span> <span class="n">IIPseudo</span><span class="p">,</span> <span class="n">Pseudo</span><span class="o">&gt;</span> <span class="p">{</span>
  <span class="n">let</span> <span class="n">isPseudo</span> <span class="o">=</span> <span class="mi">1</span><span class="p">;</span>
  <span class="n">let</span> <span class="n">Pattern</span> <span class="o">=</span> <span class="p">[];</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - class Cpu0AsmPseudoInst</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter11_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.td
def Cpu0MemAsmOperand : AsmOperandClass {
  let Name = "Mem";
  let ParserMethod = "parseMemOperand";
} // lbd document - mark - def Cpu0MemAsmOperand

// Address operand
def mem : Operand&lt;i32&gt; {
  ...
  let ParserMatchClass = Cpu0MemAsmOperand;
}
...
//===----------------------------------------------------------------------===//
// Pseudo Instruction definition
//===----------------------------------------------------------------------===//

class LoadImm32&lt; string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
           !strconcat(instr_asm, "\t$ra, $imm32")&gt; ;
def LoadImm32Reg : LoadImm32&lt;"li", shamt, CPURegs&gt;;

class LoadAddress&lt;string instr_asm, Operand MemOpnd, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins MemOpnd:$addr),
           !strconcat(instr_asm, "\t$ra, $addr")&gt; ;
def LoadAddr32Reg : LoadAddress&lt;"la", mem, CPURegs&gt;;

class LoadAddressImm&lt;string instr_asm, Operand Od, RegisterClass RC&gt; :
  Cpu0AsmPseudoInst&lt;(outs RC:$ra), (ins Od:$imm32),
           !strconcat(instr_asm, "\t$ra, $imm32")&gt; ;
def LoadAddr32Imm : LoadAddressImm&lt;"la", shamt, CPURegs&gt;;</pre>
</div>
<p>Above declare the <strong>ParserMethod = &#8220;parseMemOperand&#8221;</strong> and implement the
parseMemOperand() in Cpu0AsmParser.cpp to handle the <strong>&#8220;mem&#8221;</strong> operand which
used in Cpu0 instructions ld and st.
For example, ld $2, 4($sp), the <strong>mem</strong> operand is 4($sp).
Accompany with <strong>&#8220;let ParserMatchClass = Cpu0MemAsmOperand;&#8221;</strong>,
LLVM will call parseMemOperand() of Cpu0AsmParser.cpp when it meets the assembly
<strong>mem</strong> operand 4($sp). With above <strong>&#8220;let&#8221;</strong> assignment, TableGen will generate
the following structure and functions in Cpu0GenAsmMatcher.inc.</p>
<p class="rubric">cmake_debug_build/lib/Target/Cpu0/Cpu0GenAsmMatcher.inc</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">enum</span> <span class="n">OperandMatchResultTy</span> <span class="p">{</span>
    <span class="n">MatchOperand_Success</span><span class="p">,</span>    <span class="c1">// operand matched successfully</span>
    <span class="n">MatchOperand_NoMatch</span><span class="p">,</span>    <span class="c1">// operand did not match</span>
    <span class="n">MatchOperand_ParseFail</span>   <span class="c1">// operand matched but had errors</span>
  <span class="p">};</span>
  <span class="n">OperandMatchResultTy</span> <span class="nf">MatchOperandParserImpl</span><span class="p">(</span>
    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
    <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">);</span>
  <span class="n">OperandMatchResultTy</span> <span class="nf">tryCustomParseOperand</span><span class="p">(</span>
    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
    <span class="kt">unsigned</span> <span class="n">MCK</span><span class="p">);</span>

<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">tryCustomParseOperand</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
            <span class="kt">unsigned</span> <span class="n">MCK</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">MCK</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">MCK_Mem</span>:
    <span class="k">return</span> <span class="n">parseMemOperand</span><span class="p">(</span><span class="n">Operands</span><span class="p">);</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="n">MatchOperand_NoMatch</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">MatchOperand_NoMatch</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">OperandMatchResultTy</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">MatchOperandParserImpl</span><span class="p">(</span><span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
             <span class="n">StringRef</span> <span class="n">Mnemonic</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="c1">/// MatchClassKind - The kinds of classes which participate in</span>
<span class="c1">/// instruction matching.</span>
<span class="k">enum</span> <span class="n">MatchClassKind</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">MCK_Mem</span><span class="p">,</span> <span class="c1">// user defined class &#39;Cpu0MemAsmOperand&#39;</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>Above three Pseudo Instruction definitions in Cpu0InstrInfo.td such as
LoadImm32Reg are handled by Cpu0AsmParser.cpp as follows,</p>
<p class="rubric">lbdex/Chapter11_1/AsmParser/Cpu0AsmParser.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">)</span> <span class="p">{</span>

  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
    <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
  <span class="nl">default:</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span><span class="n">expandInstruction</span><span class="p">(</span><span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">Inst</span><span class="p">,</span> <span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span>
            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Instructions</span><span class="p">){</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">Inst</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadImm32Reg</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">expandLoadImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Imm</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">expandLoadAddressImm</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">LoadAddr32Reg</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">expandLoadAddressReg</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span><span class="n">IDLoc</span><span class="p">,</span><span class="n">Instructions</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0AsmParser</span><span class="o">::</span>
<span class="n">MatchAndEmitInstruction</span><span class="p">(</span><span class="n">SMLoc</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">Opcode</span><span class="p">,</span>
            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCParsedAsmOperand</span><span class="o">*&gt;</span> <span class="o">&amp;</span><span class="n">Operands</span><span class="p">,</span>
            <span class="n">MCStreamer</span> <span class="o">&amp;</span><span class="n">Out</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="o">&amp;</span><span class="n">ErrorInfo</span><span class="p">,</span>
            <span class="kt">bool</span> <span class="n">MatchingInlineAsm</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">Inst</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">MatchResult</span> <span class="o">=</span> <span class="n">MatchInstructionImpl</span><span class="p">(</span><span class="n">Operands</span><span class="p">,</span> <span class="n">Inst</span><span class="p">,</span> <span class="n">ErrorInfo</span><span class="p">,</span>
                        <span class="n">MatchingInlineAsm</span><span class="p">);</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">MatchResult</span><span class="p">)</span> <span class="p">{</span>
  <span class="nl">default:</span> <span class="k">break</span><span class="p">;</span>
  <span class="k">case</span> <span class="n">Match_Success</span>: <span class="p">{</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">needsExpansion</span><span class="p">(</span><span class="n">Inst</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">Instructions</span><span class="p">;</span>
    <span class="n">expandInstruction</span><span class="p">(</span><span class="n">Inst</span><span class="p">,</span> <span class="n">IDLoc</span><span class="p">,</span> <span class="n">Instructions</span><span class="p">);</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Finally, remind the CPURegs as below must
follow the order of register number because AsmParser use this when do register
number encode.</p>
<p class="rubric">lbdex/Chapter11_1/Cpu0RegisterInfo.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// The register string, such as &quot;9&quot; or &quot;gp&quot; will show on &quot;llvm-objdump -d&quot;</span>
<span class="n">let</span> <span class="n">Namespace</span> <span class="o">=</span> <span class="s">&quot;Cpu0&quot;</span> <span class="n">in</span> <span class="p">{</span>
  <span class="c1">// General Purpose Registers</span>
  <span class="n">def</span> <span class="n">ZERO</span> <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">0</span><span class="p">,</span>  <span class="s">&quot;zero&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">AT</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">1</span><span class="p">,</span>  <span class="s">&quot;1&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">V0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">2</span><span class="p">,</span>  <span class="s">&quot;2&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">2</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">V1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">3</span><span class="p">,</span>  <span class="s">&quot;3&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">A0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span>  <span class="s">&quot;4&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">4</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">A1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">5</span><span class="p">,</span>  <span class="s">&quot;5&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">5</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">T9</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">6</span><span class="p">,</span>  <span class="s">&quot;t9&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">T0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">7</span><span class="p">,</span>  <span class="s">&quot;t0&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">7</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">S0</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">8</span><span class="p">,</span>  <span class="s">&quot;8&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">8</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">S1</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">9</span><span class="p">,</span>  <span class="s">&quot;9&quot;</span><span class="o">&gt;</span><span class="p">,</span>    <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">9</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">S2</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">10</span><span class="p">,</span> <span class="s">&quot;10&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">10</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">GP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">11</span><span class="p">,</span> <span class="s">&quot;gp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">11</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">FP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">12</span><span class="p">,</span> <span class="s">&quot;fp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">12</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">SP</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">13</span><span class="p">,</span> <span class="s">&quot;sp&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">13</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">LR</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">14</span><span class="p">,</span> <span class="s">&quot;lr&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">14</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">PC</span>   <span class="o">:</span> <span class="n">Cpu0GPRReg</span><span class="o">&lt;</span><span class="mi">15</span><span class="p">,</span> <span class="s">&quot;pc&quot;</span><span class="o">&gt;</span><span class="p">,</span>   <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">15</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="c1">//  def MAR  : Register&lt; 16, &quot;mar&quot;&gt;,  DwarfRegNum&lt;[16]&gt;;</span>
<span class="c1">//  def MDR  : Register&lt; 17, &quot;mdr&quot;&gt;,  DwarfRegNum&lt;[17]&gt;;</span>

  <span class="c1">// Hi/Lo registers number and name</span>
  <span class="n">def</span> <span class="n">HI</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;hi&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">18</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">LO</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;lo&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">19</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
  <span class="n">def</span> <span class="n">SW</span>   <span class="o">:</span> <span class="n">Register</span><span class="o">&lt;</span><span class="s">&quot;sw&quot;</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">DwarfRegNum</span><span class="o">&lt;</span><span class="p">[</span><span class="mi">20</span><span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Register Classes</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">CPURegs</span> <span class="o">:</span> <span class="n">RegisterClass</span><span class="o">&lt;</span><span class="s">&quot;Cpu0&quot;</span><span class="p">,</span> <span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="mi">32</span><span class="p">,</span> <span class="p">(</span><span class="n">add</span>
  <span class="c1">// Reserved</span>
  <span class="n">ZERO</span><span class="p">,</span> <span class="n">AT</span><span class="p">,</span> 
  <span class="c1">// Return Values and Arguments</span>
  <span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">,</span> 
  <span class="c1">// Not preserved across procedure calls</span>
  <span class="n">T9</span><span class="p">,</span> <span class="n">T0</span><span class="p">,</span>
  <span class="c1">// Callee save</span>
  <span class="n">S0</span><span class="p">,</span> <span class="n">S1</span><span class="p">,</span> <span class="n">S2</span><span class="p">,</span> 
  <span class="c1">// Reserved</span>
  <span class="n">GP</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span> 
  <span class="n">SP</span><span class="p">,</span> <span class="n">LR</span><span class="p">,</span> <span class="n">PC</span><span class="p">)</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>Run Chapter11_1/ with ch11_1.cpp to get the correct result as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_
build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>obj ch11_1.bc -o
ch11_1.cpu0.o
JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_
build/bin/Debug/llvm-objdump -d ch11_1.cpu0.o

ch11_1.cpu0.o:  file format ELF32-unknown

Disassembly of section .text:
.text:
       0:     01 2d 00 08                                     ld      <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
       4:     02 0d 00 04                                     st      <span class="nv">$zero</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
       8:     09 30 00 00                                     addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 0
       c:     13 31 20 00                                     add     <span class="nv">$3</span>, <span class="nv">$1</span>, <span class="nv">$2</span>
      10:     14 32 30 00                                     sub     <span class="nv">$3</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
      14:     17 21 30 00                                     mul     <span class="nv">$2</span>, <span class="nv">$1</span>, <span class="nv">$3</span>
      18:     43 32 00 00                                     div     <span class="nv">$3</span>, <span class="nv">$2</span>
      1c:     44 23 00 00                                     divu    <span class="nv">$2</span>, <span class="nv">$3</span>
      20:     18 21 30 00                                     and     <span class="nv">$2</span>, <span class="nv">$1</span>, <span class="nv">$3</span>
      24:     19 31 20 00                                     or      <span class="nv">$3</span>, <span class="nv">$1</span>, <span class="nv">$2</span>
      28:     1a 12 30 00                                     xor     <span class="nv">$1</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
      2c:     41 43 00 00                                     mult    <span class="nv">$4</span>, <span class="nv">$3</span>
      30:     42 32 00 00                                     multu   <span class="nv">$3</span>, <span class="nv">$2</span>
      34:     46 30 00 00                                     mfhi    <span class="nv">$3</span>
      38:     47 20 00 00                                     mflo    <span class="nv">$2</span>
      3c:     48 20 00 00                                     mthi    <span class="nv">$2</span>
      40:     49 20 00 00                                     mtlo    <span class="nv">$2</span>
      44:     1d 22 00 02                                     sra     <span class="nv">$2</span>, <span class="nv">$2</span>, 2
      48:     1b 21 00 03                                     rol     <span class="nv">$2</span>, <span class="nv">$1</span>, 3
      4c:     1c 33 00 04                                     ror     <span class="nv">$3</span>, <span class="nv">$3</span>, 4
      50:     1e 22 00 02                                     shl     <span class="nv">$2</span>, <span class="nv">$2</span>, 2
      54:     1f 23 00 05                                     shr     <span class="nv">$2</span>, <span class="nv">$3</span>, 5
      58:     10 23 00 00                                     cmp     <span class="nv">$sw</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
      5c:     30 00 00 14                                     jeq     <span class="nv">$sw</span>, 20
      60:     31 00 00 10                                     jne     <span class="nv">$sw</span>, 16
      64:     32 ff ff ec                                     jlt     <span class="nv">$sw</span>, -20
      68:     34 ff ff f0                                     jle     <span class="nv">$sw</span>, -16
      6c:     33 ff ff <span class="nb">fc                                     </span>jgt     <span class="nv">$sw</span>, -4
      70:     35 ff ff f4                                     jge     <span class="nv">$sw</span>, -12
      74:     3a 00 04 00                                     swi     1024
      78:     3b 01 00 00                                     jsub    65536
      7c:     3c e0 00 00                                     ret     <span class="nv">$lr</span>
      80:     3e e6 00 00                                     jalr    <span class="nv">$t9</span>
      84:     0f 30 00 70                                     lui     <span class="nv">$3</span>, 112
      88:     0d 33 00 00                                     ori     <span class="nv">$3</span>, <span class="nv">$3</span>, 0
      8c:     0f 30 00 80                                     lui     <span class="nv">$3</span>, 128
      90:     0d 33 00 00                                     ori     <span class="nv">$3</span>, <span class="nv">$3</span>, 0
      94:     13 33 60 00                                     add     <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$t9</span>
      98:     0f 30 00 90                                     lui     <span class="nv">$3</span>, 144
      9c:     0d 33 00 00                                     ori     <span class="nv">$3</span>, <span class="nv">$3</span>, 0
</pre></div>
</div>
<p>The instructions cmp and jeg printed with explicit $sw displayed in assembly
and disassembly. You can change code in AsmParser and Dissassembly (the last
chapter) to hide the $sw printed in these instructions (set $sw to implicit
and not displayed, such as &#8220;jeq 20&#8221; rather than &#8220;jeq $sw, 20&#8221;).</p>
</div>
<div class="section" id="verilog-of-cpu0">
<h2>Verilog of CPU0<a class="headerlink" href="#verilog-of-cpu0" title="Permalink to this headline">¶</a></h2>
<p>Verilog language is an IEEE standard in IC design. There are a lot of book and
documents for this language. Web site <a class="footnote-reference" href="#id5" id="id2">[2]</a> has a pdf <a class="footnote-reference" href="#id6" id="id3">[3]</a> in this.
Example code lbdex/cpu0_verilog/cpu0.v is the
cpu0 design in Verilog. In Appendix A, we have downloaded and installed Icarus
Verilog tool both on iMac and Linux. The cpu0.v and cpu0Is.v is a simple design
with only few hundreds lines of code.
Alough it has not the pipeline features, we can assume the
cpu0 backend code run on the pipeline machine because the pipeline version
use the same machine instructions. Verilog is C like language in syntex and
this book is a compiler book, so we list the cpu0.v as well as the building
command directly as below. We expect
readers can understand the Verilog code just with a little patient and no need
further explanation. According computer architecture, there are two type of I/O.
One is memory mapped I/O, the other is instruction I/O.
CPU0 use memory mapped I/O, we set the memory address 0x7000 as the output port.
When meet the instruction <strong>&#8220;st $ra, cx($rb)&#8221;</strong>, where cx($rb) is
0x7000 (28672), CPU0 display the content as follows,</p>
<div class="highlight-c++"><pre>ST :
  if (R[b]+c16 == 28672)
    $display("%4dns %8x : %8x OUTPUT=%-d", $stime, pc0, ir, R[a]);</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/cpu0.v</p>
<div class="highlight-c++"><pre>`define MEMSIZE   'h80000
`define MEMEMPTY   8'hFF
`define NULL       8'h00
`define IOADDR    'h80000  // IO mapping address

// Operand width
`define INT32 2'b11     // 32 bits
`define INT24 2'b10     // 24 bits
`define INT16 2'b01     // 16 bits
`define BYTE  2'b00     // 8  bits

`define EXE 3'b000
`define RESET 3'b001
`define ABORT 3'b010
`define IRQ 3'b011
`define ERROR 3'b100

// Reference web: http://ccckmit.wikidot.com/ocs:cpu0
module cpu0(input clock, reset, input [2:0] itype, output reg [2:0] tick, 
            output reg [31:0] ir, pc, mar, mdr, inout [31:0] dbus, 
            output reg m_en, m_rw, output reg [1:0] m_size);
  reg signed [31:0] R [0:15];
  // High and Low part of 64 bit result
  reg [7:0] op;
  reg [3:0] a, b, c;
  reg [4:0] c5;
  reg signed [31:0] c12, c16, uc16, c24, Ra, Rb, Rc, pc0; // pc0: instruction pc
  reg [31:0] URa, URb, URc, HI, LO, SW;

  // register name
  `define PC   R[15]   // Program Counter
  `define LR   R[14]   // Link Register
  `define SP   R[13]   // Stack Pointer
  // SW Flage
  `define I2   SW[16] // Hardware Interrupt 1, IO1 interrupt, status, 
                      // 1: in interrupt
  `define I1   SW[15] // Hardware Interrupt 0, timer interrupt, status, 
                      // 1: in interrupt
  `define I0   SW[14] // Software interrupt, status, 1: in interrupt
  `define I    SW[13] // Interrupt, 1: in interrupt
  `define I2E  SW[12]  // Hardware Interrupt 1, IO1 interrupt, Enable
  `define I1E  SW[11]  // Hardware Interrupt 0, timer interrupt, Enable
  `define I0E  SW[10]  // Software Interrupt Enable
  `define IE   SW[9]  // Interrupt Enable
  `define M    SW[8:6]  // Mode bits, itype
  `define D    SW[5]  // Debug Trace
  `define V    SW[3]  // Overflow
  `define C    SW[2]  // Carry
  `define Z    SW[1]  // Zero
  `define N    SW[0]  // Negative flag
  // Instruction Opcode 
  parameter [7:0] NOP=8'h00,LD=8'h01,ST=8'h02,LB=8'h03,LBu=8'h04,SB=8'h05,
  LH=8'h06,LHu=8'h07,SH=8'h08,ADDiu=8'h09,ANDi=8'h0C,ORi=8'h0D,
  XORi=8'h0E,LUi=8'h0F,
  CMP=8'h10,
  ADDu=8'h11,SUBu=8'h12,ADD=8'h13,SUB=8'h14,MUL=8'h17,
  AND=8'h18,OR=8'h19,XOR=8'h1A,
  ROL=8'h1B,ROR=8'h1C,SRA=8'h1D,SHL=8'h1E,SHR=8'h1F,
  SRAV=8'h20,SHLV=8'h21,SHRV=8'h22,
`ifdef CPU0II
  SLTi=8'h26,SLTiu=8'h27, SLT=8'h28,SLTu=8'h29,
  BEQ=8'h37,BNE=8'h38,
`endif
  JEQ=8'h30,JNE=8'h31,JLT=8'h32,JGT=8'h33,JLE=8'h34,JGE=8'h35,
  JMP=8'h36,
  SWI=8'h3A,JSUB=8'h3B,RET=8'h3C,IRET=8'h3D,JALR=8'h3E,
  MULT=8'h41,MULTu=8'h42,DIV=8'h43,DIVu=8'h44,
  MFHI=8'h46,MFLO=8'h47,MTHI=8'h48,MTLO=8'h49,
  MFSW=8'h50,MTSW=8'h51;

  reg [0:0] inInt = 0;
  reg [2:0] state, next_state; 
  reg [2:0] st_taskInt, ns_taskInt; 
  parameter Reset=3'h0, Fetch=3'h1, Decode=3'h2, Execute=3'h3, WriteBack=3'h4;
  integer i;

  // Read Memory Word
  task memReadStart(input [31:0] addr, input [1:0] size); begin 
    mar = addr;     // read(m[addr])
    m_rw = 1;     // Access Mode: read 
    m_en = 1;     // Enable read
    m_size = size;
  end endtask

  task memReadEnd(output [31:0] data); begin // Read Memory Finish, get data
    mdr = dbus; // get momory, dbus = m[addr]
    data = mdr; // return to data
    m_en = 0; // read complete
  end endtask

  // Write memory -- addr: address to write, data: date to write
  task memWriteStart(input [31:0] addr, input [31:0] data, input [1:0] size); 
  begin 
    mar = addr;    // write(m[addr], data)
    mdr = data;
    m_rw = 0;    // access mode: write
    m_en = 1;     // Enable write
    m_size  = size;
  end endtask

  task memWriteEnd; begin // Write Memory Finish
    m_en = 0; // write complete
  end endtask

  task regSet(input [3:0] i, input [31:0] data); begin
    if (i != 0) R[i] = data;
  end endtask

  task regHILOSet(input [31:0] data1, input [31:0] data2); begin
    HI = data1;
    LO = data2;
  end endtask

  // output a word to Output port (equal to display the word to terminal)
  task outw(input [31:0] data); begin
    if (data[7:0] != 8'h00) begin
      $write("%c", data[7:0]);
      if (data[15:8] != 8'h00) 
        $write("%c", data[15:8]);
      if (data[23:16] != 8'h00) 
        $write("%c", data[23:16]);
      if (data[31:24] != 8'h00) 
        $write("%c", data[31:24]);
    end
  end endtask

  // output a character (a byte)
  task outc(input [7:0] data); begin
      $write("%c", data[7:0]);
  end endtask

  task taskInterrupt(input [2:0] iMode); begin
  if (inInt == 0) begin
    case (iMode)
      `RESET: begin 
        `PC = 0; tick = 0; R[0] = 0; SW = 0; `LR = -1;
        `IE = 0; `I0E = 0; `I1E = 0; `I2E = 0; `I = 0; `I0 = 0; `I1 = 0; 
        `I2 = 0;
      end
      `ABORT: begin `LR = `PC; `PC = 4; end
      `IRQ:   begin `LR = `PC; `PC = 8; end
      `ERROR: begin `LR = `PC; `PC = 12; end
    endcase
    $display("taskInterrupt(%3b)", iMode);
    inInt = 1;
  end
  end endtask

  task taskExecute; begin
    m_en = 0;
    tick = tick+1;
    case (state)
    Fetch: begin  // Tick 1 : instruction fetch, throw PC to address bus, 
                  // memory.read(m[PC])
      memReadStart(`PC, `INT32);
      pc0  = `PC;
      `PC = `PC+4;
      next_state = Decode;
    end
    Decode: begin  // Tick 2 : instruction decode, ir = m[PC]
      memReadEnd(ir); // IR = dbus = m[PC]
      {op,a,b,c} = ir[31:12];
      c24 = $signed(ir[23:0]);
      c16 = $signed(ir[15:0]);
      uc16 = ir[15:0];
      c12 = $signed(ir[11:0]);
      c5  = ir[4:0];
      Ra = R[a];
      Rb = R[b];
      Rc = R[c];
      URa = R[a];
      URb = R[b];
      URc = R[c];
      next_state = Execute;
    end
    Execute: begin // Tick 3 : instruction execution
      case (op)
      NOP:   ;
      // load and store instructions
      LD:    memReadStart(Rb+c16, `INT32);      // LD Ra,[Rb+Cx]; Ra&lt;=[Rb+Cx]
      ST:    memWriteStart(Rb+c16, Ra, `INT32); // ST Ra,[Rb+Cx]; Ra=&gt;[Rb+Cx]
      // LB Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LB:    memReadStart(Rb+c16, `BYTE);
      // LBu Ra,[Rb+Cx]; Ra&lt;=(byte)[Rb+Cx]
      LBu:   memReadStart(Rb+c16, `BYTE);
      // SB Ra,[Rb+Cx]; Ra=&gt;(byte)[Rb+Cx]
      SB:    memWriteStart(Rb+c16, Ra, `BYTE);
      LH:    memReadStart(Rb+c16, `INT16); // LH Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      LHu:   memReadStart(Rb+c16, `INT16); // LHu Ra,[Rb+Cx]; Ra&lt;=(2bytes)[Rb+Cx]
      // SH Ra,[Rb+Cx]; Ra=&gt;(2bytes)[Rb+Cx]
      SH:    memWriteStart(Rb+c16, Ra, `INT16);
      // Mathematic 
      ADDiu: R[a] = Rb+c16;                   // ADDiu Ra, Rb+Cx; Ra&lt;=Rb+Cx
      CMP:   begin `N=(Ra-Rb&lt;0);`Z=(Ra-Rb==0); end // CMP Ra, Rb; SW=(Ra &gt;=&lt; Rb)
      ADDu:  regSet(a, Rb+Rc);               // ADDu Ra,Rb,Rc; Ra&lt;=Rb+Rc
      ADD:   begin regSet(a, Rb+Rc); if (a &lt; Rb) `V = 1; else `V =0; end
                                             // ADD Ra,Rb,Rc; Ra&lt;=Rb+Rc
      SUBu:  regSet(a, Rb-Rc);               // SUBu Ra,Rb,Rc; Ra&lt;=Rb-Rc
      SUB:   begin regSet(a, Rb-Rc); if (Rb &lt; 0 &amp;&amp; Rc &gt; 0 &amp;&amp; a &gt;= 0) 
             `V = 1; else `V =0; end         // SUB Ra,Rb,Rc; Ra&lt;=Rb-Rc
      MUL:   regSet(a, Rb*Rc);               // MUL Ra,Rb,Rc;     Ra&lt;=Rb*Rc
      DIVu:  regHILOSet(URa%URb, URa/URb);   // DIVu URa,URb; HI&lt;=URa%URb; 
                                             // LO&lt;=URa/URb
                                             // without exception overflow
      DIV:   begin regHILOSet(Ra%Rb, Ra/Rb); 
             if ((Ra &lt; 0 &amp;&amp; Rb &lt; 0) || (Ra == 0)) `V = 1; 
             else `V =0; end  // DIV Ra,Rb; HI&lt;=Ra%Rb; LO&lt;=Ra/Rb; With overflow
      AND:   regSet(a, Rb&amp;Rc);               // AND Ra,Rb,Rc; Ra&lt;=(Rb and Rc)
      ANDi:  regSet(a, Rb&amp;uc16);             // ANDi Ra,Rb,c16; Ra&lt;=(Rb and c16)
      OR:    regSet(a, Rb|Rc);               // OR Ra,Rb,Rc; Ra&lt;=(Rb or Rc)
      ORi:   regSet(a, Rb|uc16);             // ORi Ra,Rb,c16; Ra&lt;=(Rb or c16)
      XOR:   regSet(a, Rb^Rc);               // XOR Ra,Rb,Rc; Ra&lt;=(Rb xor Rc)
      XORi:  regSet(a, Rb^uc16);             // XORi Ra,Rb,c16; Ra&lt;=(Rb xor c16)
      LUi:   regSet(a, uc16&lt;&lt;16);
      SHL:   regSet(a, Rb&lt;&lt;c5);     // Shift Left; SHL Ra,Rb,Cx; Ra&lt;=(Rb &lt;&lt; Cx)
      SRA:   regSet(a, (Rb&amp;'h80000000)|(Rb&gt;&gt;c5)); 
                                // Shift Right with signed bit fill;
                                // SHR Ra,Rb,Cx; Ra&lt;=(Rb&amp;0x80000000)|(Rb&gt;&gt;Cx)
      SHR:   regSet(a, Rb&gt;&gt;c5);     // Shift Right with 0 fill; 
                                    // SHR Ra,Rb,Cx; Ra&lt;=(Rb &gt;&gt; Cx)
      SHLV:  regSet(a, Rb&lt;&lt;Rc);     // Shift Left; SHLV Ra,Rb,Rc; Ra&lt;=(Rb &lt;&lt; Rc)
      SRAV:  regSet(a, (Rb&amp;'h80000000)|(Rb&gt;&gt;Rc)); 
                                // Shift Right with signed bit fill;
                                // SHRV Ra,Rb,Rc; Ra&lt;=(Rb&amp;0x80000000)|(Rb&gt;&gt;Rc)
      SHRV:  regSet(a, Rb&gt;&gt;Rc);     // Shift Right with 0 fill; 
                                    // SHRV Ra,Rb,Rc; Ra&lt;=(Rb &gt;&gt; Rc)
      ROL:   regSet(a, (Rb&lt;&lt;c5)|(Rb&gt;&gt;(32-c5)));     // Rotate Left;
      ROR:   regSet(a, (Rb&gt;&gt;c5)|(Rb&lt;&lt;(32-c5)));     // Rotate Right;
      MFLO:  regSet(a, LO);         // MFLO Ra; Ra&lt;=LO
      MFHI:  regSet(a, HI);         // MFHI Ra; Ra&lt;=HI
      MTLO:  LO = Ra;               // MTLO Ra; LO&lt;=Ra
      MTHI:  HI = Ra;               // MTHI Ra; HI&lt;=Ra
      MFSW:  regSet(a, SW);         // MFSW Ra; Ra&lt;=SW
      MTSW:  SW = Ra;               // MTSW Ra; SW&lt;=Ra
      MULT:  {HI, LO}=Ra*Rb;        // MULT Ra,Rb; HI&lt;=((Ra*Rb)&gt;&gt;32); 
                                    // LO&lt;=((Ra*Rb) and 0x00000000ffffffff);
                                    // with exception overflow
      MULTu: {HI, LO}=URa*URb;      // MULT URa,URb; HI&lt;=((URa*URb)&gt;&gt;32); 
                                    // LO&lt;=((URa*URb) and 0x00000000ffffffff);
                                    // without exception overflow
`ifdef CPU0II
      // set
      SLT:   if (Rb &lt; Rc) R[a]=1; else R[a]=0;
      SLTu:  if (Rb &lt; Rc) R[a]=1; else R[a]=0;
      SLTi:  if (Rb &lt; c16) R[a]=1; else R[a]=0;
      SLTiu: if (Rb &lt; c16) R[a]=1; else R[a]=0;
      // Branch Instructions
      BEQ:   if (Ra==Rb) `PC=`PC+c16; 
      BNE:   if (Ra!=Rb) `PC=`PC+c16;
`endif
      // Jump Instructions
      JEQ:   if (`Z) `PC=`PC+c24;            // JEQ Cx; if SW(=) PC  PC+Cx
      JNE:   if (!`Z) `PC=`PC+c24;           // JNE Cx; if SW(!=) PC PC+Cx
      JLT:   if (`N)`PC=`PC+c24;             // JLT Cx; if SW(&lt;) PC  PC+Cx
      JGT:   if (!`N&amp;&amp;!`Z) `PC=`PC+c24;      // JGT Cx; if SW(&gt;) PC  PC+Cx
      JLE:   if (`N || `Z) `PC=`PC+c24;      // JLE Cx; if SW(&lt;=) PC PC+Cx    
      JGE:   if (!`N || `Z) `PC=`PC+c24;     // JGE Cx; if SW(&gt;=) PC PC+Cx
      JMP:   `PC = `PC+c24;                  // JMP Cx; PC &lt;= PC+Cx
      SWI:   begin 
        `LR=`PC;`PC= c24; `I0 = 1'b1; `I = 1'b1;
      end // Software Interrupt; SWI Cx; LR &lt;= PC; PC &lt;= Cx; INT&lt;=1
      JSUB:  begin `LR=`PC;`PC=`PC + c24; end // JSUB Cx; LR&lt;=PC; PC&lt;=PC+Cx
      JALR:  begin R[a] =`PC;`PC=Rb; end // JALR Ra,Rb; Ra&lt;=PC; PC&lt;=Rb
      RET:   begin `PC=Ra; end               // RET; PC &lt;= Ra
      IRET:  begin 
        `PC=Ra;`I = 1'b0; `M = `EXE;
      end // Interrupt Return; IRET; PC &lt;= LR; INT&lt;=0
      default : 
        $display("%4dns %8x : OP code %8x not support", $stime, pc0, op);
      endcase
      next_state = WriteBack;
    end
    WriteBack: begin // Read/Write finish, close memory
      case (op)
        LD, LB, LBu, LH, LHu  : memReadEnd(R[a]); 
                                          //read memory complete
        ST, SB, SH  : memWriteEnd(); 
                                          // write memory complete
      endcase
      case (op)
        LB  : if (R[a] &gt; 8'h7f) R[a]=R[a]|32'hffffff80;
        LH  : if (R[a] &gt; 16'h7fff) R[a]=R[a]|32'hffff8000;
      endcase
      case (op)
      MULT, MULTu, DIV, DIVu, MTHI, MTLO, MTSW :
        if (`D)
          $display("%4dns %8x : %8x HI=%8x LO=%8x SW=%8x", $stime, pc0, ir, HI, 
        LO, SW);
      ST : begin
        if (`D)
          $display("%4dns %8x : %8x m[%-04d+%-04d]=%8x  SW=%8x", $stime, pc0, ir, 
          R[b], c16, R[a], SW);
        if (R[b]+c16 == `IOADDR) begin
          outw(R[a]);
        end
      end
      SB : begin
        if (`D)
          $display("%4dns %8x : %8x m[%-04d+%-04d]=%c  SW=%8x", $stime, pc0, ir, 
        R[b], c16, R[a][7:0], SW);
        if (R[b]+c16 == `IOADDR) begin
          outc(R[a][7:0]);
        end
      end
      default :
        if (`D) // Display the written register content
          $display("%4dns %8x : %8x R[%02d]=%-8x=%-d SW=%8x", $stime, pc0, ir, 
          a, R[a], R[a], SW);
      endcase
      if (`PC &lt; 0) begin
        $display("RET to PC &lt; 0, finished!");
        $finish;
      end
      next_state = Fetch;
    end
    endcase
  end endtask

  always @(posedge clock) begin
    if (inInt == 0 &amp;&amp; itype == `RESET) begin
      taskInterrupt(`RESET);
      `M = `RESET;
      state = Fetch;
    end else if (inInt == 0 &amp;&amp; (state == Fetch) &amp;&amp; (`IE &amp;&amp; `I) &amp;&amp; 
                 ((`I0E &amp;&amp; `I0) || (`I1E &amp;&amp; `I1) || (`I2E &amp;&amp; `I2)) ) begin
      `M = `IRQ;
      taskInterrupt(`IRQ);
      state = Fetch;
    end else begin
      // `D = 1; // Trace register content at beginning
      taskExecute();
      state = next_state;
    end
    pc = `PC;
  end
endmodule

module memory0(input clock, reset, en, rw, input [1:0] m_size, 
                input [31:0] abus, dbus_in, output [31:0] dbus_out);
  reg [7:0] m [0:`MEMSIZE-1];
`ifdef DLINKER
  reg [7:0] flash [0:`MEMSIZE-1];
  reg [7:0] dsym [0:192-1];
  reg [7:0] dstr [0:96-1];
  reg [7:0] so_func_offset[0:384-1];
  reg [7:0] globalAddr [0:3];
  reg [31:0] gp;
  reg [31:0] gpPlt;
  reg [31:0] fabus;
  integer j;
  integer k;
  integer l;
  reg [31:0] j32;
  integer numDynEntry;
`endif
  reg [31:0] data;

  integer i;

`ifdef DLINKER
`include "dynlinker.v"
`endif
  initial begin
  // erase memory
    for (i=0; i &lt; `MEMSIZE; i=i+1) begin
       m[i] = `MEMEMPTY;
    end
  // load program from file to memory
    $readmemh("cpu0.hex", m);
  // display memory contents
    `ifdef TRACE
      for (i=0; i &lt; `MEMSIZE &amp;&amp; (m[i] != `MEMEMPTY || m[i+1] != `MEMEMPTY || 
         m[i+2] != `MEMEMPTY || m[i+3] != `MEMEMPTY); i=i+4) begin
        $display("%8x: %8x", i, {m[i], m[i+1], m[i+2], m[i+3]});
      end
    `endif
`ifdef DLINKER
  loadToFlash();
  createDynInfo();
`endif
  end

  always @(clock or abus or en or rw or dbus_in) 
  begin
    if (abus &gt;= 0 &amp;&amp; abus &lt;= `MEMSIZE-4) begin
      if (en == 1 &amp;&amp; rw == 0) begin // r_w==0:write
        data = dbus_in;
        case (m_size)
        `BYTE:  {m[abus]} = dbus_in[7:0];
        `INT16: {m[abus], m[abus+1] } = dbus_in[15:0];
        `INT24: {m[abus], m[abus+1], m[abus+2]} = dbus_in[24:0];
        `INT32: {m[abus], m[abus+1], m[abus+2], m[abus+3]} = dbus_in;
        endcase
      end else if (en == 1 &amp;&amp; rw == 1) begin// r_w==1:read
        case (m_size)
        `BYTE:  data = {8'h00  , 8'h00,   8'h00,   m[abus]      };
        `INT16: data = {8'h00  , 8'h00,   m[abus], m[abus+1]    };
        `INT24: data = {8'h00  , m[abus], m[abus+1], m[abus+2]  };
        `INT32: data = {m[abus], m[abus+1], m[abus+2], m[abus+3]};
        endcase
      end else
        data = 32'hZZZZZZZZ;
      `ifdef DLINKER
      `include "flashio.v"
      `endif
    end else 
      data = 32'hZZZZZZZZ;
  end
  assign dbus_out = data;
endmodule

module main;
  reg clock;
  reg [2:0] itype;
  wire [2:0] tick;
  wire [31:0] pc, ir, mar, mdr, dbus;
  wire m_en, m_rw;
  wire [1:0] m_size;

  cpu0 cpu(.clock(clock), .itype(itype), .pc(pc), .tick(tick), .ir(ir),
  .mar(mar), .mdr(mdr), .dbus(dbus), .m_en(m_en), .m_rw(m_rw), .m_size(m_size));

  memory0 mem(.clock(clock), .reset(reset), .en(m_en), .rw(m_rw), 
  .m_size(m_size), .abus(mar), .dbus_in(mdr), .dbus_out(dbus));

  initial
  begin
    clock = 0;
    itype = `RESET;
    #300000000 $finish;
  end

  always #10 clock=clock+1;

endmodule
</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/cpu0Is.v</p>
<div class="highlight-c++"><pre>// TRACE: Display the memory contents of the loaded program and data
//`define TRACE 

`include "cpu0.v"

</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:raw Jonathan<span class="nv">$ </span><span class="nb">pwd</span>
/Users/Jonathan/test/2/lbd/lbdex/cpu0_verilog/raw
JonathantekiiMac:raw Jonathan<span class="nv">$ </span>iverilog -o cpu0Is cpu0Is.v
</pre></div>
</div>
</div>
<div class="section" id="run-program-on-cpu0-machine">
<h2>Run program on CPU0 machine<a class="headerlink" href="#run-program-on-cpu0-machine" title="Permalink to this headline">¶</a></h2>
<p>Now let&#8217;s compile ch_run_backend.cpp as below. Since code size grows up from low to high
address and stack grows up from high to low address. We set $sp at 0x6ffc because
cpu0.v use 0x7000 bytes of memory.</p>
<p class="rubric">lbdex/InputFiles/InitRegs.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $1,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $2,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $3,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $4,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $5,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $6,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $7,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $8,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $9,	$ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $10, $ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $gp, $ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $fp, $ZERO, 0&quot;</span><span class="p">);</span>
<span class="k">asm</span><span class="p">(</span><span class="s">&quot;addiu $lr, $ZERO, -1&quot;</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/print.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#ifndef _PRINT_H_</span>
<span class="cp">#define _PRINT_H_</span>

<span class="cp">#define OUT_MEM 0x80000</span>

<span class="kt">void</span> <span class="nf">print_char</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">c</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">dump_mem</span><span class="p">(</span><span class="kt">unsigned</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">,</span> <span class="kt">int</span> <span class="n">n</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">);</span>
<span class="kt">void</span> <span class="nf">print_integer</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">);</span>
<span class="cp">#endif</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/print.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;print.h&quot;</span>
<span class="cp">#include &quot;itoa.cpp&quot;</span>

<span class="c1">// For memory IO</span>
<span class="kt">void</span> <span class="nf">print_char</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="n">c</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span><span class="o">*</span><span class="p">)</span><span class="n">OUT_MEM</span><span class="p">;</span>
  <span class="o">*</span><span class="n">p</span> <span class="o">=</span> <span class="n">c</span><span class="p">;</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="nf">print_string</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">str</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">p</span><span class="p">;</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">p</span> <span class="o">=</span> <span class="n">str</span><span class="p">;</span> <span class="o">*</span><span class="n">p</span> <span class="o">!=</span> <span class="sc">&#39;\0&#39;</span><span class="p">;</span> <span class="n">p</span><span class="o">++</span><span class="p">)</span>
    <span class="n">print_char</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print_char</span><span class="p">(</span><span class="o">*</span><span class="n">p</span><span class="p">);</span>
  <span class="n">print_char</span><span class="p">(</span><span class="sc">&#39;\n&#39;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">// For memory IO</span>
<span class="kt">void</span> <span class="nf">print_integer</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="n">INT_DIGITS</span> <span class="o">+</span> <span class="mi">2</span><span class="p">];</span>
  <span class="n">itoa</span><span class="p">(</span><span class="n">str</span><span class="p">,</span> <span class="n">x</span><span class="p">);</span>
  <span class="n">print_string</span><span class="p">(</span><span class="n">str</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch_run_backend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;debug.h&quot;</span>
<span class="cp">#include &quot;boot.cpp&quot;</span>

<span class="cp">#include &quot;print.h&quot;</span>

<span class="kt">int</span> <span class="nf">test_math</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_div</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_local_pointer</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_andorxornot</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_setxx</span><span class="p">();</span>
<span class="kt">bool</span> <span class="nf">test_load_bool</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_signed_char</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_unsigned_char</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_signed_short</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_unsigned_short</span><span class="p">();</span>
<span class="kt">long</span> <span class="kt">long</span> <span class="nf">test_longlong</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_control1</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_madd</span><span class="p">();</span>
<span class="kt">int</span> <span class="nf">test_vararg</span><span class="p">();</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_math</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 74</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_div</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 253</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_local_pointer</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 3</span>
  <span class="n">a</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="p">)</span><span class="n">test_load_bool</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>  <span class="c1">// a = 1</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_andorxornot</span><span class="p">();</span> <span class="c1">// a = 14</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_setxx</span><span class="p">();</span> <span class="c1">// a = 3</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_signed_char</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a = -126</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_unsigned_char</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a = 130</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_signed_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a = -32766</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_unsigned_short</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a = 32770</span>
  <span class="kt">long</span> <span class="kt">long</span> <span class="n">b</span> <span class="o">=</span> <span class="n">test_longlong</span><span class="p">();</span> <span class="c1">// 0x800000002</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="kt">int</span><span class="p">)(</span><span class="n">b</span> <span class="o">&gt;&gt;</span> <span class="mi">32</span><span class="p">));</span> <span class="c1">// 393307</span>
  <span class="n">print_integer</span><span class="p">((</span><span class="kt">int</span><span class="p">)</span><span class="n">b</span><span class="p">);</span> <span class="c1">// 16777222</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_control1</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span>	<span class="c1">// a = 51</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="mi">2147483647</span><span class="p">);</span> <span class="c1">// test mod % (mult) from itoa.cpp</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="o">-</span><span class="mi">2147483648</span><span class="p">);</span> <span class="c1">// test mod % (multu) from itoa.cpp</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_madd</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a = 7</span>
  <span class="n">a</span> <span class="o">=</span> <span class="n">test_vararg</span><span class="p">();</span>
  <span class="n">print_integer</span><span class="p">(</span><span class="n">a</span><span class="p">);</span> <span class="c1">// a = 15</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#include &quot;print.cpp&quot;</span>

<span class="kt">void</span> <span class="nf">print1_integer</span><span class="p">(</span><span class="kt">int</span> <span class="n">x</span><span class="p">)</span>
<span class="p">{</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;ld $at, 8($sp)&quot;</span><span class="p">);</span>
  <span class="k">asm</span><span class="p">(</span><span class="s">&quot;st $at, 28672($0)&quot;</span><span class="p">);</span>

  <span class="k">return</span><span class="p">;</span>
<span class="p">}</span>

<span class="cp">#if 0</span><span class="c"></span>
<span class="c">// For instruction IO</span>
<span class="c">void print2_integer(int x)</span>
<span class="c">{</span>
<span class="c">  asm(&quot;ld $at, 8($sp)&quot;);</span>
<span class="c">  asm(&quot;outw $tat&quot;);</span>
<span class="c">  return;</span>
<span class="c">}</span>
<span class="cp">#endif</span>

<span class="cp">#include &quot;ch4_1.cpp&quot;</span>
<span class="cp">#include &quot;ch4_3.cpp&quot;</span>
<span class="cp">#include &quot;ch4_5.cpp&quot;</span>
<span class="cp">#include &quot;ch7_1.cpp&quot;</span>
<span class="cp">#include &quot;ch7_2_2.cpp&quot;</span>
<span class="cp">#include &quot;ch7_3.cpp&quot;</span>
<span class="cp">#include &quot;ch7_4.cpp&quot;</span>
<span class="cp">#include &quot;ch8_1_1.cpp&quot;</span>
<span class="cp">#include &quot;ch9_1_4.cpp&quot;</span>
<span class="cp">#include &quot;ch9_3.cpp&quot;</span>

<span class="cm">/* result:</span>
<span class="cm">74</span>
<span class="cm">253</span>
<span class="cm">3</span>
<span class="cm">1</span>
<span class="cm">14</span>
<span class="cm">3</span>
<span class="cm">-126</span>
<span class="cm">130</span>
<span class="cm">-32766</span>
<span class="cm">32770</span>
<span class="cm">393307</span>
<span class="cm">16777222</span>
<span class="cm">51</span>
<span class="cm">2147483647</span>
<span class="cm">-2147483648</span>
<span class="cm">7</span>
<span class="cm">15</span>
<span class="cm">RET to PC &lt; 0, finished!</span>
<span class="cm">*/</span>
</pre></div>
</div>
<p>Let&#8217;s run Chapter11_2/ with <tt class="docutils literal"><span class="pre">llvm-objdump</span> <span class="pre">-d</span></tt> for input files
ch_run_backend.cpp to generate the hex file of inputing to cpu0Is Verilog
simulator to get the output result as below.
Remind ch_run_backend.cpp have to be compiled with option
<tt class="docutils literal"><span class="pre">clang</span> <span class="pre">-target</span> <span class="pre">mips-unknown-linux-gnu</span></tt> and use the clang of
your build instead of download from Xcode on iMac. The ~/llvm/release/
cmake_debug_build/bin/Debug/ is my build clang from source code.</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>~/llvm/release/cmake_debug_build/bin/
Debug/clang -target mips-unknown-linux-gnu -c ch_run_backend.cpp -emit-llvm
-o ch_run_backend.bc
JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_
build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>obj
ch_run_backend.bc -o ch_run_backend.cpu0.o
JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_
build/bin/Debug/llvm-objdump -d ch_run_backend.cpu0.o | tail -n +6| awk <span class="s1">&#39;{print &quot;/* &quot;</span>
<span class="s1">$1 &quot; */\t&quot; $2 &quot; &quot; $3 &quot; &quot; $4 &quot; &quot; $5 &quot;\t/* &quot; $6&quot;\t&quot; $7&quot; &quot; $8&quot; &quot; $9&quot; &quot; $10 &quot;\t*/&quot;}&#39;</span>
 &gt; ../cpu0_verilog/raw/cpu0.hex

JonathantekiiMac:raw Jonathan<span class="nv">$ </span>./cpu0Is
WARNING: cpu0Is.v:386: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for </span>the
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
74
253
3
1
14
3
-126
130
-32766
32770
393307
16777222
51
2147483647
-21474836487
7
15
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>From the result as below, you can find the print_integer() which implemented by C
language has more instructions while the print1_integer() which implemented by
assembly has less instructions. But the C version is better in portability since
the assembly version is binding with machine assembly language and make the
assumption that the stack size of print1_integer() is 8.</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:raw Jonathan<span class="nv">$ </span><span class="nb">cd</span> ../../InputFiles/
JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build
/bin/Debug/llvm-objdump -d ch_run_backend.cpu0.o
...
_Z13print_integeri:
     ................                                   addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
     ................                                   st  <span class="nv">$lr</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   st  <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   add <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
     ................                                   ld  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
     ................                                   st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
     ................                                   st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   jsub  716
     ................                                   st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
     ................                                   st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   jsub  1084
     ................                                   add <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
     ................                                   ld  <span class="nv">$fp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   ld  <span class="nv">$lr</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
     ................                                   ret <span class="nv">$lr</span>
...
_Z14print1_integeri:
     ................                                   addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
     ................                                   st  <span class="nv">$fp</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   add <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
     ................                                   ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
     ................                                   st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
     ................                                   ld  <span class="nv">$1</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   st  <span class="nv">$1</span>, 28672<span class="o">(</span><span class="nv">$zero</span><span class="o">)</span>
     ................                                   add <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
     ................                                   ld  <span class="nv">$fp</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
     ................                                   addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
     ................                                   ret <span class="nv">$lr</span>
</pre></div>
</div>
<p>You can trace the memory binary code and destination
register changed at every instruction execution by the following change and
get the result as below,</p>
<p class="rubric">lbdex/cpu0_verilog/cpu0Is.v</p>
<div class="highlight-c++"><pre>`define TRACE</pre>
</div>
<p class="rubric">lbdex/cpu0_verilog/cpu0.v</p>
<div class="highlight-c++"><pre>...
`D = 1; // Trace register content at beginning</pre>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:raw Jonathan<span class="nv">$ </span>./cpu0Is
WARNING: cpu0.v:386: <span class="nv">$readmemh</span><span class="o">(</span>cpu0.hex<span class="o">)</span>: Not enough words in the file <span class="k">for </span>the
requested range <span class="o">[</span>0:28671<span class="o">]</span>.
00000000: 2600000c
00000004: 26000004
00000008: 26000004
0000000c: 26fffffc
00000010: 09100000
00000014: 09200000
...
taskInterrupt<span class="o">(</span>001<span class="o">)</span>
1530ns 00000054 : 02ed002c m<span class="o">[</span>28620+44  <span class="o">]=</span>-1          <span class="nv">SW</span><span class="o">=</span>00000000
1610ns 00000058 : 02bd0028 m<span class="o">[</span>28620+40  <span class="o">]=</span>0           <span class="nv">SW</span><span class="o">=</span>00000000
...
RET to PC &lt; 0, finished!
</pre></div>
</div>
<p>As above result, cpu0.v dump the memory first after read input cpu0.hex.
Next, it run instructions from address 0 and print each destination
register value in the fourth column.
The first column is the nano seconds of timing. The second
is instruction address. The third is instruction content.
We have checked many example code is correct by print the variable with
print_integer().</p>
<p>This chapter shows Verilog PC output by display the I/O memory mapped address but
didn&#8217;t implementing the output hardware interface or port.
The real output hardware
interface/port is hardware output device dependent, such as RS232, speaker,
LED, .... You should implement the I/O interface/port when you want to program
FPGA and wire I/O device to the I/O port.</p>
<table class="docutils footnote" frame="void" id="id4" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html">http://www.embecosm.com/appnotes/ean10/ean10-howto-llvmas-1.0.html</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id5" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="http://www.ece.umd.edu/courses/enee359a/">http://www.ece.umd.edu/courses/enee359a/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id6" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf">http://www.ece.umd.edu/courses/enee359a/verilog_tutorial.pdf</a></td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="elf.html">ELF Support</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="optimize.html">Backend Optimization</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>