

<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Function call &mdash; Write An LLVM Backend Tutorial For Cpu0</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    '',
        VERSION:     '3.1.2',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Write An LLVM Backend Tutorial For Cpu0" href="index.html" />
    <link rel="next" title="Todo List" href="todo.html" />
    <link rel="prev" title="Control flow statement" href="ctrlflow.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Write An LLVM Backend Tutorial For Cpu0</span></a></h1>
        <h2 class="heading"><span>Function call</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statement</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="todo.html">Todo List</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="function-call">
<h1>Function call<a class="headerlink" href="#function-call" title="Permalink to this headline">¶</a></h1>
<p>The subroutine/function call of backend code translation is supported in this
chapter.
A lots of code needed in function call. We break it down according llvm
supplied interface for easy to explanation.
This chapter introduce the Mips stack frame structure first since we borrow
many part of ABI from it.
Although each CPU has it&#8217;s own ABI, most of RISC CPUs ABI are similar.
In addition to support fixed number of arguments function call, cpu0 also
upport variable number of arguments since C/C++ support this feature.
Supply Mips ABI and assemble language manual on internet link in this chapter
for your reference.
The section “4.5 DAG Lowering” of tricore_llvm.pdf contains some knowledge
about Lowering process. Section “4.5.1 Calling Conventions” of tricore_llvm.pdf
is the related materials you can reference.</p>
<p>This chapter is more complicate than any of the previous chapter.
It include stack frame and the related ABI support.
If you have problem in reading the stack frame illustrated in the first three
sections of this chapter, you can read the appendix B of “Procedure Call
Convention” of book “Computer Organization and Design” which listed in
section “RISC CPU knowledge” of chapter “Control flow statement”,
“Run Time Memory” of compiler book, or “Function Call Sequence”  and
“Stack Frame” of Mips ABI.</p>
<div class="section" id="mips-stack-frame">
<h2>Mips stack frame<a class="headerlink" href="#mips-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>The first thing for design the cpu0 function call is to decide how to pass
arguments in function call. There are two options.
The first is pass arguments all in stack.
Second is pass arguments in the registers which are reserved for function
arguments, and put the other arguments in stack if it over the number of
registers reserved for function call. For example, Mips pass the first 4
arguments in register $a0, $a1, $a2, $a3, and the other arguments if it over 4
arguments in stack. <a class="reference internal" href="#funccall-f1"><em>Mips stack frame</em></a> is the Mips stack frame.</p>
<div class="figure align-center" id="funccall-f1">
<a class="reference internal image-reference" href="_images/11.png"><img alt="_images/11.png" src="_images/11.png" style="width: 688.0px; height: 531.0px;" /></a>
<p class="caption">Mips stack frame</p>
</div>
<p>Run llc with -march=mips for ch7_1.bc, you will get the following result.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch7_1.cpp</span>
<span class="kt">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>

    <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-31:InputFiles Jonathan<span class="nv">$ </span>clang -c ch7_1.cpp -emit-llvm -o ch7_1.bc
118-165-79-31:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>mips -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch7_1.bc -o ch7_1.mips.s
118-165-79-31:InputFiles Jonathan<span class="nv">$ </span>cat ch7_1.mips.s
    .section .mdebug.abi32
    .previous
    .file   <span class="s2">&quot;ch7_1.bc&quot;</span>
    .text
    .globl  _Z5sum_iiiiiii
    .align  2
    .type   _Z5sum_iiiiiii,@function
    .ent    _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
    .frame  <span class="nv">$sp</span>,32,<span class="nv">$ra</span>
    .mask   0x00000000,0
    .fmask  0x00000000,0
    .set    noreorder
    .set    nomacro
<span class="c"># BB#0:                                 # %entry</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
    st  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$5</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$6</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$7</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // load argument 5
    st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // load argument 6
    st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addu    <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
    ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    addu    <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
    st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
    jr  <span class="nv">$ra</span>
    nop
    .set    macro
    .set    reorder
    .end    _Z5sum_iiiiiii
<span class="nv">$tmp1</span>:
    .size   _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z5sum_iiiiiii

    .globl  main
    .align  2
    .type   main,@function
    .ent    main                    <span class="c"># @main</span>
main:
    .frame  <span class="nv">$sp</span>,48,<span class="nv">$ra</span>
    .mask   0x80000000,-4
    .fmask  0x00000000,0
    .set    noreorder
    .cpload <span class="nv">$25</span>
    .set    nomacro
<span class="c"># BB#0:                                 # %entry</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -48
    st  <span class="nv">$ra</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
    .cprestore  24
    st  <span class="nv">$zero</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
    st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // Save argument 6 to 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
    st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // Save argument 5 to 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$25</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
    addiu   <span class="nv">$4</span>, <span class="nv">$zero</span>, 1    // Pass argument 1 to <span class="nv">$4</span> <span class="o">(=</span><span class="nv">$a0</span><span class="o">)</span>
    addiu   <span class="nv">$5</span>, <span class="nv">$zero</span>, 2    // Pass argument 2 to <span class="nv">$5</span> <span class="o">(=</span><span class="nv">$a1</span><span class="o">)</span>
    addiu   <span class="nv">$6</span>, <span class="nv">$zero</span>, 3
    addiu   <span class="nv">$7</span>, <span class="nv">$zero</span>, 4
    jalr    <span class="nv">$25</span>
    nop
    ld  <span class="nv">$gp</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$ra</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 48
    jr  <span class="nv">$ra</span>
    nop
    .set    macro
    .set    reorder
    .end    main
<span class="nv">$tmp4</span>:
    .size   main, <span class="o">(</span><span class="nv">$tmp4</span><span class="o">)</span>-main
</pre></div>
</div>
<p>From the mips assembly code generated as above, we know it save the first 4
arguments to $a0..$a3 and last 2 arguments to 16($sp) and 20($sp).
<a class="reference internal" href="#funccall-f2"><em>Mips arguments location in stack frame</em></a> is the arguments location for example code ch7_1.cpp.
It load argument 5 from 48($sp) in sum_i() since the argument 5 is saved to
16($sp) in main().
The stack size of sum_i() is 32, so 16+32($sp) is the location of incoming
argument 5.</p>
<div class="figure align-center" id="funccall-f2">
<a class="reference internal image-reference" href="_images/21.png"><img alt="_images/21.png" src="_images/21.png" style="width: 740.0px; height: 577.0px;" /></a>
<p class="caption">Mips arguments location in stack frame</p>
</div>
<p>The 007-2418-003.pdf in
<a class="reference external" href="https://www.dropbox.com/home/LLVMBackendTutorial/doc/MIPSproAssemblyLanguageProgrammerGuide">https://www.dropbox.com/home/LLVMBackendTutorial/doc/MIPSproAssemblyLanguageProgrammerGuide</a>
is the Mips assembly language manual.
psABI-mips.pdf in <a class="reference external" href="https://www.dropbox.com/sh/2pkh1fewlq2zag9/buvX_zeN09/doc">https://www.dropbox.com/sh/2pkh1fewlq2zag9/buvX_zeN09/doc</a> is
Mips Application Binary Interface which include the <a class="reference internal" href="#funccall-f1"><em>Mips stack frame</em></a>.</p>
</div>
<div class="section" id="load-incoming-arguments-from-stack-frame">
<h2>Load incoming arguments from stack frame<a class="headerlink" href="#load-incoming-arguments-from-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>From last section, to support function call, we need implement the arguments
pass mechanism with stack frame. Before do that, let&#8217;s run the old version of
code 6/1/Cpu0 with ch7_1.cpp and see what happen.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-31:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch7_1.bc -o ch7_1.cpu0.s
Assertion failed: <span class="o">(</span>InVals.size<span class="o">()</span> <span class="o">==</span> Ins.size<span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="s2">&quot;LowerFormalArguments didn&#39;t</span>
<span class="s2">emit the correct number of values!&quot;</span><span class="o">)</span>, <span class="k">function </span>LowerArguments, file /Users/
Jonathan/llvm/3.1.test/cpu0/1/src/lib/CodeGen/SelectionDAG/
SelectionDAGBuilder.cpp, line 6671.
Stack dump:
0.  Program arguments: /Users/Jonathan/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch7_1.bc -o
ch7_1.cpu0.s
1.  Running pass <span class="s1">&#39;Function Pass Manager&#39;</span> on module <span class="s1">&#39;ch7_1.bc&#39;</span>.
2.  Running pass <span class="s1">&#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39;</span> on <span class="k">function</span>
<span class="s1">&#39;@_Z5sum_iiiiiii&#39;</span>
Illegal instruction: 4
</pre></div>
</div>
<p>Since 6/1/Cpu0 define the LowerFormalArguments() with empty, we get the error
message as above.
Before define LowerFormalArguments(), we have to choose how to pass arguments
in function call. We choose pass arguments all in stack frame.
We don&#8217;t reserve any dedicated register for arguments passing since cpu0 has
only 16 registers while Mips has 32 registers. Cpu0CallingConv.td is defined
for cpu0 passing rule as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0CallingConv.td</span>
<span class="p">...</span>
<span class="n">def</span> <span class="n">RetCC_Cpu0EABI</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="c1">// i32 are returned in registers V0, V1</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToReg</span><span class="o">&lt;</span><span class="p">[</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">]</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 EABI Calling Convention</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">CC_Cpu0EABI</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="c1">// Promote i8/i16 arguments to i32.</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i8</span><span class="p">,</span> <span class="n">i16</span><span class="p">],</span> <span class="n">CCPromoteToType</span><span class="o">&lt;</span><span class="n">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span>
  <span class="c1">// Integer values get stored in stack slots that are 4 bytes in</span>
  <span class="c1">// size and 4-byte aligned.</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToStack</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>


<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Calling Convention Dispatch</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">CC_Cpu0</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="n">CCDelegateTo</span><span class="o">&lt;</span><span class="n">CC_Cpu0EABI</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>


<span class="n">def</span> <span class="n">RetCC_Cpu0</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="n">CCDelegateTo</span><span class="o">&lt;</span><span class="n">RetCC_Cpu0EABI</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>

<span class="n">def</span> <span class="n">CSR_O32</span> <span class="o">:</span> <span class="n">CalleeSavedRegs</span><span class="o">&lt;</span><span class="p">(</span><span class="n">add</span> <span class="n">LR</span><span class="p">,</span> <span class="n">FP</span><span class="p">,</span>
                                   <span class="p">(</span><span class="n">sequence</span> <span class="s">&quot;S%u&quot;</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">))</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>As above, CC_Cpu0 is the cpu0 Calling Convention which delegate to CC_Cpu0EABI
and define the CC_Cpu0EABI.
The reason we don&#8217;t define the Calling Convention directly in CC_Cpu0 is that
a real general CPU like Mips can have several Calling Convention.
Combine with the mechanism of <a class="reference external" href="http://jonathan2251.github.com/lbd/llvmstructure.html#target-registration">section Target Registration</a> which llvm
supplied, we can use different Calling Convention in  different target.
Although cpu0 only have a Calling Convention right now, define with a dedicate
Call Convention name (CC_Cpu0EABI in this example) is a better solution for
system expand, and naming your Calling Convention. CC_Cpu0EABI as above, say it
pass arguments in stack frame.</p>
<p>Function LowerFormalArguments() charge function incoming arguments creation.
We define it as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0ISelLowering.cpp</span>
<span class="p">...</span>
<span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Used with vargs to acumulate store chains.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="n">OutChains</span><span class="p">;</span>

  <span class="c1">// Assign locations to all of the incoming arguments.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">ArgLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
                 <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">ArgLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeFormalArguments</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">CC_Cpu0</span><span class="p">);</span>

  <span class="n">Function</span><span class="o">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span> <span class="o">=</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">arg_begin</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">LastFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// Cpu0FI-&gt;LastInArgFI is 0 at the entry of this function.</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">FuncArg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">EVT</span> <span class="n">ValVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getValVT</span><span class="p">();</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>
    <span class="kt">bool</span> <span class="n">IsRegLoc</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">isRegLoc</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// sanity check</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isMemLoc</span><span class="p">());</span>

    <span class="c1">// The stack pointer offset is relative to the caller stack frame.</span>
    <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span>
                                    <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>

    <span class="c1">// Create load nodes to retrieve arguments from the stack</span>
    <span class="n">SDValue</span> <span class="n">FIN</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>
    <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">ValVT</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span>
                                 <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getFixedStack</span><span class="p">(</span><span class="n">LastFI</span><span class="p">),</span>
                                 <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setLastInArgFI</span><span class="p">(</span><span class="n">LastFI</span><span class="p">);</span>
  <span class="c1">// All stores are grouped in one node to allow the matching between</span>
  <span class="c1">// the size of Ins and InVals. This only happens when on varg functions</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OutChains</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">OutChains</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Refresh <a class="reference external" href="http://jonathan2251.github.com/lbd/globalvar.html#global-variable">section Global variable</a>, we have take care global
variable translation by create the IR DAG in LowerGlobalAddress() first, and
then do the Instruction Selection by their corresponding machine instruction
DAG in Cpu0InstrInfo.td.
LowerGlobalAddress() is called when llc meet the global variable access.
LowerFormalArguments() work with the same way.
It is called when function is entered.
It get incoming arguments information by CCInfo(CallConv,..., ArgLocs, …)
before enter “for loop”. In ch7_1.cpp, there are 6 arguments in sum_i(...)
function call and we use the stack frame only for arguments passing without
any arguments pass in registers.
So ArgLocs.size() is 6, each argument information is in ArgLocs[i] and
ArgLocs[i].isMemLoc() is true.
In “for loop”, it create each frame index object by LastFI =
MFI-&gt;CreateFixedObject(ValVT.getSizeInBits()/8,VA.getLocMemOffset(), true) and
FIN = DAG.getFrameIndex(LastFI, getPointerTy()).
nd then create IR DAG load node and put the load node into vector InVals by
InVals.push_back(DAG.getLoad(ValVT, dl, Chain, FIN,
MachinePointerInfo::getFixedStack(LastFI), false, false, false, 0)).
Cpu0FI-&gt;setVarArgsFrameIndex(0) and Cpu0FI-&gt;setLastInArgFI(LastFI) are called
when before and after above work. In ch7_1.cpp example, LowerFormalArguments()
will be called twice. First time is for sum_i() which will create 6 load DAG
for 6 incoming arguments passing into this function.
Second time is for main() which didn&#8217;t create any load DAG for no incoming
argument passing into main().
In addition to LowerFormalArguments() which create the load DAG, we need to
define the loadRegFromStackSlot() to issue the machine instruction
“ld $r, offset($sp)” to load incoming arguments from stack frame offset.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0InstrInfo.cpp</span>
<span class="p">...</span>
<span class="k">static</span> <span class="n">MachineMemOperand</span><span class="o">*</span> <span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MBB</span><span class="p">.</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="o">*</span><span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Align</span> <span class="o">=</span> <span class="n">MFI</span><span class="p">.</span><span class="n">getObjectAlignment</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MF</span><span class="p">.</span><span class="n">getMachineMemOperand</span><span class="p">(</span><span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getFixedStack</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span> <span class="n">Flag</span><span class="p">,</span>
                                 <span class="n">MFI</span><span class="p">.</span><span class="n">getObjectSize</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span> <span class="n">Align</span><span class="p">);</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span>
<span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                     <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">MMO</span> <span class="o">=</span> <span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">MachineMemOperand</span><span class="o">::</span><span class="n">MOLoad</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">RC</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegisterClass</span><span class="p">)</span>
    <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Register class not handled!&quot;</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">),</span> <span class="n">DestReg</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">addMemOperand</span><span class="p">(</span><span class="n">MMO</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Beyond Calling Convention and LowerFormalArguments(), 7/2/Cpu0 add following
code for cpu0 instructions swi (Software Interrupt) and jsub, jalr
(function call) definition and printing.</p>
<div class="highlight-c++"><pre>// Cpu0InstrFormats.td
...
// Cpu0 Pseudo Instructions Format
class Cpu0Pseudo&lt;dag outs, dag ins, string asmstr, list&lt;dag&gt; pattern&gt;:
      Cpu0Inst&lt;outs, ins, asmstr, pattern, IIPseudo, Pseudo&gt; {
  let isCodeGenOnly = 1;
  let isPseudo = 1;
}

// Cpu0InstrInfo.td
...
def SDT_Cpu0JmpLink      : SDTypeProfile&lt;0, 1, [SDTCisVT&lt;0, iPTR&gt;]&gt;;
...
// Call
def Cpu0JmpLink : SDNode&lt;"Cpu0ISD::JmpLink",SDT_Cpu0JmpLink,
                         [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue,
                          SDNPVariadic]&gt;;
...
// These are target-independent nodes, but have target-specific formats.
def callseq_start : SDNode&lt;"ISD::CALLSEQ_START", SDT_Cpu0CallSeqStart,
                           [SDNPHasChain, SDNPOutGlue]&gt;;
def callseq_end   : SDNode&lt;"ISD::CALLSEQ_END", SDT_Cpu0CallSeqEnd,
                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]&gt;;
…
def jmptarget   : Operand&lt;OtherVT&gt; {
  let EncoderMethod = "getJumpTargetOpValue";
}
…
def calltarget  : Operand&lt;iPTR&gt; {
  let EncoderMethod = "getJumpTargetOpValue";
}
…
// Jump and Link (Call)
let isCall=1, hasDelaySlot=0 in {
  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, "\t$target"), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
       let DecoderMethod = "DecodeJumpTarget";
       }

  class JumpLinkReg&lt;bits&lt;8&gt; op, string instr_asm,
                    RegisterClass RC&gt;:
    FA&lt;op, (outs), (ins RC:$rb, variable_ops),
       !strconcat(instr_asm, "\t$rb"), [(Cpu0JmpLink RC:$rb)], IIBranch&gt; {
    let rc = 0;
    let ra = 14;
    let shamt = 0;
  }
}
…
/// Jump and Branch Instructions
def SWI  : JumpLink&lt;0x2A, "swi"&gt;;
def JSUB : JumpLink&lt;0x2B, "jsub"&gt;;
…
def JALR : JumpLinkReg&lt;0x2D, "jalr", CPURegs&gt;;
…
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
…

// Cpu0InstPrinter.cpp
…
static void printExpr(const MCExpr *Expr, raw_ostream &amp;OS) {
  switch (Kind) {
  ...
  case MCSymbolRefExpr::VK_Cpu0_GOT_CALL:  OS &lt;&lt; "%call24("; break;
  …
  }
…
}

// Cpu0MCCodeEmitter.cpp
…
unsigned Cpu0MCCodeEmitter::
getMachineOpValue(const MCInst &amp;MI, const MCOperand &amp;MO,
                  SmallVectorImpl&lt;MCFixup&gt; &amp;Fixups) const {
...
  switch(cast&lt;MCSymbolRefExpr&gt;(Expr)-&gt;getKind()) {
  ...
  case MCSymbolRefExpr::VK_Cpu0_GOT_CALL:
    FixupKind = Cpu0::fixup_Cpu0_CALL24;
    break;
  …
  }
…
}

// Cpu0MachineFucntion.h
class Cpu0FunctionInfo : public MachineFunctionInfo {
  ...
    /// VarArgsFrameIndex - FrameIndex for start of varargs area.
  int VarArgsFrameIndex;

  // Range of frame object indices.
  // InArgFIRange: Range of indices of all frame objects created during call to
  //               LowerFormalArguments.
  // OutArgFIRange: Range of indices of all frame objects created during call to
  //                LowerCall except for the frame object for restoring $gp.
  std::pair&lt;int, int&gt; InArgFIRange, OutArgFIRange;
  int GPFI; // Index of the frame object for restoring $gp
  mutable int DynAllocFI; // Frame index of dynamically allocated stack area.
  unsigned MaxCallFrameSize;

public:
  Cpu0FunctionInfo(MachineFunction&amp; MF)
  : MF(MF), GlobalBaseReg(0),
    VarArgsFrameIndex(0), InArgFIRange(std::make_pair(-1, 0)),
    OutArgFIRange(std::make_pair(-1, 0)), GPFI(0), DynAllocFI(0),
    MaxCallFrameSize(0)
    {}

  bool isInArgFI(int FI) const {
    return FI &lt;= InArgFIRange.first &amp;&amp; FI &gt;= InArgFIRange.second;
  }
  void setLastInArgFI(int FI) { InArgFIRange.second = FI; }

  void extendOutArgFIRange(int FirstFI, int LastFI) {
    if (!OutArgFIRange.second)
      // this must be the first time this function was called.
      OutArgFIRange.first = FirstFI;
    OutArgFIRange.second = LastFI;
  }

  int getGPFI() const { return GPFI; }
  void setGPFI(int FI) { GPFI = FI; }
  bool needGPSaveRestore() const { return getGPFI(); }
  bool isGPFI(int FI) const { return GPFI &amp;&amp; GPFI == FI; }

  // The first call to this function creates a frame object for dynamically
  // allocated stack area.
  int getDynAllocFI() const {
    if (!DynAllocFI)
      DynAllocFI = MF.getFrameInfo()-&gt;CreateFixedObject(4, 0, true);

    return DynAllocFI;
  }
  bool isDynAllocFI(int FI) const { return DynAllocFI &amp;&amp; DynAllocFI == FI; }
  ...
  int getVarArgsFrameIndex() const { return VarArgsFrameIndex; }
  void setVarArgsFrameIndex(int Index) { VarArgsFrameIndex = Index; }

  unsigned getMaxCallFrameSize() const { return MaxCallFrameSize; }
  void setMaxCallFrameSize(unsigned S) { MaxCallFrameSize = S; }
};</pre>
</div>
<p>After above changes, you can run 7/2/Cpu0 with ch7_1.cpp and see what happen
as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-83:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch7_1.bc -o ch7_1.cpu0.s
Assertion failed: <span class="o">((</span>isTailCall <span class="o">||</span> InVals.size<span class="o">()</span> <span class="o">==</span> Ins.size<span class="o">())</span> <span class="o">&amp;&amp;</span>
<span class="s2">&quot;LowerCall didn&#39;t emit the correct number of values!&quot;</span><span class="o">)</span>, <span class="k">function </span>LowerCallTo,
file /Users/Jonathan/llvm/3.1.test/cpu0/1/src/lib/CodeGen/SelectionDAG/
SelectionDAGBuilder.cpp, line 6482.
Stack dump:
0.  Program arguments: /Users/Jonathan/llvm/3.1.test/cpu0/1/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch7_1.bc -o
ch7_1.cpu0.s
1.  Running pass <span class="s1">&#39;Function Pass Manager&#39;</span> on module <span class="s1">&#39;ch7_1.bc&#39;</span>.
2.  Running pass <span class="s1">&#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39;</span> on <span class="k">function</span>
<span class="s1">&#39;@main&#39;</span>
Illegal instruction: 4
</pre></div>
</div>
</div>
<div class="section" id="store-outgoing-arguments-to-stack-frame">
<h2>Store outgoing arguments to stack frame<a class="headerlink" href="#store-outgoing-arguments-to-stack-frame" title="Permalink to this headline">¶</a></h2>
<p><a class="reference internal" href="#funccall-f2"><em>Mips arguments location in stack frame</em></a> depicted two steps to take care arguments passing.
One is store outgoing arguments in caller function, and the other is load
incoming arguments in callee function.
We define LowerFormalArguments() to do “load incoming arguments” in callee
function of the last section.
Now, we have to finish “store outgoing arguments” in caller function.
LowerCall() is responsible to do this. The implementation as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Cpu0ISelLowering.cpp</span>
<span class="p">...</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">InChain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Callee</span><span class="p">,</span>
                              <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                              <span class="kt">bool</span> <span class="n">doesNotRet</span><span class="p">,</span> <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">isTailCall</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                              <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                              <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Cpu0 target does not yet support tail call optimization.</span>
  <span class="n">isTailCall</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFL</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">IsPIC</span> <span class="o">=</span> <span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">;</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Analyze operands of the call, assigning locations to each operand.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">ArgLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
                 <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">ArgLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeCallOperands</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">CC_Cpu0</span><span class="p">);</span>

  <span class="c1">// Get a count of how many bytes are to be pushed on the stack.</span>
  <span class="kt">unsigned</span> <span class="n">NextStackOffset</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">getNextStackOffset</span><span class="p">();</span>

  <span class="c1">// If this is the first call, create a stack frame object that points to</span>
  <span class="c1">// a location to which .cprestore saves $gp.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPIC</span> <span class="o">&amp;&amp;</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">())</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setGPFI</span><span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">));</span>
  <span class="c1">// Get the frame index of the stack frame object that points to the location</span>
  <span class="c1">// of dynamically allocated area on the stack.</span>
  <span class="kt">int</span> <span class="n">DynAllocFI</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getDynAllocFI</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">MaxCallFrameSize</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getMaxCallFrameSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MaxCallFrameSize</span> <span class="o">&lt;</span> <span class="n">NextStackOffset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setMaxCallFrameSize</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">);</span>

    <span class="c1">// Set the offsets relative to $sp of the $gp restore slot and dynamically</span>
    <span class="c1">// allocated stack space. These offsets must be aligned to a boundary</span>
    <span class="c1">// determined by the stack alignment of the ABI.</span>
    <span class="kt">unsigned</span> <span class="n">StackAlignment</span> <span class="o">=</span> <span class="n">TFL</span><span class="o">-&gt;</span><span class="n">getStackAlignment</span><span class="p">();</span>
    <span class="n">NextStackOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">NextStackOffset</span> <span class="o">+</span> <span class="n">StackAlignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                      <span class="n">StackAlignment</span> <span class="o">*</span> <span class="n">StackAlignment</span><span class="p">;</span>

    <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setObjectOffset</span><span class="p">(</span><span class="n">DynAllocFI</span><span class="p">,</span> <span class="n">NextStackOffset</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Chain is the output chain of the last Load/Store or CopyToReg node.</span>
  <span class="c1">// ByValChain is the output chain of the last Memcpy node created for copying</span>
  <span class="c1">// byval arguments to the stack.</span>
  <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">CallSeqStart</span><span class="p">,</span> <span class="n">ByValChain</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">NextStackOffsetVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">,</span> <span class="kc">true</span><span class="p">);</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">CallSeqStart</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_START</span><span class="p">(</span><span class="n">InChain</span><span class="p">,</span> <span class="n">NextStackOffsetVal</span><span class="p">);</span>
  <span class="n">ByValChain</span> <span class="o">=</span> <span class="n">InChain</span><span class="p">;</span>

  <span class="c1">// With EABI is it possible to have 16 args on registers.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RegsToPass</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">MemOpChains</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">FirstFI</span> <span class="o">=</span> <span class="o">-</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getNumFixedObjects</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LastFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Walk the register/memloc assignments, inserting copies/loads.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">Arg</span> <span class="o">=</span> <span class="n">OutVals</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">MVT</span> <span class="n">ValVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">LocVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocVT</span><span class="p">();</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">Outs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>

    <span class="c1">// ByVal Arg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="s">&quot;!!!Error!!!, Flags.isByVal()==true&quot;</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Register can&#39;t get to this point...</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isMemLoc</span><span class="p">());</span>

    <span class="c1">// Create the frame index object for this incoming parameter</span>
    <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span>
                                    <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span> <span class="kc">true</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">PtrOff</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>

    <span class="c1">// emit ISD::STORE whichs stores the</span>
    <span class="c1">// parameter value to a stack Location</span>
    <span class="n">MemOpChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">PtrOff</span><span class="p">,</span>
                                       <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Extend range of indices of frame objects for outgoing arguments that were</span>
  <span class="c1">// created during this function call. Skip this step if no such objects were</span>
  <span class="c1">// created.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LastFI</span><span class="p">)</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">extendOutArgFIRange</span><span class="p">(</span><span class="n">FirstFI</span><span class="p">,</span> <span class="n">LastFI</span><span class="p">);</span>

  <span class="c1">// If a memcpy has been created to copy a byval arg to a stack, replace the</span>
  <span class="c1">// chain input of CallSeqStart with ByValChain.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">InChain</span> <span class="o">!=</span> <span class="n">ByValChain</span><span class="p">)</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">UpdateNodeOperands</span><span class="p">(</span><span class="n">CallSeqStart</span><span class="p">.</span><span class="n">getNode</span><span class="p">(),</span> <span class="n">ByValChain</span><span class="p">,</span>
                           <span class="n">NextStackOffsetVal</span><span class="p">);</span>

  <span class="c1">// Transform all store nodes into one single node because all store</span>
  <span class="c1">// nodes are independent of each other.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MemOpChains</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MemOpChains</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// If the callee is a GlobalAddress/ExternalSymbol node (quite common, every</span>
  <span class="c1">// direct call is) turn it into a TargetGlobalAddress/TargetExternalSymbol</span>
  <span class="c1">// node so that legalize doesn&#39;t hack it.</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">OpFlag</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsPICCall</span> <span class="o">=</span> <span class="n">IsPIC</span><span class="p">;</span> <span class="c1">// true if calls are translated to jalr $25</span>
  <span class="kt">bool</span> <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="kc">false</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">CalleeLo</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GlobalAddressSDNode</span> <span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalAddressSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Callee</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">OpFlag</span> <span class="o">=</span> <span class="n">IsPICCall</span> <span class="o">?</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_CALL</span> <span class="o">:</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_NO_FLAG</span><span class="p">;</span>
    <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">(),</span> <span class="n">dl</span><span class="p">,</span>
                                          <span class="n">getPointerTy</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OpFlag</span><span class="p">);</span>
    <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ExternalSymbolSDNode</span> <span class="o">*</span><span class="n">S</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ExternalSymbolSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Callee</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsPIC</span><span class="p">)</span> <span class="c1">// static</span>
      <span class="n">OpFlag</span> <span class="o">=</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_NO_FLAG</span><span class="p">;</span>
    <span class="k">else</span> <span class="c1">// O32 &amp; PIC</span>
      <span class="n">OpFlag</span> <span class="o">=</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_CALL</span><span class="p">;</span>
    <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetExternalSymbol</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">(),</span> <span class="n">getPointerTy</span><span class="p">(),</span>
                                         <span class="n">OpFlag</span><span class="p">);</span>
    <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="kc">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">;</span>

  <span class="c1">// Create nodes that load address of callee and copy it to T9</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GlobalOrExternal</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Load callee address</span>
      <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span>
                           <span class="n">GetGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">()),</span> <span class="n">Callee</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">LoadValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">getPointerTy</span><span class="p">(),</span> <span class="n">dl</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span>
                                      <span class="n">Callee</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span>
                                      <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="kc">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

      <span class="c1">// Use GOT+LO if callee has internal linkage.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">CalleeLo</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">SDValue</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span> <span class="n">CalleeLo</span><span class="p">);</span>
        <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span> <span class="n">LoadValue</span><span class="p">,</span> <span class="n">Lo</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span>
        <span class="n">Callee</span> <span class="o">=</span> <span class="n">LoadValue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// T9 should contain the address of the callee function if</span>
  <span class="c1">// -reloction-model=pic or it is an indirect call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span> <span class="o">||</span> <span class="o">!</span><span class="n">GlobalOrExternal</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// copy to T9</span>
    <span class="kt">unsigned</span> <span class="n">T9Reg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">;</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">T9Reg</span><span class="p">,</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">SDValue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">T9Reg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// Cpu0JmpLink = #chain, #target_address, #opt_in_flags...</span>
  <span class="c1">//             = Chain, Callee, Reg#1, Reg#2, ...</span>
  <span class="c1">//</span>
  <span class="c1">// Returns a chain &amp; a flag for retval copy to use.</span>
  <span class="n">SDVTList</span> <span class="n">NodeTys</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getVTList</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">);</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">Ops</span><span class="p">;</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Callee</span><span class="p">);</span>

  <span class="c1">// Add argument registers to the end of the list so that they are</span>
  <span class="c1">// known live into the call.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">RegsToPass</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span>
                                  <span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">getValueType</span><span class="p">()));</span>

  <span class="c1">// Add a register mask operand representing the call-preserved registers.</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span> <span class="o">=</span> <span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRegisterInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">uint32_t</span> <span class="o">*</span><span class="n">Mask</span> <span class="o">=</span> <span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallConv</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Mask</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Missing call preserved mask for calling convention&quot;</span><span class="p">);</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegisterMask</span><span class="p">(</span><span class="n">Mask</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">InFlag</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">InFlag</span><span class="p">);</span>

  <span class="n">Chain</span>  <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">NodeTys</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ops</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Create the CALLSEQ_END node.</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_END</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span>
                             <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span>
                             <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="kc">true</span><span class="p">),</span> <span class="n">InFlag</span><span class="p">);</span>
  <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Handle result values, copying them out of physregs into vregs that we</span>
  <span class="c1">// return.</span>
  <span class="k">return</span> <span class="n">LowerCallResult</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">,</span> <span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span>
                         <span class="n">Ins</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">InVals</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// LowerCallResult - Lower the result values of a call into the</span>
<span class="c1">/// appropriate copies out of appropriate physical registers.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                                    <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                    <span class="n">DebugLoc</span> <span class="n">dl</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Assign locations to each value returned by this call.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="n">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
         <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">RVLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeCallResult</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">RetCC_Cpu0</span><span class="p">);</span>

  <span class="c1">// Copy all of the result registers out of their specified physreg.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getLocReg</span><span class="p">(),</span>
                               <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">InFlag</span><span class="p">).</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Just like load incoming arguments from stack frame, we call
CCInfo(CallConv,..., ArgLocs, …) to get outgoing arguments information before
enter “for loop” and set stack alignment with 8 bytes.
They&#8217;re almost same in “for loop” with LowerFormalArguments(), except
LowerCall() create store DAG vector instead of load DAG vector.
DAG.getCALLSEQ_START() and DAG.getCALLSEQ_END() are set before and after the
“for loop”, they insert CALLSEQ_START, CALLSEQ_END, and translate into pseudo
machine instructions !ADJCALLSTACKDOWN, !ADJCALLSTACKUP later according
Cpu0InstrInfo.td definition as follows.</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.td
...
// These are target-independent nodes, but have target-specific formats.
def callseq_start : SDNode&lt;"ISD::CALLSEQ_START", SDT_Cpu0CallSeqStart,
                           [SDNPHasChain, SDNPOutGlue]&gt;;
def callseq_end   : SDNode&lt;"ISD::CALLSEQ_END", SDT_Cpu0CallSeqEnd,
                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]&gt;;

//===----------------------------------------------------------------------===//
// Pseudo instructions
//===----------------------------------------------------------------------===//

// As stack alignment is always done with addiu, we need a 16-bit immediate
let Defs = [SP], Uses = [SP] in {
def ADJCALLSTACKDOWN : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt),
                                  "!ADJCALLSTACKDOWN $amt",
                                  [(callseq_start timm:$amt)]&gt;;
def ADJCALLSTACKUP   : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt1, uimm16:$amt2),
                                  "!ADJCALLSTACKUP $amt1",
                                  [(callseq_end timm:$amt1, timm:$amt2)]&gt;;
}


Like load incoming arguments, we need to implement storeRegToStackSlot() for
store outgoing arguments to stack frame offset.

.. code-block:: c++

// Cpu0InstrInfo.cpp
...
//- st SrcReg, MMO(FI)
void Cpu0InstrInfo::
storeRegToStackSlot(MachineBasicBlock &amp;MBB, MachineBasicBlock::iterator I,
                    unsigned SrcReg, bool isKill, int FI,
                    const TargetRegisterClass *RC,
                    const TargetRegisterInfo *TRI) const {
  DebugLoc DL;
  if (I != MBB.end()) DL = I-&gt;getDebugLoc();
  MachineMemOperand *MMO = GetMemOperand(MBB, FI, MachineMemOperand::MOStore);

  unsigned Opc = 0;

  if (RC == Cpu0::CPURegsRegisterClass)
    Opc = Cpu0::ST;
  assert(Opc &amp;&amp; "Register class not handled!");
  BuildMI(MBB, I, DL, get(Opc)).addReg(SrcReg, getKillRegState(isKill))
    .addFrameIndex(FI).addImm(0).addMemOperand(MMO);
}</pre>
</div>
<p>Now, let&#8217;s run 7/3/Cpu0 with ch7_1.cpp to get result as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-83:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch7_1.bc -o ch7_1.cpu0.s
118-165-79-83:InputFiles Jonathan<span class="nv">$ </span>cat ch7_1.cpu0.s
    .section .mdebug.abi32
    .previous
    .file   <span class="s2">&quot;ch7_1.bc&quot;</span>
    .text
    .globl  _Z5sum_iiiiiii
    .align  2
    .type   _Z5sum_iiiiiii,@function
    .ent    _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
    .frame  <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
    .mask   0x00000000,0
    .set    noreorder
    .set    nomacro
<span class="c"># BB#0:                                 # %entry</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
    ld  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    add <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
    ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
    add <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
    st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
    ret <span class="nv">$lr</span>
    .set    macro
    .set    reorder
    .end    _Z5sum_iiiiiii
<span class="nv">$tmp1</span>:
    .size   _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z5sum_iiiiiii

    .globl  main
    .align  2
    .type   main,@function
    .ent    main                    <span class="c"># @main</span>
main:
    .frame  <span class="nv">$sp</span>,40,<span class="nv">$lr</span>
    .mask   0x00004000,-4
    .set    noreorder
    .cpload <span class="nv">$t9</span>
    .set    nomacro
<span class="c"># BB#0:                                 # %entry</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
    st  <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
    st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    !ADJCALLSTACKDOWN 24
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
    st  <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // wrong offset
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
    st  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
    st  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
    st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
    st  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
    st  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$6</span>, %call24<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
    jalr    <span class="nv">$6</span>
    !ADJCALLSTACKUP 24
    st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    ld  <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
    ret <span class="nv">$lr</span>
    .set    macro
    .set    reorder
    .end    main
<span class="nv">$tmp4</span>:
    .size   main, <span class="o">(</span><span class="nv">$tmp4</span><span class="o">)</span>-main
</pre></div>
</div>
<p>It store the arguments to wrong offset.
We will fix this issue and take care !ADJCALLSTACKUP and !ADJCALLSTACKDOWN in
next two sections.</p>
</div>
<div class="section" id="fix-the-wrong-offset-in-storing-arguments-to-stack-frame">
<h2>Fix the wrong offset in storing arguments to stack frame<a class="headerlink" href="#fix-the-wrong-offset-in-storing-arguments-to-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>To fix the wrong offset in storing arguments, we modify the following code
in eliminateFrameIndex() as follows.
The bold text as below is added in 7/4/Cpu0 to set the caller outgoing
arguments into spOffset($sp) (7/3/Cpu0 set them to pOffset+stackSize($sp).</p>
<div class="highlight-c++"><pre>// Cpu0RegisterInfo.cpp
...
void Cpu0RegisterInfo::
eliminateFrameIndex(MachineBasicBlock::iterator II, int SPAdj,
                    RegScavenger *RS) const {
  …
  Cpu0FunctionInfo *Cpu0FI = MF.getInfo&lt;Cpu0FunctionInfo&gt;();
  …
  if (Cpu0FI-&gt;isOutArgFI(FrameIndex) || Cpu0FI-&gt;isDynAllocFI(FrameIndex) ||
      (FrameIndex &gt;= MinCSFI &amp;&amp; FrameIndex &lt;= MaxCSFI))
    FrameReg = Cpu0::SP;
  else
    FrameReg = getFrameRegister(MF);
  …
  // Calculate final offset.
  // - There is no need to change the offset if the frame object is one of the
  //   following: an outgoing argument, pointer to a dynamically allocated
  //   stack space or a $gp restore location,
  // - If the frame object is any of the following, its offset must be adjusted
  //   by adding the size of the stack:
  //   incoming argument, callee-saved register location or local variable.
  if (Cpu0FI-&gt;isOutArgFI(FrameIndex) || Cpu0FI-&gt;isGPFI(FrameIndex) ||
      Cpu0FI-&gt;isDynAllocFI(FrameIndex))
    Offset = spOffset;
  else
    Offset = spOffset + (int64_t)stackSize;
  Offset    += MI.getOperand(i+1).getImm();

  DEBUG(errs() &lt;&lt; "Offset     : " &lt;&lt; Offset &lt;&lt; "\n" &lt;&lt; "&lt;---------&gt;\n");

  // If MI is not a debug value, make sure Offset fits in the 16-bit immediate
  // field.
  if (!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset)) {
    assert("(!MI.isDebugValue() &amp;&amp; !isInt&lt;16&gt;(Offset))");
  }

  MI.getOperand(i).ChangeToRegister(FrameReg, false);
  MI.getOperand(i+1).ChangeToImmediate(Offset);

}

// Cpu0MachineFunction.h
  ...
  bool isOutArgFI(int FI) const {
    return FI &lt;= OutArgFIRange.first &amp;&amp; FI &gt;= OutArgFIRange.second;
  }</pre>
</div>
<p>Run 7/4/Cpu0 with ch7_1.cpp will get the following result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>
asm ch7_1.bc -o ch7_1.cpu0.s
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>cat ch7_1.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch7_1.bc&quot;</span>
  .text
  .globl  _Z5sum_iiiiiii
  .align  2
  .type _Z5sum_iiiiiii,@function
  .ent  _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 32
  ld  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  add <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z5sum_iiiiiii
<span class="nv">$tmp2</span>:
  .size _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-_Z5sum_iiiiiii
  .cfi_endproc

  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,40,<span class="nv">$lr</span>
  .mask   0x00004000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp5</span>:
  .cfi_def_cfa_offset 40
  st  <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp6</span>:
  .cfi_offset 14, -4
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  !ADJCALLSTACKDOWN 24
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$6</span>, %call24<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$6</span>
  !ADJCALLSTACKUP 24
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp7</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>Summary callee incoming arguments and caller outgoing arguments as
<a class="reference internal" href="#funccall-t1"><em>Callee incoming arguments and caller outgoing arguments</em></a>.</p>
<div class="figure align-center" id="funccall-t1">
<a class="reference internal image-reference" href="_images/12.png"><img alt="_images/12.png" src="_images/12.png" style="width: 694.0px; height: 153.0px;" /></a>
<p class="caption">Callee incoming arguments and caller outgoing arguments</p>
</div>
</div>
<div class="section" id="pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup">
<h2>Pseudo hook instruction ADJCALLSTACKDOWN and ADJCALLSTACKUP<a class="headerlink" href="#pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup" title="Permalink to this headline">¶</a></h2>
<p>To fix the !ADJSTACKDOWN and !1ADJSTACKUP, we call Cpu0GenInstrInfo(Cpu0::
ADJCALLSTACKDOWN, Cpu0::ADJCALLSTACKUP) in Cpu0InstrInfo() constructor
function and define eliminateCallFramePseudoInstr() as follows,</p>
<div class="highlight-c++"><pre>// Cpu0InstrInfo.cpp
...
Cpu0InstrInfo::Cpu0InstrInfo(Cpu0TargetMachine &amp;tm)
  : Cpu0GenInstrInfo(Cpu0::ADJCALLSTACKDOWN, Cpu0::ADJCALLSTACKUP),
…

// Cpu0RegisterInfo.cpp
...
// Cpu0
// This function eliminate ADJCALLSTACKDOWN,
// ADJCALLSTACKUP pseudo instructions
void Cpu0RegisterInfo::
eliminateCallFramePseudoInstr(MachineFunction &amp;MF, MachineBasicBlock &amp;MBB,
                MachineBasicBlock::iterator I) const {
  // Simply discard ADJCALLSTACKDOWN, ADJCALLSTACKUP instructions.
  MBB.erase(I);
}</pre>
</div>
<p>With above definition, eliminateCallFramePseudoInstr() will be called when
llvm meet pseudo instructions ADJCALLSTACKDOWN and ADJCALLSTACKUP.
We just discard these 2 pseudo instructions.
Run 7/4/Cpu0 with ch7_1.cpp will get the following result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype
<span class="o">=</span>asm ch7_1.bc -o ch7_1.cpu0.s
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>cat ch7_1.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch7_1.bc&quot;</span>
  .text
  .globl  _Z5sum_iiiiiii
  .align  2
  .type _Z5sum_iiiiiii,@function
  .ent  _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 32
  ld  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  add <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z5sum_iiiiiii
<span class="nv">$tmp2</span>:
  .size _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-_Z5sum_iiiiiii
  .cfi_endproc

  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,64,<span class="nv">$lr</span>
  .mask   0x00004000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -64
<span class="nv">$tmp5</span>:
  .cfi_def_cfa_offset 64
  st  <span class="nv">$lr</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp6</span>:
  .cfi_offset 14, -4
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$6</span>, %call24<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$6</span>
  st  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$lr</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 64
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp7</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
</div>
<div class="section" id="handle-gp-register-in-pic-addressing-mode">
<h2>Handle $gp register in PIC addressing mode<a class="headerlink" href="#handle-gp-register-in-pic-addressing-mode" title="Permalink to this headline">¶</a></h2>
<p>In <a class="reference external" href="http://jonathan2251.github.com/lbd/globalvar.html#global-variable">section Global variable</a>, we mentioned there are two addressing
mode, one is static address mode, the other is PIC (position-independent code).
We also mentioned, one example of PIC mode is used in share library.
Share library usually can be loaded in different memory address decided on run
time.
The static mode (absolute address mode) is usually designed to load in specific
memory address decided on compile time.
Since share library can be loaded in different memory address, the global
variable address cannot be decided in compile time.
Even though, we can decide the distance between global variable address and
shared library function if they will be loaded to the contiguous memory space
together.</p>
<p>Let&#8217;s run 7/5/Cpu0 with ch7_2.cpp to get the following result and we put the
comment in it for explanation.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-67-25:InputFiles Jonathan<span class="nv">$ </span>cat ch7_2.cpu0.s
    .section .mdebug.abi32
    .previous
    .file   <span class="s2">&quot;ch7_2.bc&quot;</span>
    .text
    .globl  _Z5sum_iiiiiii
    .align  2
    .type   _Z5sum_iiiiiii,@function
    .ent    _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
...
    .cpload <span class="nv">$t9</span> // assign <span class="nv">$gp</span> <span class="o">=</span> <span class="nv">$t9</span> by loader when loader load re-entry
                //  <span class="k">function</span> <span class="o">(</span>shared library<span class="o">)</span> of _Z5sum_iiiiiii
    .set    nomacro
<span class="c"># BB#0:</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
    .cfi_def_cfa_offset 32
...
    ld  <span class="nv">$3</span>, %got<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>   // %got<span class="o">(</span>gI<span class="o">)</span> is offset of <span class="o">(</span>gI - _Z5sum_iiiiiii<span class="o">)</span>
...
    ret <span class="nv">$lr</span>
    .set    macro
    .set    reorder
    .end    _Z5sum_iiiiiii
...
    .ent    main                    <span class="c"># @main</span>
main:
    .cfi_startproc
    .frame  <span class="nv">$sp</span>,72,<span class="nv">$lr</span>
    .mask   0x00004000,-4
    .set    noreorder
    .cpload <span class="nv">$t9</span>
    .set    nomacro
<span class="c"># BB#0:</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -72
<span class="nv">$tmp5</span>:
    .cfi_def_cfa_offset 72
    st  <span class="nv">$lr</span>, 68<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp6</span>:
    .cfi_offset 14, -4
    .cprestore  24  // save <span class="nv">$gp</span> to 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
...
    ld  <span class="nv">$6</span>, %call24<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
    jalr    <span class="nv">$6</span>      // <span class="nv">$t9</span> register number is 6, meaning <span class="nv">$6</span> and %t9 are the
                    //  same register
    ld  <span class="nv">$gp</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>    // restore <span class="nv">$gp</span> from 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
...
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 72
    ret <span class="nv">$lr</span>
    .set    macro
    .set    reorder
    .end    main
<span class="nv">$tmp7</span>:
    .size   main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
    .cfi_endproc

    .type   gI,@object              <span class="c"># @gI</span>
    .data
    .globl  gI
    .align  2
gI:
    .4byte  100                     <span class="c"># 0x64</span>
    .size   gI, 4
</pre></div>
</div>
<p>As above code comment, “.cprestore 24” is a pseudo instruction for save $gp to
24($sp); “ld $gp, 24($sp)” will restore the $gp.
In other word, $gp is caller saved register, so main() need to save/restore $gp
before/after call the shared library _Z5sum_iiiiiii() function.
In _Z5sum_iiiiiii() function, we translate global variable gI address by
“ld $3, %got(gI)($gp)” where %got(gI) is offset of (gI - _Z5sum_iiiiiii)
(we can write our cpu0 compiler to produce obj code by calculate the offset
value).</p>
<p>According the original cpu0 web site information, it only support “jsub” 24
bits address range access.
We add “jalr” to cpu0 and expand it to 32 bit address. We did this change for
two reason. One is cpu0 can be expand to 32 bit address space by only add this
instruction.
The other is cpu0 is designed for teaching purpose, this book is the same
purpose for llvm backend design. We reserve “jalr” as PIC mode for shared
library or dynamic loading code to demonstrate the caller how to handle the
caller saved register $gp in calling the shared library and the shared library
how to use $gp to access global variable address. This solution is popular in
reality and deserve change cpu0 official design as a compiler book.
Mips use the same solution in 32 bits Mips32 CPU.</p>
<p>Now, as the following code added in 7/5/Cpu0, we can issue “.cprestore” in
emitPrologue() and emit ld $gp, ($gp save slot on stack) after jalr by create
file Cpu0EmitGPRestore.cpp which run as a function pass.</p>
<div class="highlight-c++"><pre>// # CMakeLists.txt
...
add_llvm_target(Cpu0CodeGen
  ...
  Cpu0EmitGPRestore.cpp
…

// Cpu0TargetMachine.cpp
...
bool Cpu0PassConfig::addPreRegAlloc() {
  // Do not restore $gp if target is Cpu064.
  // In N32/64, $gp is a callee-saved register.

  PM-&gt;add(createCpu0EmitGPRestorePass(getCpu0TargetMachine()));
  return true;
}

// Cpu0.h
  ...
  FunctionPass *createCpu0EmitGPRestorePass(Cpu0TargetMachine &amp;TM);

// Cpu0FrameLowering.cpp
…

void Cpu0FrameLowering::emitPrologue(MachineFunction &amp;MF) const {
  ...
  unsigned RegSize = 4;
  unsigned LocalVarAreaOffset = Cpu0FI-&gt;needGPSaveRestore() ?
  (MFI-&gt;getObjectOffset(Cpu0FI-&gt;getGPFI()) + RegSize) :
  Cpu0FI-&gt;getMaxCallFrameSize();
  ….
  // Restore GP from the saved stack location
  if (Cpu0FI-&gt;needGPSaveRestore()) {
  unsigned Offset = MFI-&gt;getObjectOffset(Cpu0FI-&gt;getGPFI());
  BuildMI(MBB, MBBI, dl, TII.get(Cpu0::CPRESTORE)).addImm(Offset)
    .addReg(Cpu0::GP);
  }
}

// Cpu0InstrInfo.td
…
// When handling PIC code the assembler needs .cpload and .cprestore
// directives. If the real instructions corresponding these directives
// are used, we have the same behavior, but get also a bunch of warnings
// from the assembler.
let neverHasSideEffects = 1 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
               ".cprestore\t$loc", []&gt;;


// Cpu0SelLowering.cpp
…
SDValue
Cpu0TargetLowering::LowerCall(SDValue InChain, SDValue Callee,
                CallingConv::ID CallConv, bool isVarArg,
                bool doesNotRet, bool &amp;isTailCall,
                const SmallVectorImpl&lt;ISD::OutputArg&gt; &amp;Outs,
                const SmallVectorImpl&lt;SDValue&gt; &amp;OutVals,
                const SmallVectorImpl&lt;ISD::InputArg&gt; &amp;Ins,
                DebugLoc dl, SelectionDAG &amp;DAG,
                SmallVectorImpl&lt;SDValue&gt; &amp;InVals) const {
  ...
  // If this is the first call, create a stack frame object that points to
  // a location to which .cprestore saves $gp.
  if (IsPIC &amp;&amp; Cpu0FI-&gt;globalBaseRegFixed() &amp;&amp; !Cpu0FI-&gt;getGPFI())
  ...
  if (MaxCallFrameSize &lt; NextStackOffset) {
  if (Cpu0FI-&gt;needGPSaveRestore())
    MFI-&gt;setObjectOffset(Cpu0FI-&gt;getGPFI(), NextStackOffset);
  …
}

// Cpu0EmitGPRestore.cpp
//===-- Cpu0EmitGPRestore.cpp - Emit GP Restore Instruction ---------------===//
//
//                     The LLVM Compiler Infrastructure
//
// This file is distributed under the University of Illinois Open Source
// License. See LICENSE.TXT for details.
//
//===----------------------------------------------------------------------===//
//
// This pass emits instructions that restore $gp right
// after jalr instructions.
//
//===----------------------------------------------------------------------===//

#define DEBUG_TYPE "emit-gp-restore"

#include "Cpu0.h"
#include "Cpu0TargetMachine.h"
#include "Cpu0MachineFunction.h"
#include "llvm/CodeGen/MachineFunctionPass.h"
#include "llvm/CodeGen/MachineInstrBuilder.h"
#include "llvm/Target/TargetInstrInfo.h"
#include "llvm/ADT/Statistic.h"

using namespace llvm;

namespace {
  struct Inserter : public MachineFunctionPass {

  TargetMachine &amp;TM;
  const TargetInstrInfo *TII;

  static char ID;
  Inserter(TargetMachine &amp;tm)
    : MachineFunctionPass(ID), TM(tm), TII(tm.getInstrInfo()) { }

  virtual const char *getPassName() const {
    return "Cpu0 Emit GP Restore";
  }

  bool runOnMachineFunction(MachineFunction &amp;F);
  };
  char Inserter::ID = 0;
} // end of anonymous namespace

bool Inserter::runOnMachineFunction(MachineFunction &amp;F) {
  Cpu0FunctionInfo *Cpu0FI = F.getInfo&lt;Cpu0FunctionInfo&gt;();

  if ((TM.getRelocationModel() != Reloc::PIC_) ||
    (!Cpu0FI-&gt;globalBaseRegFixed()))
  return false;

  bool Changed = false;
  int FI = Cpu0FI-&gt;getGPFI();

  for (MachineFunction::iterator MFI = F.begin(), MFE = F.end();
     MFI != MFE; ++MFI) {
  MachineBasicBlock&amp; MBB = *MFI;
  MachineBasicBlock::iterator I = MFI-&gt;begin();

   /// IsLandingPad - Indicate that this basic block is entered via an
  /// exception handler.
  // If MBB is a landing pad, insert instruction that restores $gp after
  // EH_LABEL.
  if (MBB.isLandingPad()) {
    // Find EH_LABEL first.
    for (; I-&gt;getOpcode() != TargetOpcode::EH_LABEL; ++I) ;

    // Insert ld.
    ++I;
    DebugLoc dl = I != MBB.end() ? I-&gt;getDebugLoc() : DebugLoc();
    BuildMI(MBB, I, dl, TII-&gt;get(Cpu0::LD), Cpu0::GP).addFrameIndex(FI)
                             .addImm(0);
    Changed = true;
  }

  while (I != MFI-&gt;end()) {
    if (I-&gt;getOpcode() != Cpu0::JALR) {
    ++I;
    continue;
    }

    DebugLoc dl = I-&gt;getDebugLoc();
    // emit ld $gp, ($gp save slot on stack) after jalr
    BuildMI(MBB, ++I, dl, TII-&gt;get(Cpu0::LD), Cpu0::GP).addFrameIndex(FI)
                             .addImm(0);
    Changed = true;
  }
  }

  return Changed;
}

/// createCpu0EmitGPRestorePass - Returns a pass that emits instructions that
/// restores $gp clobbered by jalr instructions.
FunctionPass *llvm::createCpu0EmitGPRestorePass(Cpu0TargetMachine &amp;tm) {
  return new Inserter(tm);
}

//===-- Cpu0MachineFunctionInfo.h - Private data used for Cpu0 ----*- C++ -*-=//
…
class Cpu0FunctionInfo : public MachineFunctionInfo {
  ...
  bool EmitNOAT;

public:
  Cpu0FunctionInfo(MachineFunction&amp; MF)
  : ...
  MaxCallFrameSize(0), EmitNOAT(false)
  ...
  bool getEmitNOAT() const { return EmitNOAT; }
  void setEmitNOAT() { EmitNOAT = true; }

};

} // end of namespace llvm

#endif // CPU0_MACHINE_FUNCTION_INFO_H

//  Cpu0AsmPrinter.cpp
...
void Cpu0AsmPrinter::EmitInstrWithMacroNoAT(const MachineInstr *MI) {
  MCInst TmpInst;

  MCInstLowering.Lower(MI, TmpInst);
  OutStreamer.EmitRawText(StringRef("\t.set\tmacro"));
  if (Cpu0FI-&gt;getEmitNOAT())
  OutStreamer.EmitRawText(StringRef("\t.set\tat"));
  OutStreamer.EmitInstruction(TmpInst);
  if (Cpu0FI-&gt;getEmitNOAT())
  OutStreamer.EmitRawText(StringRef("\t.set\tnoat"));
  OutStreamer.EmitRawText(StringRef("\t.set\tnomacro"));
}

void Cpu0AsmPrinter::EmitInstruction(const MachineInstr *MI) {
  ...
  unsigned Opc = MI-&gt;getOpcode();
  MCInst TmpInst0;
  SmallVector&lt;MCInst, 4&gt; MCInsts;

  switch (Opc) {
  case Cpu0::CPRESTORE: {
  const MachineOperand &amp;MO = MI-&gt;getOperand(0);
  assert(MO.isImm() &amp;&amp; "CPRESTORE's operand must be an immediate.");
  int64_t Offset = MO.getImm();

  if (OutStreamer.hasRawTextSupport()) {
    if (!isInt&lt;16&gt;(Offset)) {
    EmitInstrWithMacroNoAT(MI);
    return;
    }
  } else {
    MCInstLowering.LowerCPRESTORE(Offset, MCInsts);

    for (SmallVector&lt;MCInst, 4&gt;::iterator I = MCInsts.begin();
       I != MCInsts.end(); ++I)
    OutStreamer.EmitInstruction(*I);

    return;
  }

  break;
  }
  default:
  break;
  }

  MCInstLowering.Lower(MI, TmpInst0);
  OutStreamer.EmitInstruction(TmpInst0);
}

void Cpu0AsmPrinter::EmitFunctionBodyStart() {
  ...
  if (OutStreamer.hasRawTextSupport()) {
  ...
  if (Cpu0FI-&gt;getEmitNOAT())
    OutStreamer.EmitRawText(StringRef("\t.set\tnoat"));
  } else if (EmitCPLoad) {
  SmallVector&lt;MCInst, 4&gt; MCInsts;
  MCInstLowering.LowerCPLOAD(MCInsts);
  for (SmallVector&lt;MCInst, 4&gt;::iterator I = MCInsts.begin();
     I != MCInsts.end(); ++I)
    OutStreamer.EmitInstruction(*I);
  }
}

// Cpu0MCInstLower.cpp
…
sstatic void CreateMCInst(MCInst&amp; Inst, unsigned Opc, const MCOperand&amp; Opnd0,
             const MCOperand&amp; Opnd1,
             const MCOperand&amp; Opnd2 = MCOperand()) {
  Inst.setOpcode(Opc);
  Inst.addOperand(Opnd0);
  Inst.addOperand(Opnd1);
  if (Opnd2.isValid())
  Inst.addOperand(Opnd2);
}

// Lower ".cpload $reg" to
//  "addiu $gp, $zero, %hi(_gp_disp)"
//  "shl   $gp, $gp, 16"
//  "addiu $gp, $gp, %lo(_gp_disp)"
//  "addu  $gp, $gp, $t9"
void Cpu0MCInstLower::LowerCPLOAD(SmallVector&lt;MCInst, 4&gt;&amp; MCInsts) {
  MCOperand GPReg = MCOperand::CreateReg(Cpu0::GP);
  MCOperand T9Reg = MCOperand::CreateReg(Cpu0::T9);
  MCOperand ZEROReg = MCOperand::CreateReg(Cpu0::ZERO);
  StringRef SymName("_gp_disp");
  const MCSymbol *Sym = Ctx-&gt;GetOrCreateSymbol(SymName);
  const MCSymbolRefExpr *MCSym;

  MCSym = MCSymbolRefExpr::Create(Sym, MCSymbolRefExpr::VK_Cpu0_ABS_HI, *Ctx);
  MCOperand SymHi = MCOperand::CreateExpr(MCSym);
  MCSym = MCSymbolRefExpr::Create(Sym, MCSymbolRefExpr::VK_Cpu0_ABS_LO, *Ctx);
  MCOperand SymLo = MCOperand::CreateExpr(MCSym);

  MCInsts.resize(4);

  CreateMCInst(MCInsts[0], Cpu0::ADDiu, GPReg, ZEROReg, SymHi);
  CreateMCInst(MCInsts[1], Cpu0::SHL, GPReg, GPReg, MCOperand::CreateImm(16));
  CreateMCInst(MCInsts[2], Cpu0::ADDiu, GPReg, GPReg, SymLo);
  CreateMCInst(MCInsts[3], Cpu0::ADD, GPReg, GPReg, T9Reg);
}

// Lower ".cprestore offset" to "st $gp, offset($sp)".
void Cpu0MCInstLower::LowerCPRESTORE(int64_t Offset,
                   SmallVector&lt;MCInst, 4&gt;&amp; MCInsts) {
  assert(isInt&lt;32&gt;(Offset) &amp;&amp; (Offset &gt;= 0) &amp;&amp;
     "Imm operand of .cprestore must be a non-negative 32-bit value.");

  MCOperand SPReg = MCOperand::CreateReg(Cpu0::SP), BaseReg = SPReg;
  MCOperand GPReg = MCOperand::CreateReg(Cpu0::GP);
  MCOperand ZEROReg = MCOperand::CreateReg(Cpu0::ZERO);

  if (!isInt&lt;16&gt;(Offset)) {
  unsigned Hi = ((Offset + 0x8000) &gt;&gt; 16) &amp; 0xffff;
  Offset &amp;= 0xffff;
  MCOperand ATReg = MCOperand::CreateReg(Cpu0::AT);
  BaseReg = ATReg;

  // addiu   at,zero,hi
  // shl     at,at,16
  // add     at,at,sp
  MCInsts.resize(3);
  CreateMCInst(MCInsts[0], Cpu0::ADDiu, ATReg, ZEROReg, MCOperand::CreateImm(Hi));
  CreateMCInst(MCInsts[1], Cpu0::SHL, ATReg, ATReg, MCOperand::CreateImm(16));
  CreateMCInst(MCInsts[2], Cpu0::ADD, ATReg, ATReg, SPReg);
  }

  MCInst St;
  CreateMCInst(St, Cpu0::ST, GPReg, BaseReg, MCOperand::CreateImm(Offset));
  MCInsts.push_back(St);
}</pre>
</div>
<p>The above added code of Cpu0AsmPrinter.cpp will call the LowerCPLOAD() and
LowerCPRESTORE() when user run with “llc -filetype=obj”.
The above added code of Cpu0MCInstLower.cpp take care the .cpload and
.cprestore machine instructions.
It translate pseudo asm .cpload into four machine instructions, and .cprestore
into one machine instruction as follows.
As mentioned in <a class="reference external" href="http://jonathan2251.github.com/lbd/globalvar.html#global-variable">section Global variable</a>.
When the share library main() function be loaded, the loader will assign the
$t9 value to $gp when meet “.cpload $t9”.
After that, the $gp value is $9 which point to main(), and the global variable
address is the relative address to main().
The _gp_disp is zero as the following reason from Mips ABI.</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Lower &quot;.cpload $reg&quot; to</span>
<span class="c1">//  &quot;addiu $gp, $zero, %hi(_gp_disp)&quot;</span>
<span class="c1">//  &quot;shl   $gp, $gp, 16&quot;</span>
<span class="c1">//  &quot;addiu $gp, $gp, %lo(_gp_disp)&quot;</span>
<span class="c1">//  &quot;addu  $gp, $gp, $t9&quot;</span>

<span class="c1">// Lower &quot;.cprestore offset&quot; to &quot;st $gp, offset($sp)&quot;.</span>
</pre></div>
</div>
<div class="admonition note">
<p class="first admonition-title">Note</p>
<p>// <strong>Mips ABI: _gp_disp</strong>
After calculating the gp, a function allocates the local stack space and saves
the gp on the stack, so it can be restored after subsequent function calls.
In other words, the gp is a caller saved register.</p>
<p>...</p>
<p class="last">_gp_disp represents the offset between the beginning of the function and the
global offset table.
Various optimizations are possible in this code example and the others that
follow.
For example, the calculation of gp need not be done for a position-independent
function that is strictly local to an object module.</p>
</div>
<p>By run with “llc -filetype=obj”, the .cpload and .cprestore are translated into
machine code as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>
obj ch7_2.bc -o ch7_2.cpu0.o
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>hexdump  ch7_2.cpu0.o
...
// .cpload machine instructions <span class="s2">&quot;09 a0 00 00 to 13 aa 60 00&quot;</span>
0000030 00 0a 00 07 09 a0 00 00 1e aa 00 10 09 aa 00 00
0000040 13 aa 60 00 09 dd ff e0 00 2d 00 20 01 2d 00 1c
...

// .cpload machine instructions <span class="s2">&quot;09 a0 00 00 to 13 aa 60 00&quot;</span>
00000b0 09 dd 00 20 2c 00 00 00 09 a0 00 00 1e aa 00 10
00000c0 09 aa 00 00 13 aa 60 00 09 dd ff b8 01 ed 00 44
// .cprestore machine instruction “ 01 ad 00 18”
00000d0 01 ad 00 18 09 20 00 00 01 2d 00 40 09 20 00 06
...

118-165-67-25:InputFiles Jonathan<span class="nv">$ </span>cat ch7_2.cpu0.s
...
  .ent  _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
...
  .cpload <span class="nv">$t9</span> // assign <span class="nv">$gp</span> <span class="o">=</span> <span class="nv">$t9</span> by loader when loader load re-entry <span class="k">function</span>
              // <span class="o">(</span>shared library<span class="o">)</span> of _Z5sum_iiiiiii
  .set  nomacro
<span class="c"># BB#0:</span>
...
  .ent  main                    <span class="c"># @main</span>
...
  .cpload <span class="nv">$t9</span>
  .set  nomacro
...
  .cprestore  24  // save <span class="nv">$gp</span> to 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
…
</pre></div>
</div>
<p>Run “llc -static” will call jsub instruction instead of jalr as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>
asm ch7_2.bc -o ch7_2.cpu0.s
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>cat ch7_2.cpu0.s
…
  jsub  _Z5sum_iiiiiii
...
</pre></div>
</div>
<p>The ch7_1_2.cpp, ch7_1_3.cpp and ch7_1_4.cpp are example code more for test.</p>
</div>
<div class="section" id="variable-number-of-arguments">
<h2>Variable number of arguments<a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this headline">¶</a></h2>
<p>Until now, we support fixed number of arguments is formal function definition.
This section support variable number of arguments since C language support
this feature.
Run 7/7/Cpu0 with ch7_3.cpp to get the following,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch7_3.cpp</span>
<span class="c1">//#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="kt">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">//  printf(&quot;a = %d\n&quot;, a);</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/3.1.test/cpu0/1/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>
asm ch7_3.bc -o ch7_3.cpu0.s
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>cat ch7_3.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch7_3.bc&quot;</span>
  .text
  .globl  _Z5sum_iiz
  .align  2
  .type _Z5sum_iiz,@function
  .ent  _Z5sum_iiz              <span class="c"># @_Z5sum_iiz</span>
_Z5sum_iiz:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,56,<span class="nv">$lr</span>
  .mask   0x00004000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -56
<span class="nv">$tmp2</span>:
  .cfi_def_cfa_offset 56
  st  <span class="nv">$lr</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp3</span>:
  .cfi_offset 14, -4
  .cprestore  0
  ld  <span class="nv">$2</span>, %got<span class="o">(</span>__stack_chk_guard<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> 0
  ld  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // amount
  st  <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // amount
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">i</span>  <span class="o">=</span> 0
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">val</span> <span class="o">=</span> 0
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">sum</span> <span class="o">=</span> 0
  addiu <span class="nv">$3</span>, <span class="nv">$sp</span>, 48 // <span class="nv">$3</span> <span class="o">=</span> 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>  // 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> <span class="nv">boundary</span> <span class="o">=</span>
          // <span class="o">(</span>the address of <span class="o">(</span>argument -1<span class="o">))</span> <span class="o">=</span> ptr_arg
  st  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">i</span> <span class="o">=</span> 0
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 40 // <span class="nv">$2</span> <span class="o">=</span> 40
<span class="nv">$BB0_1</span>:                                 <span class="c"># =&gt;This Inner Loop Header: Depth=1</span>
  ld  <span class="nv">$3</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">$3</span> <span class="o">=</span> amount
  ld  <span class="nv">$4</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">$4</span> <span class="o">=</span> i
  cmp <span class="nv">$4</span>, <span class="nv">$3</span>
  jge <span class="nv">$BB0_7</span>    // i &gt;<span class="o">=</span> amount
  jmp <span class="nv">$BB0_2</span>
<span class="nv">$BB0_2</span>:                                 <span class="c">#   in Loop: Header=BB0_1 Depth=1</span>
          // i &lt; amount
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>  // <span class="nv">$3</span> <span class="o">=</span> boundary
  cmp <span class="nv">$3</span>, <span class="nv">$2</span>
  jgt <span class="nv">$BB0_4</span>    // boundary &gt; 40
  jmp <span class="nv">$BB0_3</span>
<span class="nv">$BB0_3</span>:                                 <span class="c">#   in Loop: Header=BB0_1 Depth=1</span>
        // boundary &lt;<span class="o">=</span> 40
  addiu <span class="nv">$4</span>, <span class="nv">$3</span>, 8
  ld  <span class="nv">$5</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // *<span class="o">(</span>20<span class="o">(</span><span class="nv">$sp</span><span class="o">))</span> <span class="o">=</span> constant 8
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>  // boundary +<span class="o">=</span> 8
  add <span class="nv">$3</span>, <span class="nv">$5</span>, <span class="nv">$3</span>
  jmp <span class="nv">$BB0_5</span>
<span class="nv">$BB0_4</span>:                                 <span class="c">#   in Loop: Header=BB0_1 Depth=1</span>
          // boundary &gt; 40
  ld  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> ptr_arg
  addiu <span class="nv">$4</span>, <span class="nv">$3</span>, 8
  st  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // ptr_arg +<span class="o">=</span> 8
<span class="nv">$BB0_5</span>:                                 <span class="c">#   in Loop: Header=BB0_1 Depth=1</span>
  ld  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>   // <span class="nv">$3</span> <span class="o">=</span> <span class="nv">val</span> <span class="o">=</span> *ptr_arg
  st  <span class="nv">$3</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">$4</span> <span class="o">=</span> sum
  add <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$3</span>
  st  <span class="nv">$3</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // sum +<span class="o">=</span> val
<span class="c"># BB#6:                                 #   in Loop: Header=BB0_1 Depth=1</span>
  ld  <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">$3</span> <span class="o">=</span> i
  addiu <span class="nv">$3</span>, <span class="nv">$3</span>, 1
  st  <span class="nv">$3</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // <span class="nv">i</span> <span class="o">=</span> i + 1
  jmp <span class="nv">$BB0_1</span>
<span class="nv">$BB0_7</span>:
  ld  <span class="nv">$2</span>, %got<span class="o">(</span>__stack_chk_guard<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  cmp <span class="nv">$2</span>, <span class="nv">$3</span>
  jne <span class="nv">$BB0_9</span>
  jmp <span class="nv">$BB0_8</span>
<span class="nv">$BB0_8</span>:                                 <span class="c"># %SP_return</span>
  ld  <span class="nv">$lr</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 56
  ret <span class="nv">$lr</span>
<span class="nv">$BB0_9</span>:                                 <span class="c"># %CallStackCheckFailBlk</span>
  ld  <span class="nv">$6</span>, %call24<span class="o">(</span>__stack_chk_fail<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$6</span>
  ld  <span class="nv">$gp</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  .set  macro
  .set  reorder
  .end  _Z5sum_iiz
<span class="nv">$tmp4</span>:
  .size _Z5sum_iiz, <span class="o">(</span><span class="nv">$tmp4</span><span class="o">)</span>-_Z5sum_iiz
  .cfi_endproc

  .globl  main
  .align  2
  .type main,@function
  .ent  main                    <span class="c"># @main</span>
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,88,<span class="nv">$lr</span>
  .mask   0x00004000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -88
<span class="nv">$tmp7</span>:
  .cfi_def_cfa_offset 88
  st  <span class="nv">$lr</span>, 84<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp8</span>:
  .cfi_offset 14, -4
  .cprestore  32
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 80<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$6</span>, %call24<span class="o">(</span>_Z5sum_iiz<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$6</span>
  ld  <span class="nv">$gp</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 76<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$lr</span>, 84<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 88
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp9</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp9</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>We have problem in analysis of the output ch7_1.cpu0.s.
We guess and try to analysis as follows.
As above code, we get the first argument “amount” from “ld $2, 56($sp)” since
the stack size of the callee function “_Z5sum_iiz()” is 56.
Next, check i &lt; amount in block $BB0_1.
If  i &lt; amount, than enter into $BB0_2.
We assume boundary &gt; 40 and the content of address 16($sp) is the ptr_arg
which stored the address 64($sp).
When it exits $BB0_2 and enter into $BB0_4, the register $3 is the point to
the second argument and it do the sum += val in $BB0_5.
It do i += 1 in $BB0_6 and jumb to $BB0_1 enter into second round.
The second round do as above again, it will get the third argument and add
to sum in $BB0_5 since the ptr_arg (16($sp)) is added 8 in the previous run.
We assume the boundary &gt; 40 but actually according the analysis the boundary
is &lt; 40, so the above analysis in not satisfied.
The boundary &gt; 40 is exist in llvm IR, and mips has the same translated.
So, we don&#8217;t know what&#8217;s wrong. The llvm IR as following,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-221:InputFiles Jonathan<span class="nv">$ </span>llvm-dis ch7_3.bc -o ch7_3.ll
118-165-78-221:InputFiles Jonathan<span class="nv">$ </span>cat ch7_3.ll
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch7_3.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="s2">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="s2">32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-apple-macosx10.8.0&quot;</span>

%struct.__va_list_tag <span class="o">=</span> <span class="nb">type</span> <span class="o">{</span> i32, i32, i8*, i8* <span class="o">}</span>

define i32 @_Z5sum_iiz<span class="o">(</span>i32 %amount, ...<span class="o">)</span> nounwind uwtable ssp <span class="o">{</span>
...
; &lt;label&gt;:8                                       ; <span class="nv">preds</span> <span class="o">=</span> %4
...
  %12 <span class="o">=</span> icmp ule i32 %11, 40
  br i1 %12, label %13, label %19
</pre></div>
</div>
<p>We have verified the ch7_1.bc is correct by add printf and run with “lli”
llvm interpreter to get the correct result as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="kt">int</span> <span class="n">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;a = %d</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">,</span> <span class="n">a</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-221:InputFiles Jonathan<span class="nv">$ </span>lli ch7_3_1.bc
<span class="nv">a</span> <span class="o">=</span> 21
</pre></div>
</div>
<p>To support variable number of arguments, the following code needed only to
add in 7/7/Cpu0.
The ch7_3_2.cpp is C++ template example code, it can be translated into cpu0
backend code too.</p>
<div class="highlight-c++"><pre>// Cpu0TargetLowering.cpp
...
Cpu0TargetLowering::
Cpu0TargetLowering(Cpu0TargetMachine &amp;TM)
  : TargetLowering(TM, new Cpu0TargetObjectFile()),
  Subtarget(&amp;TM.getSubtarget&lt;Cpu0Subtarget&gt;()) {
  ...
  setOperationAction(ISD::VASTART,            MVT::Other, Custom);
  ...
  // Support va_arg(): variable numbers (not fixed numbers) of arguments
  //  (parameters) for function all
  setOperationAction(ISD::VAARG,             MVT::Other, Expand);
  setOperationAction(ISD::VACOPY,            MVT::Other, Expand);
  setOperationAction(ISD::VAEND,             MVT::Other, Expand);
  …
}
…

SDValue Cpu0TargetLowering::
LowerOperation(SDValue Op, SelectionDAG &amp;DAG) const
{
  switch (Op.getOpcode())
  {
  ...
  case ISD::VASTART:            return LowerVASTART(Op, DAG);
  }
  return SDValue();
}

...
SDValue Cpu0TargetLowering::LowerVASTART(SDValue Op, SelectionDAG &amp;DAG) const {
  MachineFunction &amp;MF = DAG.getMachineFunction();
  Cpu0FunctionInfo *FuncInfo = MF.getInfo&lt;Cpu0FunctionInfo&gt;();

  DebugLoc dl = Op.getDebugLoc();
  SDValue FI = DAG.getFrameIndex(FuncInfo-&gt;getVarArgsFrameIndex(),
                 getPointerTy());

  // vastart just stores the address of the VarArgsFrameIndex slot into the
  // memory location argument.
  const Value *SV = cast&lt;SrcValueSDNode&gt;(Op.getOperand(2))-&gt;getValue();
  return DAG.getStore(Op.getOperand(0), dl, FI, Op.getOperand(1),
            MachinePointerInfo(SV), false, false, 0);
}</pre>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// ch7_3_2.cpp</span>
<span class="p">...</span>
<span class="c1">//#include &lt;stdio.h&gt;</span>
<span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
  <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
  <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="n">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>
<span class="c1">//  printf(&quot;a = %d\n&quot;, a);</span>

  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>Until now, we have 5,500 lines of source code around in 7/7/Cpu0.
The cpu0 backend code now can take care the integer function call and control
statement just like the llvm front end tutorial example code.
Look back the chapter of “Back end structure”, there are 3,000 lines of source
code with taking three instructions only.
With this 80% more of code, it can translate tens of instructions, global
variable, control flow statement and function call.</p>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statement</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="todo.html">Todo List</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2012, LLVM.
      Created using <a href="http://sphinx.pocoo.org/">Sphinx</a> 1.1.3.
    </div>
  </body>
</html>