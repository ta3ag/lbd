<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
  "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">


<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
    
    <title>Function call &mdash; Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</title>
    
    <link rel="stylesheet" href="_static/haiku.css" type="text/css" />
    <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
    <link rel="stylesheet" href="_static/print.css" type="text/css" />
    
    <script type="text/javascript">
      var DOCUMENTATION_OPTIONS = {
        URL_ROOT:    './',
        VERSION:     '3.4.3',
        COLLAPSE_INDEX: false,
        FILE_SUFFIX: '.html',
        HAS_SOURCE:  true
      };
    </script>
    <script type="text/javascript" src="_static/jquery.js"></script>
    <script type="text/javascript" src="_static/underscore.js"></script>
    <script type="text/javascript" src="_static/doctools.js"></script>
    <script type="text/javascript" src="http://cdn.mathjax.org/mathjax/latest/MathJax.js?config=TeX-AMS-MML_HTMLorMML"></script>
    <script type="text/javascript" src="_static/theme_extras.js"></script>
    <link rel="author" title="About these documents" href="about.html" />
    <link rel="top" title="Tutorial: Creating an LLVM Backend for the Cpu0 Architecture" href="index.html" />
    <link rel="next" title="ELF Support" href="elf.html" />
    <link rel="prev" title="Control flow statements" href="ctrlflow.html" /> 
  </head>
  <body>
      <div class="header"><h1 class="heading"><a href="index.html">
          <span>Tutorial: Creating an LLVM Backend for the Cpu0 Architecture</span></a></h1>
        <h2 class="heading"><span>Function call</span></h2>
      </div>
      <div class="topnav">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>
      <div class="content">
        
        
  <div class="section" id="function-call">
<span id="sec-funccall"></span><h1>Function call<a class="headerlink" href="#function-call" title="Permalink to this headline">¶</a></h1>
<p>The subroutine/function call of backend code translation is supported in this
chapter.
A lots of code needed in function call. We break it down according llvm
supplied interface for easy to explanation.
This chapter start from introducing the Mips stack frame structure since we
borrow many part of ABI from it.
Although each CPU has it&#8217;s own ABI, most of RISC CPUs ABI are similar.
In addition to support fixed number of arguments function call, cpu0 also
upport variable number of arguments since C/C++ support this feature.
Supply Mips ABI and assemble language manual on internet link in this chapter
for your reference.
The section “4.5 DAG Lowering” of tricore_llvm.pdf contains some knowledge
about Lowering process. Section “4.5.1 Calling Conventions” of tricore_llvm.pdf
is the related materials you can reference.</p>
<p>This chapter is more complicate than any of the previous chapter.
It include stack frame and the related ABI support.
If you have problem in reading the stack frame illustrated in the first three
sections of this chapter, you can read the appendix B of “Procedure Call
Convention” of book “Computer Organization and Design” which listed in
section “RISC CPU knowledge” of chapter “Control flow statement” <a class="footnote-reference" href="#id10" id="id1">[1]</a>,
“Run Time Memory” of compiler book, or “Function Call Sequence”  and
“Stack Frame” of Mips ABI.</p>
<div class="section" id="mips-stack-frame">
<h2>Mips stack frame<a class="headerlink" href="#mips-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>The first thing for design the cpu0 function call is deciding how to pass
arguments in function call. There are two options.
The first is pass arguments all in stack.
Second is pass arguments in the registers which are reserved for function
arguments, and put the other arguments in stack if it over the number of
registers reserved for function call. For example, Mips pass the first 4
arguments in register $a0, $a1, $a2, $a3, and the other arguments in stack
if it over 4 arguments. <a class="pageref" href="#funccall-f1">Figure  1</a> is the Mips stack frame.</p>
<div class="figure align-center" id="funccall-f1">
<a class="reference internal image-reference" href="_images/14.png"><img alt="_images/14.png" src="_images/14.png" style="width: 688.0px; height: 531.0px;" /></a>
<p class="caption">Figure 1: Mips stack frame</p>
</div>
<p>Run <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-march=mips</span></tt> for ch9_1.bc, you will get the following result.
See comment <strong>&#8220;//&#8221;</strong>.</p>
<p class="rubric">lbdex/InputFiles/ch9_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="n">gI</span> <span class="o">=</span> <span class="mi">100</span><span class="p">;</span>

<span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">gI</span> <span class="o">+</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span>  
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_1.cpp -emit-llvm -o ch9_1.bc
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>mips -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.mips.s
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>cat ch9_1.mips.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_1.bc&quot;</span>
  .text
  .globl  _Z5sum_iiiiiii
  .align  2
  .type _Z5sum_iiiiiii,@function
  .set  nomips16                <span class="c"># @_Z5sum_iiiiiii</span>
  .ent  _Z5sum_iiiiiii
_Z5sum_iiiiiii:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,32,<span class="nv">$ra</span>
  .mask   0x00000000,0
  .fmask  0x00000000,0
  .set  noreorder
  .set  nomacro
  .set  noat
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 32
  sw  <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sw  <span class="nv">$5</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sw  <span class="nv">$t9</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  sw  <span class="nv">$7</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$1</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // load argument 5
  sw  <span class="nv">$1</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$1</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // load argument 6
  sw  <span class="nv">$1</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
  lw  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  lw  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  lw  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
  addu  <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$1</span>
  sw  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jr  <span class="nv">$ra</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
  .set  at
  .set  macro
  .set  reorder
  .end  _Z5sum_iiiiiii
<span class="nv">$tmp2</span>:
  .size _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-_Z5sum_iiiiiii
  .cfi_endproc

  .globl  main
  .align  2
  .type main,@function
  .set  nomips16                <span class="c"># @main</span>
  .ent  main
main:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,40,<span class="nv">$ra</span>
  .mask   0x80000000,-4
  .fmask  0x00000000,0
  .set  noreorder
  .set  nomacro
  .set  noat
<span class="c"># BB#0:</span>
  lui <span class="nv">$2</span>, %hi<span class="o">(</span>_gp_disp<span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>_gp_disp<span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp5</span>:
  .cfi_def_cfa_offset 40
  sw  <span class="nv">$ra</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp6</span>:
  .cfi_offset 31, -4
  addu  <span class="nv">$gp</span>, <span class="nv">$2</span>, <span class="nv">$25</span>
  sw  <span class="nv">$zero</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$1</span>, <span class="nv">$zero</span>, 6
  sw  <span class="nv">$1</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // Save argument 6 to 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$1</span>, <span class="nv">$zero</span>, 5
  sw  <span class="nv">$1</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> // Save argument 5 to 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$25</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  addiu <span class="nv">$4</span>, <span class="nv">$zero</span>, 1    // Pass argument 1 to <span class="nv">$4</span> <span class="o">(=</span><span class="nv">$a0</span><span class="o">)</span>
  addiu <span class="nv">$5</span>, <span class="nv">$zero</span>, 2    // Pass argument 2 to <span class="nv">$5</span> <span class="o">(=</span><span class="nv">$a1</span><span class="o">)</span>
  addiu <span class="nv">$t9</span>, <span class="nv">$zero</span>, 3
  jalr  <span class="nv">$25</span>
  addiu <span class="nv">$7</span>, <span class="nv">$zero</span>, 4
  sw  <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  lw  <span class="nv">$ra</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  jr  <span class="nv">$ra</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
  .set  at
  .set  macro
  .set  reorder
  .end  main
<span class="nv">$tmp7</span>:
  .size main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
  .cfi_endproc
</pre></div>
</div>
<p>From the mips assembly code generated as above, we know it save the first 4
arguments to $a0..$a3 and last 2 arguments to 16($sp) and 20($sp).
<a class="pageref" href="#funccall-f2">Figure  2</a> is the arguments location for example code
ch9_1.cpp.
It load argument 5 from 48($sp) in sum_i() since the argument 5 is saved to
16($sp) in main().
The stack size of sum_i() is 32, so 16+32($sp) is the location of incoming
argument 5.</p>
<div class="figure align-center" id="funccall-f2">
<a class="reference internal image-reference" href="_images/21.png"><img alt="_images/21.png" src="_images/21.png" style="width: 740.0px; height: 577.0px;" /></a>
<p class="caption">Figure 2: Mips arguments location in stack frame</p>
</div>
<p>The 007-2418-003.pdf in <a class="footnote-reference" href="#id11" id="id2">[2]</a> is the Mips assembly language manual.
<a class="footnote-reference" href="#id12" id="id3">[3]</a> is Mips Application Binary Interface which include the
<a class="pageref" href="#funccall-f1">Figure  1</a>.</p>
</div>
<div class="section" id="load-incoming-arguments-from-stack-frame">
<h2>Load incoming arguments from stack frame<a class="headerlink" href="#load-incoming-arguments-from-stack-frame" title="Permalink to this headline">¶</a></h2>
<p>From last section, to support function call, we need implementing the arguments
pass mechanism with stack frame. Before do that, let&#8217;s run the old version of
code Chapter8_1/ with ch9_1.cpp and see what happens.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-31:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_1.bc -o ch9_1.cpu0.s
Assertion failed: <span class="o">(</span>InVals.size<span class="o">()</span> <span class="o">==</span> Ins.size<span class="o">()</span> <span class="o">&amp;&amp;</span> <span class="s2">&quot;LowerFormalArguments didn&#39;t</span>
<span class="s2">emit the correct number of values!&quot;</span><span class="o">)</span>, <span class="k">function </span>LowerArguments, file /Users/
Jonathan/llvm/test/src/lib/CodeGen/SelectionDAG/
SelectionDAGBuilder.cpp, ...
...
0.  Program arguments: /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.cpu0.s
1.  Running pass <span class="s1">&#39;Function Pass Manager&#39;</span> on module <span class="s1">&#39;ch9_1.bc&#39;</span>.
2.  Running pass <span class="s1">&#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39;</span> on <span class="k">function</span>
<span class="s1">&#39;@_Z5sum_iiiiiii&#39;</span>
Illegal instruction: 4
</pre></div>
</div>
<p>Since Chapter8_1/ define the LowerFormalArguments() with empty, we get the error
message as above.
Before define LowerFormalArguments(), we have to choose how to pass arguments
in function call. We choose pass arguments all in stack frame.
We don&#8217;t reserve any dedicated register for arguments passing since cpu0 has
only 16 registers while Mips has 32 registers. Cpu0CallingConv.td is defined
for cpu0 passing rule as follows,</p>
<p class="rubric">lbdex/Chapter9_1/Cpu0CallingConv.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 EABI Calling Convention</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">CC_Cpu0EABI</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="c1">// Promote i8/i16 arguments to i32.</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i8</span><span class="p">,</span> <span class="n">i16</span><span class="p">],</span> <span class="n">CCPromoteToType</span><span class="o">&lt;</span><span class="n">i32</span><span class="o">&gt;&gt;</span><span class="p">,</span>
  <span class="c1">// Integer values get stored in stack slots that are 4 bytes in</span>
  <span class="c1">// size and 4-byte aligned.</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToStack</span><span class="o">&lt;</span><span class="mi">4</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>


<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">// Cpu0 Calling Convention Dispatch</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="n">def</span> <span class="n">CC_Cpu0</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="n">CCDelegateTo</span><span class="o">&lt;</span><span class="n">CC_Cpu0EABI</span><span class="o">&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>As above, CC_Cpu0 is the cpu0 Calling Convention which delegate to CC_Cpu0EABI
and define the CC_Cpu0EABI.
The reason we don&#8217;t define the Calling Convention directly in CC_Cpu0 is that
a real general CPU like Mips can have several Calling Convention.
Combine with the mechanism of &#8220;section Target Registration&#8221; <a class="footnote-reference" href="#id13" id="id4">[4]</a> which llvm
supplied, we can use different Calling Convention in  different target.
Although cpu0 only have a Calling Convention right now, define with a dedicate
Call Convention name (CC_Cpu0EABI in this example) is a better solution for
system expand, and naming your Calling Convention. CC_Cpu0EABI as above, say it
pass arguments in stack frame.</p>
<p>Function LowerFormalArguments() charge function incoming arguments creation.
We define it as follows,</p>
<p class="rubric">lbdex/Chapter9_1/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">/// LowerFormalArguments - transform physical registers into virtual registers</span>
<span class="c1">/// and generate load operations for arguments places on the stack.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                                         <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                                         <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                      <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                         <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                         <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                                          <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>

  <span class="c1">// Used with vargs to acumulate store chains.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="n">OutChains</span><span class="p">;</span>

  <span class="c1">// Assign locations to all of the incoming arguments.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">ArgLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
                 <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">ArgLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>
                         
  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeFormalArguments</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">CC_Cpu0</span><span class="p">);</span>

  <span class="n">Function</span><span class="o">::</span><span class="n">const_arg_iterator</span> <span class="n">FuncArg</span> <span class="o">=</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">arg_begin</span><span class="p">();</span>
  <span class="kt">int</span> <span class="n">LastFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span><span class="c1">// Cpu0FI-&gt;LastInArgFI is 0 at the entry of this function.</span>

  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">FuncArg</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">EVT</span> <span class="n">ValVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getValVT</span><span class="p">();</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">Ins</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span> 
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// sanity check</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isMemLoc</span><span class="p">());</span>

    <span class="c1">// The stack pointer offset is relative to the caller stack frame.</span>
    <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span>
                                    <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>

    <span class="c1">// Create load nodes to retrieve arguments from the stack</span>
    <span class="n">SDValue</span> <span class="n">FIN</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>
    <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">ValVT</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span>
                                 <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getFixedStack</span><span class="p">(</span><span class="n">LastFI</span><span class="p">),</span>
                                 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setLastInArgFI</span><span class="p">(</span><span class="n">LastFI</span><span class="p">);</span>
  <span class="c1">// All stores are grouped in one node to allow the matching between</span>
  <span class="c1">// the size of Ins and InVals. This only happens when on varg functions</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OutChains</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">OutChains</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">OutChains</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="p">}</span> <span class="c1">// if (!OutChains.empty())</span>
  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">virtual</span> <span class="n">SDValue</span>
    <span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
<span class="c1">// LowerCall: outgoing arguments</span>
</pre></div>
</div>
<p>Refresh &#8220;section Global variable&#8221; <a class="footnote-reference" href="#id14" id="id5">[5]</a>, we handled global
variable translation by create the IR DAG in LowerGlobalAddress() first, and
then do the Instruction Selection by their corresponding machine instruction
DAG in Cpu0InstrInfo.td.
LowerGlobalAddress() is called when <tt class="docutils literal"><span class="pre">llc</span></tt> meet the global variable access.
LowerFormalArguments() work with the same way.
It is called when function is entered.
It get incoming arguments information by CCInfo(CallConv,..., ArgLocs, ...)
before enter <strong>“for loop”</strong>. In ch9_1.cpp, there are 6 arguments in sum_i(...)
function call and we use the stack frame only for arguments passing without
any arguments pass in registers.
So ArgLocs.size() is 6, each argument information is in ArgLocs[i] and
ArgLocs[i].isMemLoc() is true.
In <strong>“for loop”</strong>, it create each frame index object by LastFI =
MFI-&gt;CreateFixedObject(ValVT.getSizeInBits()/8,VA.getLocMemOffset(), true) and
FIN = DAG.getFrameIndex(LastFI, getPointerTy()).
And then create IR DAG load node and put the load node into vector InVals by
InVals.push_back(DAG.getLoad(ValVT, DL, Chain, FIN,
MachinePointerInfo::getFixedStack(LastFI), false, false, false, 0)).
Cpu0FI-&gt;setVarArgsFrameIndex(0) and Cpu0FI-&gt;setLastInArgFI(LastFI) are called
when before and after above work. In ch9_1.cpp example, LowerFormalArguments()
will be called twice. First time is for sum_i() which will create 6 load DAG
for 6 incoming arguments passing into this function.
Second time is for main() which didn&#8217;t create any load DAG for no incoming
argument passing into main().
In addition to LowerFormalArguments() which create the load DAG, we need to
define the loadRegFromStackSlot() to issue the machine instruction
<strong>“ld $r, offset($sp)”</strong> to load incoming arguments from stack frame offset.
GetMemOperand(..., FI, ...) return the Memory location of the frame index
variable, which is the offset.</p>
<p class="rubric">lbdex/Chapter9_1/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="n">MachineMemOperand</span><span class="o">*</span> <span class="nf">GetMemOperand</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">Flag</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="o">*</span><span class="n">MBB</span><span class="p">.</span><span class="n">getParent</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">&amp;</span><span class="n">MFI</span> <span class="o">=</span> <span class="o">*</span><span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Align</span> <span class="o">=</span> <span class="n">MFI</span><span class="p">.</span><span class="n">getObjectAlignment</span><span class="p">(</span><span class="n">FI</span><span class="p">);</span>

  <span class="k">return</span> <span class="n">MF</span><span class="p">.</span><span class="n">getMachineMemOperand</span><span class="p">(</span><span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getFixedStack</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span> <span class="n">Flag</span><span class="p">,</span>
                                 <span class="n">MFI</span><span class="p">.</span><span class="n">getObjectSize</span><span class="p">(</span><span class="n">FI</span><span class="p">),</span> <span class="n">Align</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - GetMemOperand</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span> <span class="c1">// lbd document - mark - before loadRegFromStackSlot</span>
<span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                     <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                     <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">MMO</span> <span class="o">=</span> <span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">MachineMemOperand</span><span class="o">::</span><span class="n">MOLoad</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Register class not handled!&quot;</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">),</span> <span class="n">DestReg</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">)</span>
    <span class="p">.</span><span class="n">addMemOperand</span><span class="p">(</span><span class="n">MMO</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - loadRegFromStackSlot</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">virtual</span> <span class="kt">void</span> <span class="n">loadRegFromStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                  <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span><span class="p">,</span>
                                  <span class="kt">unsigned</span> <span class="n">DestReg</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                                  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>In addition to Calling Convention and LowerFormalArguments(), Chapter9_1/ add the
following code for Cpu0 instructions <strong>swi</strong> (Software Interrupt), <strong>jsub</strong> and
<strong>jalr</strong> (function call) definition and printing.</p>
<p class="rubric">lbdex/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def SDT_Cpu0JmpLink      : SDTypeProfile&lt;0, 1, [SDTCisVT&lt;0, iPTR&gt;]&gt;;
...
// Call
def Cpu0JmpLink : SDNode&lt;"Cpu0ISD::JmpLink",SDT_Cpu0JmpLink,
                         [SDNPHasChain, SDNPOutGlue, SDNPOptInGlue,
                          SDNPVariadic]&gt;;
...
def calltarget  : Operand&lt;iPTR&gt; {
  let EncoderMethod = "getJumpTargetOpValue";
}
...
// Jump and Link (Call)
let isCall=1, hasDelaySlot=0 in {
  class JumpLink&lt;bits&lt;8&gt; op, string instr_asm&gt;:
    FJ&lt;op, (outs), (ins calltarget:$target, variable_ops),
       !strconcat(instr_asm, "\t$target"), [(Cpu0JmpLink imm:$target)],
       IIBranch&gt; {
       }

  class JumpLinkReg&lt;bits&lt;8&gt; op, string instr_asm,
                    RegisterClass RC&gt;:
    FA&lt;op, (outs), (ins RC:$rb, variable_ops),
       !strconcat(instr_asm, "\t$rb"), [(Cpu0JmpLink RC:$rb)], IIBranch&gt; {
    let rc = 0;
    let ra = 14;
    let shamt = 0;
  }
}
...
/// Jump and Branch Instructions
def SWI  : JumpLink&lt;0x2a, "swi"&gt;;
def JSUB : JumpLink&lt;0x2b, "jsub"&gt;;
...
def JALR    : JumpLinkReg&lt;0x2e, "jalr", GPROut&gt;;
...
def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;
...</pre>
</div>
<p class="rubric">lbdex/Chapter9_1/InstPrinter/Cpu0InstPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">static</span> <span class="kt">void</span> <span class="nf">printExpr</span><span class="p">(</span><span class="k">const</span> <span class="n">MCExpr</span> <span class="o">*</span><span class="n">Expr</span><span class="p">,</span> <span class="n">raw_ostream</span> <span class="o">&amp;</span><span class="n">OS</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Kind</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span>:<span class="o">:</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="o">:</span>  <span class="n">OS</span> <span class="o">&lt;&lt;</span> <span class="s">&quot;%call16(&quot;</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                                              <span class="n">MachineOperandType</span> <span class="n">MOTy</span><span class="p">,</span>
                                              <span class="kt">unsigned</span> <span class="n">Offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">Cpu0II</span>:<span class="o">:</span><span class="n">MO_GOT_CALL</span><span class="o">:</span>  <span class="n">Kind</span> <span class="o">=</span> <span class="n">MCSymbolRefExpr</span><span class="o">::</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="p">;</span> <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ExternalSymbol</span><span class="o">:</span>
    <span class="n">Symbol</span> <span class="o">=</span> <span class="n">AsmPrinter</span><span class="p">.</span><span class="n">GetExternalSymbolSymbol</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">getSymbolName</span><span class="p">());</span>
    <span class="n">Offset</span> <span class="o">+=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getOffset</span><span class="p">();</span>
    <span class="k">break</span><span class="p">;</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="n">MCOperand</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerOperand</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineOperand</span><span class="o">&amp;</span> <span class="n">MO</span><span class="p">,</span>
                                        <span class="kt">unsigned</span> <span class="n">offset</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">MOTy</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_ExternalSymbol</span><span class="o">:</span>
  <span class="k">case</span> <span class="n">MachineOperand</span>:<span class="o">:</span><span class="n">MO_BlockAddress</span><span class="o">:</span>
    <span class="k">return</span> <span class="n">LowerSymbolOperand</span><span class="p">(</span><span class="n">MO</span><span class="p">,</span> <span class="n">MOTy</span><span class="p">,</span> <span class="n">offset</span><span class="p">);</span>
  <span class="p">...</span>
 <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/MCTargetDesc/Cpu0AsmBackend.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_CALL16</span><span class="o">:</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/MCTargetDesc/Cpu0ELFObjectWriter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">fixup_Cpu0_CALL16</span><span class="o">:</span>
  <span class="n">Type</span> <span class="o">=</span> <span class="n">ELF</span><span class="o">::</span><span class="n">R_CPU0_CALL16</span><span class="p">;</span>
  <span class="k">break</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/MCTargetDesc/Cpu0FixupKinds.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// resulting in - R_CPU0_CALL16.</span>
<span class="n">fixup_Cpu0_CALL16</span><span class="p">,</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/MCTargetDesc/Cpu0MCCodeEmitter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getJumpTargetOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">OpNo</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span> <span class="o">||</span> <span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JMP</span><span class="p">)</span>
    <span class="n">Fixups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                     <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_PC24</span><span class="p">)));</span>
  <span class="k">else</span> <span class="nf">if</span> <span class="p">(</span><span class="n">Opcode</span> <span class="o">==</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SWI</span><span class="p">)</span>
    <span class="n">Fixups</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MCFixup</span><span class="o">::</span><span class="n">Create</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="n">Expr</span><span class="p">,</span>
                                     <span class="n">MCFixupKind</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_24</span><span class="p">)));</span>
  <span class="p">...</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - getJumpTargetOpValue</span>
<span class="p">...</span>
<span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getMachineOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
<span class="p">...</span>
  <span class="k">switch</span><span class="p">(</span><span class="n">cast</span><span class="o">&lt;</span><span class="n">MCSymbolRefExpr</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Expr</span><span class="p">)</span><span class="o">-&gt;</span><span class="n">getKind</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span>:<span class="o">:</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="o">:</span>
    <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="p">}</span>
<span class="p">...</span>
<span class="p">}</span>

<span class="kt">unsigned</span> <span class="n">Cpu0MCCodeEmitter</span><span class="o">::</span>
<span class="n">getMachineOpValue</span><span class="p">(</span><span class="k">const</span> <span class="n">MCInst</span> <span class="o">&amp;</span><span class="n">MI</span><span class="p">,</span> <span class="k">const</span> <span class="n">MCOperand</span> <span class="o">&amp;</span><span class="n">MO</span><span class="p">,</span>
                  <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">MCFixup</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Fixups</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">MCSymbolRefExpr</span>:<span class="o">:</span><span class="n">VK_Cpu0_GOT_CALL</span><span class="o">:</span>
    <span class="n">FixupKind</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">fixup_Cpu0_CALL16</span><span class="p">;</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_1/Cpu0MachineFucntion.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0FunctionInfo</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionInfo</span> <span class="p">{</span>
  <span class="p">...</span>
    <span class="c1">/// VarArgsFrameIndex - FrameIndex for start of varargs area.</span>
  <span class="kt">int</span> <span class="n">VarArgsFrameIndex</span><span class="p">;</span>

  <span class="c1">// Range of frame object indices.</span>
  <span class="c1">// InArgFIRange: Range of indices of all frame objects created during call to</span>
  <span class="c1">//               LowerFormalArguments.</span>
  <span class="c1">// OutArgFIRange: Range of indices of all frame objects created during call to</span>
  <span class="c1">//                LowerCall except for the frame object for restoring $gp.</span>
  <span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">int</span><span class="o">&gt;</span> <span class="n">InArgFIRange</span><span class="p">,</span> <span class="n">OutArgFIRange</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="k">mutable</span> <span class="kt">int</span> <span class="n">DynAllocFI</span><span class="p">;</span> <span class="c1">// Frame index of dynamically allocated stack area.</span>
  <span class="p">...</span>

<span class="nl">public:</span>
  <span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
  <span class="o">:</span> <span class="p">...</span>
    <span class="n">VarArgsFrameIndex</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">InArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span>
    <span class="n">OutArgFIRange</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="o">-</span><span class="mi">1</span><span class="p">,</span> <span class="mi">0</span><span class="p">)),</span> <span class="n">GPFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DynAllocFI</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span>
    <span class="p">...</span>
    <span class="p">{}</span>

  <span class="kt">bool</span> <span class="n">isInArgFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">InArgFIRange</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">InArgFIRange</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setLastInArgFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">InArgFIRange</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>

  <span class="kt">void</span> <span class="n">extendOutArgFIRange</span><span class="p">(</span><span class="kt">int</span> <span class="n">FirstFI</span><span class="p">,</span> <span class="kt">int</span> <span class="n">LastFI</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">second</span><span class="p">)</span>
      <span class="c1">// this must be the first time this function was called.</span>
      <span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">first</span> <span class="o">=</span> <span class="n">FirstFI</span><span class="p">;</span>
    <span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">second</span> <span class="o">=</span> <span class="n">LastFI</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="kt">int</span> <span class="n">getGPFI</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setGPFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="p">{</span> <span class="n">GPFI</span> <span class="o">=</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">needGPSaveRestore</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">getGPFI</span><span class="p">();</span> <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isGPFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">GPFI</span> <span class="o">&amp;&amp;</span> <span class="n">GPFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>

  <span class="c1">// The first call to this function creates a frame object for dynamically</span>
  <span class="c1">// allocated stack area.</span>
  <span class="kt">int</span> <span class="n">getDynAllocFI</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">DynAllocFI</span><span class="p">)</span>
      <span class="n">DynAllocFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>

    <span class="k">return</span> <span class="n">DynAllocFI</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="kt">bool</span> <span class="n">isDynAllocFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">DynAllocFI</span> <span class="o">&amp;&amp;</span> <span class="n">DynAllocFI</span> <span class="o">==</span> <span class="n">FI</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
  <span class="kt">int</span> <span class="n">getVarArgsFrameIndex</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span> <span class="k">return</span> <span class="n">VarArgsFrameIndex</span><span class="p">;</span> <span class="p">}</span>
  <span class="kt">void</span> <span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="kt">int</span> <span class="n">Index</span><span class="p">)</span> <span class="p">{</span> <span class="n">VarArgsFrameIndex</span> <span class="o">=</span> <span class="n">Index</span><span class="p">;</span> <span class="p">}</span>
  <span class="p">...</span>
<span class="p">};</span>
</pre></div>
</div>
<p>The SWI, JSUB and JALR defined in Cpu0InstrInfo.td as above all use Cpu0JmpLink
node. They are distinguishable since both SWI and JSUB use &#8220;imm&#8221; operand while
JALR use register operand. JSUB take the priority to match since we set the
following code in Cpu0InstrInfo.td.</p>
<p class="rubric">lbdex/Chapter9_1/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def : Pat&lt;(Cpu0JmpLink (i32 tglobaladdr:$dst)),
          (JSUB tglobaladdr:$dst)&gt;;
def : Pat&lt;(Cpu0JmpLink (i32 texternalsym:$dst)),
          (JSUB texternalsym:$dst)&gt;;</pre>
</div>
<p>The code tells TableGen generate pattern match pattern to match the &#8220;imm&#8221; for
&#8220;tglobaladdr&#8221; pattern first. If it fails then try to match &#8220;texternalsym&#8221; next.
The function you declared is &#8220;tglobaladdr&#8221;, the function which implicit used by
llvm most are &#8220;texternalsym&#8221; such as &#8220;memcpy&#8221;. The &#8220;memcpy&#8221; will be generated
when define a long string. The ch9_1_2.cpp is an example to generate &#8220;memcpy&#8221;
function call. It will be shown in next section of Chapter9_2 example code.
Even though SWI have no chance to match in C/C++ language. We define it for easy
to implement assembly parser which introduced in Chapter 11. This
SWI definition will save us to implement the assembly parser for this
instruction. TableGen will generate information for SWI instruction in assembly
and ELF obj encode automatically. The Cpu0GenDAGISel.inc contains the TablGen
generated information about JSUB and JALR pattern match information as follows,</p>
<div class="highlight-c++"><div class="highlight"><pre>          <span class="cm">/*SwitchOpcode*/</span> <span class="mi">74</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">),</span><span class="c1">// -&gt;734</span>
<span class="cm">/*660*/</span>     <span class="n">OPC_RecordNode</span><span class="p">,</span>   <span class="c1">// #0 = &#39;Cpu0JmpLink&#39; chained node</span>
<span class="cm">/*661*/</span>     <span class="n">OPC_CaptureGlueInput</span><span class="p">,</span>
<span class="cm">/*662*/</span>     <span class="n">OPC_RecordChild1</span><span class="p">,</span> <span class="c1">// #1 = $target</span>
<span class="cm">/*663*/</span>     <span class="n">OPC_Scope</span><span class="p">,</span> <span class="mi">57</span><span class="p">,</span> <span class="cm">/*-&gt;722*/</span> <span class="c1">// 2 children in Scope</span>
<span class="cm">/*665*/</span>       <span class="n">OPC_MoveChild</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/*667*/</span>       <span class="n">OPC_SwitchOpcode</span> <span class="cm">/*3 cases */</span><span class="p">,</span> <span class="mi">22</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">Constant</span><span class="p">),</span>
<span class="c1">// -&gt;693</span>
<span class="cm">/*671*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*672*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*673*/</span>         <span class="n">OPC_EmitConvertToTarget</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
<span class="cm">/*675*/</span>         <span class="n">OPC_Scope</span><span class="p">,</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/*-&gt;684*/</span> <span class="c1">// 2 children in Scope</span>
<span class="cm">/*677*/</span>           <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SWI</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                      <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                  <span class="c1">// Src: (Cpu0JmpLink (imm:iPTR):$target) - Complexity = 6</span>
                  <span class="c1">// Dst: (SWI (imm:iPTR):$target)</span>
<span class="cm">/*684*/</span>         <span class="cm">/*Scope*/</span> <span class="mi">7</span><span class="p">,</span> <span class="cm">/*-&gt;692*/</span>
<span class="cm">/*685*/</span>           <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                      <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span>
                  <span class="c1">// Src: (Cpu0JmpLink (imm:iPTR):$target) - Complexity = 6</span>
                  <span class="c1">// Dst: (JSUB (imm:iPTR):$target)</span>
<span class="cm">/*692*/</span>         <span class="mi">0</span><span class="p">,</span> <span class="cm">/*End of Scope*/</span>
              <span class="cm">/*SwitchOpcode*/</span> <span class="mi">11</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetGlobalAddress</span><span class="p">),</span><span class="c1">// -&gt;707</span>
<span class="cm">/*696*/</span>         <span class="n">OPC_CheckType</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*698*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*699*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*700*/</span>         <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                    <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="c1">// Src: (Cpu0JmpLink (tglobaladdr:i32):$dst) - Complexity = 6</span>
                <span class="c1">// Dst: (JSUB (tglobaladdr:i32):$dst)</span>
              <span class="cm">/*SwitchOpcode*/</span> <span class="mi">11</span><span class="p">,</span>  <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TargetExternalSymbol</span><span class="p">),</span><span class="c1">// -&gt;721</span>
<span class="cm">/*710*/</span>         <span class="n">OPC_CheckType</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*712*/</span>         <span class="n">OPC_MoveParent</span><span class="p">,</span>
<span class="cm">/*713*/</span>         <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*714*/</span>         <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JSUB</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                    <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
                <span class="c1">// Src: (Cpu0JmpLink (texternalsym:i32):$dst) - Complexity = 6</span>
                <span class="c1">// Dst: (JSUB (texternalsym:i32):$dst)</span>
              <span class="mi">0</span><span class="p">,</span> <span class="c1">// EndSwitchOpcode</span>
<span class="cm">/*722*/</span>     <span class="cm">/*Scope*/</span> <span class="mi">10</span><span class="p">,</span> <span class="cm">/*-&gt;733*/</span>
<span class="cm">/*723*/</span>       <span class="n">OPC_CheckChild1Type</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>
<span class="cm">/*725*/</span>       <span class="n">OPC_EmitMergeInputChains1_0</span><span class="p">,</span>
<span class="cm">/*726*/</span>       <span class="n">OPC_MorphNodeTo</span><span class="p">,</span> <span class="n">TARGET_VAL</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">JALR</span><span class="p">),</span> <span class="mi">0</span><span class="o">|</span><span class="n">OPFL_Chain</span><span class="o">|</span>
<span class="n">OPFL_GlueInput</span><span class="o">|</span><span class="n">OPFL_GlueOutput</span><span class="o">|</span><span class="n">OPFL_Variadic1</span><span class="p">,</span>
                  <span class="mi">0</span><span class="cm">/*#VTs*/</span><span class="p">,</span> <span class="mi">1</span><span class="cm">/*#Ops*/</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span>
              <span class="c1">// Src: (Cpu0JmpLink CPURegs:i32:$rb) - Complexity = 3</span>
              <span class="c1">// Dst: (JALR CPURegs:i32:$rb)</span>
<span class="cm">/*733*/</span>     <span class="mi">0</span><span class="p">,</span> <span class="cm">/*End of Scope*/</span>
</pre></div>
</div>
<p>After above changes, you can run Chapter9_1/ with ch9_1.cpp and see what happens
in the following,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-79-83:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_1.bc -o ch9_1.cpu0.s
Assertion failed: <span class="o">((</span>CLI.IsTailCall <span class="o">||</span> InVals.size<span class="o">()</span> <span class="o">==</span> CLI.Ins.size<span class="o">())</span> <span class="o">&amp;&amp;</span>
<span class="s2">&quot;LowerCall didn&#39;t emit the correct number of values!&quot;</span><span class="o">)</span>, <span class="k">function </span>LowerCallTo,
file /Users/Jonathan/llvm/test/src/lib/CodeGen/SelectionDAG/SelectionDAGBuilder.
cpp, ...
...
0.  Program arguments: /Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.cpu0.s
1.  Running pass <span class="s1">&#39;Function Pass Manager&#39;</span> on module <span class="s1">&#39;ch9_1.bc&#39;</span>.
2.  Running pass <span class="s1">&#39;CPU0 DAG-&gt;DAG Pattern Instruction Selection&#39;</span> on <span class="k">function</span>
<span class="s1">&#39;@main&#39;</span>
Illegal instruction: 4
</pre></div>
</div>
<p>Now, the LowerFormalArguments() has the correct number, but LowerCall() has not
the correct number of values!</p>
</div>
<div class="section" id="store-outgoing-arguments-to-stack-frame">
<h2>Store outgoing arguments to stack frame<a class="headerlink" href="#store-outgoing-arguments-to-stack-frame" title="Permalink to this headline">¶</a></h2>
<p><a class="pageref" href="#funccall-f2">Figure  2</a> depicted two steps to take care arguments passing.
One is store outgoing arguments in caller function, and the other is load
incoming arguments in callee function.
We defined LowerFormalArguments() for <strong>“load incoming arguments”</strong> in callee
function last section.
Now, we will finish <strong>“store outgoing arguments”</strong> in caller function.
LowerCall() is responsible to do this. The implementation as follows,</p>
<p class="rubric">lbdex/Chapter9_2/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// lbd document - mark - before LowerCall</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span>                     <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">DAG</span><span class="p">;</span>
  <span class="n">SDLoc</span> <span class="n">DL</span>                              <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">DL</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span> <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Outs</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span>     <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">OutVals</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="p">,</span> <span class="mi">32</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span>   <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Ins</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">InChain</span>                       <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Chain</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">Callee</span>                        <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">Callee</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="o">&amp;</span><span class="n">isTailCall</span>                      <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">IsTailCall</span><span class="p">;</span>
  <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span>              <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">CallConv</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">isVarArg</span>                         <span class="o">=</span> <span class="n">CLI</span><span class="p">.</span><span class="n">IsVarArg</span><span class="p">;</span>
  <span class="c1">// Cpu0 target does not yet support tail call optimization.</span>
  <span class="n">isTailCall</span>                            <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>

  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getFrameInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="n">TargetFrameLowering</span> <span class="o">*</span><span class="n">TFL</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">();</span>
  <span class="kt">bool</span> <span class="n">IsPIC</span> <span class="o">=</span> <span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">==</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">;</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="c1">// Analyze operands of the call, assigning locations to each operand.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">ArgLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
                 <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">ArgLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeCallOperands</span><span class="p">(</span><span class="n">Outs</span><span class="p">,</span> <span class="n">CC_Cpu0</span><span class="p">);</span>

  <span class="c1">// Get a count of how many bytes are to be pushed on the stack.</span>
  <span class="kt">unsigned</span> <span class="n">NextStackOffset</span> <span class="o">=</span> <span class="n">CCInfo</span><span class="p">.</span><span class="n">getNextStackOffset</span><span class="p">();</span>

  <span class="c1">// If this is the first call, create a stack frame object that points to</span>
  <span class="c1">// a location to which .cprestore saves $gp.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPIC</span> <span class="o">&amp;&amp;</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">())</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setGPFI</span><span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="mi">4</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">));</span>
  <span class="c1">// Get the frame index of the stack frame object that points to the location</span>
  <span class="c1">// of dynamically allocated area on the stack.</span>
  <span class="kt">int</span> <span class="n">DynAllocFI</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getDynAllocFI</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">MaxCallFrameSize</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getMaxCallFrameSize</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">MaxCallFrameSize</span> <span class="o">&lt;</span> <span class="n">NextStackOffset</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setMaxCallFrameSize</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">);</span>

    <span class="c1">// Set the offsets relative to $sp of the $gp restore slot and dynamically</span>
    <span class="c1">// allocated stack space. These offsets must be aligned to a boundary</span>
    <span class="c1">// determined by the stack alignment of the ABI.</span>
    <span class="kt">unsigned</span> <span class="n">StackAlignment</span> <span class="o">=</span> <span class="n">TFL</span><span class="o">-&gt;</span><span class="n">getStackAlignment</span><span class="p">();</span>
    <span class="n">NextStackOffset</span> <span class="o">=</span> <span class="p">(</span><span class="n">NextStackOffset</span> <span class="o">+</span> <span class="n">StackAlignment</span> <span class="o">-</span> <span class="mi">1</span><span class="p">)</span> <span class="o">/</span>
                      <span class="n">StackAlignment</span> <span class="o">*</span> <span class="n">StackAlignment</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>    <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setObjectOffset</span><span class="p">(</span><span class="n">DynAllocFI</span><span class="p">,</span> <span class="n">NextStackOffset</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="c1">// Chain is the output chain of the last Load/Store or CopyToReg node.</span>
  <span class="c1">// ByValChain is the output chain of the last Memcpy node created for copying</span>
  <span class="c1">// byval arguments to the stack.</span>
  <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">CallSeqStart</span><span class="p">,</span> <span class="n">ByValChain</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">NextStackOffsetVal</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">CallSeqStart</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_START</span><span class="p">(</span><span class="n">InChain</span><span class="p">,</span> <span class="n">NextStackOffsetVal</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>
  <span class="n">ByValChain</span> <span class="o">=</span> <span class="n">InChain</span><span class="p">;</span>

  <span class="c1">// With EABI is it possible to have 16 args on registers.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RegsToPass</span><span class="p">;</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">MemOpChains</span><span class="p">;</span>

  <span class="kt">int</span> <span class="n">FirstFI</span> <span class="o">=</span> <span class="o">-</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getNumFixedObjects</span><span class="p">()</span> <span class="o">-</span> <span class="mi">1</span><span class="p">,</span> <span class="n">LastFI</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="c1">// Walk the register/memloc assignments, inserting copies/loads.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">SDValue</span> <span class="n">Arg</span> <span class="o">=</span> <span class="n">OutVals</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">[</span><span class="n">i</span><span class="p">];</span>
    <span class="n">MVT</span> <span class="n">ValVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">LocVT</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocVT</span><span class="p">();</span>
    <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span> <span class="n">Flags</span> <span class="o">=</span> <span class="n">Outs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">Flags</span><span class="p">;</span>

    <span class="c1">// ByVal Arg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="s">&quot;!!!Error!!!, Flags.isByVal()==true&quot;</span><span class="p">);</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
             <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Promote the value if needed.</span>
    <span class="k">switch</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocInfo</span><span class="p">())</span> <span class="p">{</span>
    <span class="nl">default:</span> <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;Unknown loc info!&quot;</span><span class="p">);</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">Full</span><span class="o">:</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">SExt</span><span class="o">:</span>
      <span class="n">Arg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">SIGN_EXTEND</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">Arg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">ZExt</span><span class="o">:</span>
      <span class="n">Arg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ZERO_EXTEND</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">Arg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="k">case</span> <span class="n">CCValAssign</span>:<span class="o">:</span><span class="n">AExt</span><span class="o">:</span>
      <span class="n">Arg</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ANY_EXTEND</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">LocVT</span><span class="p">,</span> <span class="n">Arg</span><span class="p">);</span>
      <span class="k">break</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="c1">// Arguments that can be passed on register must be kept at</span>
    <span class="c1">// RegsToPass vector</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isRegLoc</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">RegsToPass</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">make_pair</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">getLocReg</span><span class="p">(),</span> <span class="n">Arg</span><span class="p">));</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="c1">// Register can&#39;t get to this point...</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">VA</span><span class="p">.</span><span class="n">isMemLoc</span><span class="p">());</span>

    <span class="c1">// Create the frame index object for this incoming parameter</span>
    <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">ValVT</span><span class="p">.</span><span class="n">getSizeInBits</span><span class="p">()</span><span class="o">/</span><span class="mi">8</span><span class="p">,</span>
                                    <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">PtrOff</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>

    <span class="c1">// emit ISD::STORE whichs stores the</span>
    <span class="c1">// parameter value to a stack Location</span>
    <span class="n">MemOpChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">PtrOff</span><span class="p">,</span>
                                       <span class="n">MachinePointerInfo</span><span class="p">(),</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="c1">// Extend range of indices of frame objects for outgoing arguments that were</span>
  <span class="c1">// created during this function call. Skip this step if no such objects were</span>
  <span class="c1">// created.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">LastFI</span><span class="p">)</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">extendOutArgFIRange</span><span class="p">(</span><span class="n">FirstFI</span><span class="p">,</span> <span class="n">LastFI</span><span class="p">);</span>

  <span class="c1">// If a memcpy has been created to copy a byval arg to a stack, replace the</span>
  <span class="c1">// chain input of CallSeqStart with ByValChain.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">InChain</span> <span class="o">!=</span> <span class="n">ByValChain</span><span class="p">)</span>
    <span class="n">DAG</span><span class="p">.</span><span class="n">UpdateNodeOperands</span><span class="p">(</span><span class="n">CallSeqStart</span><span class="p">.</span><span class="n">getNode</span><span class="p">(),</span> <span class="n">ByValChain</span><span class="p">,</span>
                           <span class="n">NextStackOffsetVal</span><span class="p">);</span>

  <span class="c1">// Transform all store nodes into one single node because all store</span>
  <span class="c1">// nodes are independent of each other.</span>
  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">MemOpChains</span><span class="p">.</span><span class="n">empty</span><span class="p">())</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span>
                        <span class="o">&amp;</span><span class="n">MemOpChains</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">MemOpChains</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>

  <span class="c1">// If the callee is a GlobalAddress/ExternalSymbol node (quite common, every</span>
  <span class="c1">// direct call is) turn it into a TargetGlobalAddress/TargetExternalSymbol</span>
  <span class="c1">// node so that legalize doesn&#39;t hack it.</span>
  <span class="kt">unsigned</span> <span class="kt">char</span> <span class="n">OpFlag</span><span class="p">;</span>
  <span class="kt">bool</span> <span class="n">IsPICCall</span> <span class="o">=</span> <span class="n">IsPIC</span><span class="p">;</span> <span class="c1">// true if calls are translated to jalr $25</span>
  <span class="kt">bool</span> <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="n">SDValue</span> <span class="n">CalleeLo</span><span class="p">;</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">GlobalAddressSDNode</span> <span class="o">*</span><span class="n">G</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">GlobalAddressSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Callee</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">OpFlag</span> <span class="o">=</span> <span class="n">IsPICCall</span> <span class="o">?</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_CALL</span> <span class="o">:</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_NO_FLAG</span><span class="p">;</span>
    <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetGlobalAddress</span><span class="p">(</span><span class="n">G</span><span class="o">-&gt;</span><span class="n">getGlobal</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span>
                                          <span class="n">getPointerTy</span><span class="p">(),</span> <span class="mi">0</span><span class="p">,</span> <span class="n">OpFlag</span><span class="p">);</span>
    <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="k">else</span> <span class="k">if</span> <span class="p">(</span><span class="n">ExternalSymbolSDNode</span> <span class="o">*</span><span class="n">S</span> <span class="o">=</span> <span class="n">dyn_cast</span><span class="o">&lt;</span><span class="n">ExternalSymbolSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Callee</span><span class="p">))</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">IsPIC</span><span class="p">)</span> <span class="c1">// static</span>
      <span class="n">OpFlag</span> <span class="o">=</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_NO_FLAG</span><span class="p">;</span>
    <span class="k">else</span> <span class="c1">// O32 &amp; PIC</span>
      <span class="n">OpFlag</span> <span class="o">=</span> <span class="n">Cpu0II</span><span class="o">::</span><span class="n">MO_GOT_CALL</span><span class="p">;</span>
    <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getTargetExternalSymbol</span><span class="p">(</span><span class="n">S</span><span class="o">-&gt;</span><span class="n">getSymbol</span><span class="p">(),</span> <span class="n">getPointerTy</span><span class="p">(),</span>
                                         <span class="n">OpFlag</span><span class="p">);</span>
    <span class="n">GlobalOrExternal</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
  <span class="p">}</span>

  <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">;</span>

  <span class="c1">// Create nodes that load address of callee and copy it to T9</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">GlobalOrExternal</span><span class="p">)</span> <span class="p">{</span>
      <span class="c1">// Load callee address</span>
      <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Wrapper</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span>
                           <span class="n">getGlobalReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">()),</span> <span class="n">Callee</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">LoadValue</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getLoad</span><span class="p">(</span><span class="n">getPointerTy</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span>
                                      <span class="n">Callee</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="o">::</span><span class="n">getGOT</span><span class="p">(),</span>
                                      <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>

      <span class="c1">// Use GOT+LO if callee has internal linkage.</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">CalleeLo</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span> <span class="p">{</span>
        <span class="n">SDValue</span> <span class="n">Lo</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">Lo</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span> <span class="n">CalleeLo</span><span class="p">);</span>
        <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span> <span class="n">LoadValue</span><span class="p">,</span> <span class="n">Lo</span><span class="p">);</span>
      <span class="p">}</span> <span class="k">else</span>
        <span class="n">Callee</span> <span class="o">=</span> <span class="n">LoadValue</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="c1">// T9 should contain the address of the callee function if</span>
  <span class="c1">// -reloction-model=pic or it is an indirect call.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPICCall</span> <span class="o">||</span> <span class="o">!</span><span class="n">GlobalOrExternal</span><span class="p">)</span> <span class="p">{</span>
    <span class="c1">// copy to T9</span>
    <span class="kt">unsigned</span> <span class="n">T9Reg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">T9</span><span class="p">;</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">T9Reg</span><span class="p">,</span> <span class="n">Callee</span><span class="p">,</span> <span class="n">SDValue</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="mi">0</span><span class="p">));</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">Callee</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">T9Reg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>
  <span class="p">}</span>

  <span class="c1">// Cpu0JmpLink = #chain, #target_address, #opt_in_flags...</span>
  <span class="c1">//             = Chain, Callee, Reg#1, Reg#2, ...</span>
  <span class="c1">//</span>
  <span class="c1">// Returns a chain &amp; a flag for retval copy to use.</span>
  <span class="n">SDVTList</span> <span class="n">NodeTys</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getVTList</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Glue</span><span class="p">);</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;</span> <span class="n">Ops</span><span class="p">;</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">);</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Callee</span><span class="p">);</span>

  <span class="c1">// Add argument registers to the end of the list so that they are</span>
  <span class="c1">// known live into the call.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">RegsToPass</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">first</span><span class="p">,</span>
                                  <span class="n">RegsToPass</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">second</span><span class="p">.</span><span class="n">getValueType</span><span class="p">()));</span>

  <span class="c1">// Add a register mask operand representing the call-preserved registers.</span>
  <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span> <span class="o">=</span> <span class="n">getTargetMachine</span><span class="p">().</span><span class="n">getRegisterInfo</span><span class="p">();</span>
  <span class="k">const</span> <span class="kt">uint32_t</span> <span class="o">*</span><span class="n">Mask</span> <span class="o">=</span> <span class="n">TRI</span><span class="o">-&gt;</span><span class="n">getCallPreservedMask</span><span class="p">(</span><span class="n">CallConv</span><span class="p">);</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Mask</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Missing call preserved mask for calling convention&quot;</span><span class="p">);</span>
  <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegisterMask</span><span class="p">(</span><span class="n">Mask</span><span class="p">));</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">InFlag</span><span class="p">.</span><span class="n">getNode</span><span class="p">())</span>
    <span class="n">Ops</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">InFlag</span><span class="p">);</span>

  <span class="n">Chain</span>  <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">Cpu0ISD</span><span class="o">::</span><span class="n">JmpLink</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">NodeTys</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Ops</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Ops</span><span class="p">.</span><span class="n">size</span><span class="p">());</span>
  <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Create the CALLSEQ_END node.</span>
  <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCALLSEQ_END</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span>
                             <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="n">NextStackOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span>
                             <span class="n">DAG</span><span class="p">.</span><span class="n">getIntPtrConstant</span><span class="p">(</span><span class="mi">0</span><span class="p">,</span> <span class="nb">true</span><span class="p">),</span> <span class="n">InFlag</span><span class="p">,</span> <span class="n">DL</span><span class="p">);</span>
  <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>

  <span class="c1">// Handle result values, copying them out of physregs into vregs that we</span>
  <span class="c1">// return.</span>
  <span class="k">return</span> <span class="nf">LowerCallResult</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">InFlag</span><span class="p">,</span> <span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span>
                         <span class="n">Ins</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">InVals</span><span class="p">);</span>
<span class="p">}</span>

<span class="c1">/// LowerCallResult - Lower the result values of a call into the</span>
<span class="c1">/// appropriate copies out of appropriate physical registers.</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                                    <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                                    <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                                    <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                                    <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Assign locations to each value returned by this call.</span>
  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">CCValAssign</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;</span> <span class="n">RVLocs</span><span class="p">;</span>
  <span class="n">CCState</span> <span class="nf">CCInfo</span><span class="p">(</span><span class="n">CallConv</span><span class="p">,</span> <span class="n">isVarArg</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">(),</span>
		 <span class="n">getTargetMachine</span><span class="p">(),</span> <span class="n">RVLocs</span><span class="p">,</span> <span class="o">*</span><span class="n">DAG</span><span class="p">.</span><span class="n">getContext</span><span class="p">());</span>

  <span class="n">CCInfo</span><span class="p">.</span><span class="n">AnalyzeCallResult</span><span class="p">(</span><span class="n">Ins</span><span class="p">,</span> <span class="n">RetCC_Cpu0</span><span class="p">);</span>

  <span class="c1">// Copy all of the result registers out of their specified physreg.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">RVLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getLocReg</span><span class="p">(),</span>
                               <span class="n">RVLocs</span><span class="p">[</span><span class="n">i</span><span class="p">].</span><span class="n">getValVT</span><span class="p">(),</span> <span class="n">InFlag</span><span class="p">).</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">InFlag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Chain</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_2/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre>    
    <span class="c1">// Lower Operand helpers</span>
    <span class="n">SDValue</span> <span class="n">LowerCallResult</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">InFlag</span><span class="p">,</span>
                            <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                            <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                            <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                            <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p>Just like load incoming arguments from stack frame, we call
CCInfo(CallConv,..., ArgLocs, ...) to get outgoing arguments information before
enter <strong>“for loop”</strong> and set stack alignment with 8 bytes.
They&#8217;re almost same in <strong>“for loop”</strong> with LowerFormalArguments(), except
LowerCall() create store DAG vector instead of load DAG vector.
After the <strong>“for loop”</strong>, it create <strong>“ld $t9, %call16(_Z5sum_iiiiiii)($gp)”</strong>
and jalr $t9 for calling subroutine (the $6 is $t9) in PIC mode.
DAG.getCALLSEQ_START() and DAG.getCALLSEQ_END() are set before the
<strong>“for loop”</strong> and after call subroutine, they insert CALLSEQ_START,
CALLSEQ_END, and translate into pseudo machine instructions !ADJCALLSTACKDOWN,
!ADJCALLSTACKUP later according Cpu0InstrInfo.td definition as follows.</p>
<p class="rubric">lbdex/Chapter9_2/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>def SDT_Cpu0CallSeqStart : SDCallSeqStart&lt;[SDTCisVT&lt;0, i32&gt;]&gt;;
def SDT_Cpu0CallSeqEnd   : SDCallSeqEnd&lt;[SDTCisVT&lt;0, i32&gt;, SDTCisVT&lt;1, i32&gt;]&gt;;
...
// These are target-independent nodes, but have target-specific formats.
def callseq_start : SDNode&lt;"ISD::CALLSEQ_START", SDT_Cpu0CallSeqStart,
                           [SDNPHasChain, SDNPOutGlue]&gt;;
def callseq_end   : SDNode&lt;"ISD::CALLSEQ_END", SDT_Cpu0CallSeqEnd,
                           [SDNPHasChain, SDNPOptInGlue, SDNPOutGlue]&gt;;
...
//===----------------------------------------------------------------------===//
// Pseudo instructions
//===----------------------------------------------------------------------===//

// As stack alignment is always done with addiu, we need a 16-bit immediate
let Defs = [SP], Uses = [SP] in {
def ADJCALLSTACKDOWN : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt),
                                  "!ADJCALLSTACKDOWN $amt",
                                  [(callseq_start timm:$amt)]&gt;;
def ADJCALLSTACKUP   : Cpu0Pseudo&lt;(outs), (ins uimm16:$amt1, uimm16:$amt2),
                                  "!ADJCALLSTACKUP $amt1",
                                  [(callseq_end timm:$amt1, timm:$amt2)]&gt;;
}</pre>
</div>
<p>Like load incoming arguments, we need to implement storeRegToStackSlot() for
store outgoing arguments to stack frame offset.</p>
<p class="rubric">lbdex/Chapter9_2/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//- st SrcReg, MMO(FI)</span>
<span class="kt">void</span> <span class="n">Cpu0InstrInfo</span><span class="o">::</span>
<span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">,</span>
                    <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FI</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">DebugLoc</span> <span class="n">DL</span><span class="p">;</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">())</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
  <span class="n">MachineMemOperand</span> <span class="o">*</span><span class="n">MMO</span> <span class="o">=</span> <span class="n">GetMemOperand</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">MachineMemOperand</span><span class="o">::</span><span class="n">MOStore</span><span class="p">);</span>

  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>

  <span class="n">Opc</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ST</span><span class="p">;</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">Opc</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Register class not handled!&quot;</span><span class="p">);</span>
  <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">get</span><span class="p">(</span><span class="n">Opc</span><span class="p">)).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SrcReg</span><span class="p">,</span> <span class="n">getKillRegState</span><span class="p">(</span><span class="n">isKill</span><span class="p">))</span>
    <span class="p">.</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">).</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">).</span><span class="n">addMemOperand</span><span class="p">(</span><span class="n">MMO</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - storeRegToStackSlot</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_2/Cpu0InstrInfo.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="k">virtual</span> <span class="kt">void</span> <span class="n">storeRegToStackSlot</span><span class="p">(</span><span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                   <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MBBI</span><span class="p">,</span>
                                   <span class="kt">unsigned</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isKill</span><span class="p">,</span> <span class="kt">int</span> <span class="n">FrameIndex</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">,</span>
                                   <span class="k">const</span> <span class="n">TargetRegisterInfo</span> <span class="o">*</span><span class="n">TRI</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.cpu0.s
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
      .section .mdebug.abi32
      .previous
      .file   <span class="s2">&quot;ch9_1.bc&quot;</span>
      .text
      .globl  _Z5sum_iiiiiii
      .align  2
      .type   _Z5sum_iiiiiii,@function
      .ent    _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
      .cfi_startproc
      .frame  <span class="nv">$sp</span>,32,<span class="nv">$lr</span>
      .mask   0x00000000,0
      .set    noreorder
      .cpload <span class="nv">$t9</span>
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
      .cfi_def_cfa_offset 32
      ld      <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, %got_hi<span class="o">(</span>gI<span class="o">)</span>
      shl     <span class="nv">$3</span>, <span class="nv">$3</span>, 16
      addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$gp</span>
      ld      <span class="nv">$3</span>, %got_lo<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$3</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
      ld      <span class="nv">$4</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
      ld      <span class="nv">$4</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
      ld      <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
      ld      <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
      ld      <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addu    <span class="nv">$3</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
      addu    <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>
      st      <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 32
      ret     <span class="nv">$lr</span>
      .set    macro
      .set    reorder
      .end    _Z5sum_iiiiiii
<span class="nv">$tmp2</span>:
      .size   _Z5sum_iiiiiii, <span class="o">(</span><span class="nv">$tmp2</span><span class="o">)</span>-_Z5sum_iiiiiii
      .cfi_endproc

      .globl  main
      .align  2
      .type   main,@function
      .ent    main                    <span class="c"># @main</span>
main:
      .cfi_startproc
      .frame  <span class="nv">$sp</span>,40,<span class="nv">$lr</span>
      .mask   0x00004000,-4
      .set    noreorder
      .cpload <span class="nv">$t9</span>
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp5</span>:
      .cfi_def_cfa_offset 40
      st      <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp6</span>:
      .cfi_offset 14, -4
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
      st      <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      !ADJCALLSTACKDOWN 24
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
      st      <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
      st      <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
      st      <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
      st      <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
      st      <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
      st      <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      jalr    <span class="nv">$t9</span>
      !ADJCALLSTACKUP 24
      st      <span class="nv">$2</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$lr</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
      ret     <span class="nv">$lr</span>
      .set    macro
      .set    reorder
      .end    main
<span class="nv">$tmp7</span>:
      .size   main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
      .cfi_endproc

      .type   gI,@object              <span class="c"># @gI</span>
      .data
      .globl  gI
      .align  2
gI:
      .4byte  100                     <span class="c"># 0x64</span>
      .size   gI, 4
</pre></div>
</div>
<p>The last section mentioned the &#8220;JSUB texternalsym&#8221; pattern. Run Chapter9_2 with
ch9_1_2.cpp to get the result as below. For long string, llvm call memcpy() to
initialize string (char str[81] = &#8220;Hello world&#8221; in this case). For short string,
the &#8220;call memcpy&#8221; is translated into &#8220;store with contant&#8221; in stages of
optimization.</p>
<p class="rubric">lbdex/InputFiles/ch9_1_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">char</span> <span class="n">str</span><span class="p">[</span><span class="mi">81</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello world&quot;</span><span class="p">;</span>
  <span class="kt">char</span> <span class="n">s</span><span class="p">[</span><span class="mi">6</span><span class="p">]</span> <span class="o">=</span> <span class="s">&quot;Hello&quot;</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>llvm-dis ch9_1_2.bc -o -
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch9_1_2.bc&#39;</span>
...
@_ZZ4mainE3str <span class="o">=</span> private unnamed_addr constant <span class="o">[</span>81 x i8<span class="o">]</span> c<span class="s2">&quot;Hello world\00\00\00\</span>
<span class="s2">00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00</span>
<span class="s2">\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\00\0</span>
<span class="s2">0\00\00\00\00\00\00\00\00\00\00\00\00\00&quot;</span>, align 1
@_ZZ4mainE1s <span class="o">=</span> private unnamed_addr constant <span class="o">[</span>6 x i8<span class="o">]</span> c<span class="s2">&quot;Hello\00&quot;</span>, align 1

; Function Attrs: nounwind
define i32 @main<span class="o">()</span> <span class="c">#0 {</span>
entry:
  %retval <span class="o">=</span> alloca i32, align 4
  %str <span class="o">=</span> alloca <span class="o">[</span>81 x i8<span class="o">]</span>, align 1
  store i32 0, i32* %retval
  %0 <span class="o">=</span> bitcast <span class="o">[</span>81 x i8<span class="o">]</span>* %str to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32<span class="o">(</span>i8* %0, i8* getelementptr inbounds
  <span class="o">([</span>81 x i8<span class="o">]</span>* @_ZZ4mainE3str, i32 0, i32 0<span class="o">)</span>, i32 81, i32 1, i1 <span class="nb">false</span><span class="o">)</span>
  %1 <span class="o">=</span> bitcast <span class="o">[</span>6 x i8<span class="o">]</span>* %s to i8*
  call void @llvm.memcpy.p0i8.p0i8.i32<span class="o">(</span>i8* %1, i8* getelementptr inbounds
  <span class="o">([</span>6 x i8<span class="o">]</span>* @_ZZ4mainE1s, i32 0, i32 0<span class="o">)</span>, i32 6, i32 1, i1 <span class="nb">false</span><span class="o">)</span>

  ret i32 0
<span class="o">}</span>

JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_1_2.cpp -emit-llvm -o ch9_1_2.bc
JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build
/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch9_1_2.bc -o -
  .section .mdebug.abi32
  ...
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 81
  st  <span class="nv">$2</span>, 128<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span><span class="nv">$_ZZ4mainE3str</span><span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span><span class="nv">$_ZZ4mainE3str</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 124<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$fp</span>, 28
  st  <span class="nv">$2</span>, 120<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  jsub  memcpy
  !ADJCALLSTACKUP 16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 28416  // <span class="nv">28416</span><span class="o">=</span><span class="nv">0x6f00</span><span class="o">=</span><span class="s2">&quot;o\0&quot;</span>
  sh  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 18533  // <span class="nv">18533</span><span class="o">=</span><span class="nv">0x4865</span><span class="o">=</span><span class="s2">&quot;He&quot;</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  ori <span class="nv">$2</span>, <span class="nv">$2</span>, 27756         // <span class="nv">27756</span><span class="o">=</span><span class="nv">0x6c6c</span><span class="o">=</span><span class="s2">&quot;ll&quot;</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
  ...
  .type <span class="nv">$_ZZ4mainE3str</span>,@object  <span class="c"># @_ZZ4mainE3str</span>
  .section  .rodata,<span class="s2">&quot;a&quot;</span>,@progbits
<span class="nv">$_ZZ4mainE3str</span>:
  .asciz   <span class="s2">&quot;Hello world\000\000\000\000\000\000\000\000\000\000\000\000\000\000</span>
<span class="s2">  \000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\</span>
<span class="s2">  000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\0</span>
<span class="s2">  00\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000\000&quot;</span>
  .size <span class="nv">$_ZZ4mainE3str</span>, 81
</pre></div>
</div>
<p>The &#8220;call memcpy&#8221; for short string is optimized by llvm before &#8220;DAG-&gt;DAG Pattern
Instruction Selection&#8221; stage and translate it into &#8220;store with contant&#8221; as
follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build
/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch9_1_2.bc
-debug -o -

Initial selection DAG: BB#0 <span class="s1">&#39;main:entry&#39;</span>
SelectionDAG has 35 nodes:
  ...
        0x7fd909030810: &lt;multiple use&gt;
        0x7fd909030c10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;1214606444&gt;  // <span class="nv">1214606444</span><span class="o">=</span><span class="nv">0x48656c6c</span><span class="o">=</span><span class="s2">&quot;Hell&quot;</span>

        0x7fd909030910: &lt;multiple use&gt;
        0x7fd90902d810: &lt;multiple use&gt;
      0x7fd909030d10: <span class="nv">ch</span> <span class="o">=</span> store 0x7fd909030810, 0x7fd909030c10, 0x7fd909030910,
      0x7fd90902d810&lt;ST4<span class="o">[</span>%1<span class="o">]</span>&gt;

        0x7fd909030810: &lt;multiple use&gt;
        0x7fd909030e10: <span class="nv">i16</span> <span class="o">=</span> Constant&lt;28416&gt;      // <span class="nv">28416</span><span class="o">=</span><span class="nv">0x6f00</span><span class="o">=</span><span class="s2">&quot;o\0&quot;</span>

        ...

        0x7fd90902d810: &lt;multiple use&gt;
      0x7fd909031210: <span class="nv">ch</span> <span class="o">=</span> store 0x7fd909030810, 0x7fd909030e10, 0x7fd909031010,
      0x7fd90902d810&lt;ST2<span class="o">[</span>%1+4<span class="o">](</span><span class="nv">align</span><span class="o">=</span>4<span class="o">)</span>&gt;
  ...
</pre></div>
</div>
<p>The &#8220;isTailCall = false;&#8221; set in LowerCall() of Cpu0ISelLowering.cpp meaning Cpu0
don&#8217;t support tail call optimization at this moment. About tail call
optimization please reference <a class="footnote-reference" href="#id15" id="id6">[6]</a>.</p>
</div>
<div class="section" id="fix-issues">
<h2>Fix issues<a class="headerlink" href="#fix-issues" title="Permalink to this headline">¶</a></h2>
<p>Run Chapter9_2/ with ch7_5.cpp to get the incorrect main return (return register
$2 is not 0) as follows,</p>
<p class="rubric">lbdex/InputFiles/ch7_5.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">struct</span> <span class="n">Date</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
<span class="p">};</span>

<span class="n">Date</span> <span class="n">date</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
<span class="kt">int</span> <span class="n">a</span><span class="p">[</span><span class="mi">3</span><span class="p">]</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>

<span class="kt">int</span> <span class="nf">test_struct</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">day</span> <span class="o">=</span> <span class="n">date</span><span class="p">.</span><span class="n">day</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="n">a</span><span class="p">[</span><span class="mi">1</span><span class="p">];</span>

  <span class="k">return</span> <span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="n">day</span><span class="p">);</span> <span class="c1">// 10+12=22</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-31:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch7_5.cpp -emit-llvm -o ch7_5.bc
118-165-78-31:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>asm ch7_5.bc -o
ch7_5.cpu0.static.s
118-165-78-31:InputFiles Jonathan<span class="nv">$ </span>cat ch7_5.cpu0.static.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch7_5.bc&quot;</span>
  ...
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,16,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -16
<span class="nv">$tmp1</span>:
  .cfi_def_cfa_offset 16
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>date<span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>date<span class="o">)</span>
  ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, %hi<span class="o">(</span>a<span class="o">)</span>
  shl <span class="nv">$2</span>, <span class="nv">$2</span>, 16
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span>a<span class="o">)</span>
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 16
  ret <span class="nv">$lr</span>
  .set  macro
...
</pre></div>
</div>
<p>Summary the issues for the code generated as above and in last section as follows:</p>
<ol class="arabic simple">
<li>It store the arguments to wrong offset.</li>
<li>!ADJCALLSTACKUP and !ADJCALLSTACKDOWN.</li>
<li>The $gp is caller saved register. The caller main() didn&#8217;t save $gp will has
bug if the callee sum_i() has changed $gp. Programmer can change $gp with
assembly code in sum_i().</li>
<li>Return value of main().</li>
</ol>
<p>Solve these issues in each sub-section.</p>
<div class="section" id="fix-the-wrong-offset-in-storing-arguments-to-stack-frame">
<h3>Fix the wrong offset in storing arguments to stack frame<a class="headerlink" href="#fix-the-wrong-offset-in-storing-arguments-to-stack-frame" title="Permalink to this headline">¶</a></h3>
<p>To fix the wrong offset in storing arguments, we modify the following code
in eliminateFrameIndex() as follows.
The code as below is modified in Chapter9_3/ to set the caller outgoing
arguments into spOffset($sp) (Chapter9_2/ set them to pOffset+stackSize($sp).</p>
<p class="rubric">lbdex/Chapter9_3/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">eliminateFrameIndex</span><span class="p">(</span><span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">II</span><span class="p">,</span> <span class="kt">int</span> <span class="n">SPAdj</span><span class="p">,</span>
                    <span class="n">RegScavenger</span> <span class="o">*</span><span class="n">RS</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="n">FrameIndex</span> <span class="o">&gt;=</span> <span class="n">MinCSFI</span> <span class="o">&amp;&amp;</span> <span class="n">FrameIndex</span> <span class="o">&lt;=</span> <span class="n">MaxCSFI</span><span class="p">))</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">FrameReg</span> <span class="o">=</span> <span class="n">getFrameRegister</span><span class="p">(</span><span class="n">MF</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="c1">// Calculate final offset.</span>
  <span class="c1">// - There is no need to change the offset if the frame object is one of the</span>
  <span class="c1">//   following: an outgoing argument, pointer to a dynamically allocated</span>
  <span class="c1">//   stack space or a $gp restore location,</span>
  <span class="c1">// - If the frame object is any of the following, its offset must be adjusted</span>
  <span class="c1">//   by adding the size of the stack:</span>
  <span class="c1">//   incoming argument, callee-saved register location or local variable.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isOutArgFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isGPFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">)</span> <span class="o">||</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">isDynAllocFI</span><span class="p">(</span><span class="n">FrameIndex</span><span class="p">))</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span><span class="p">;</span>
  <span class="k">else</span>
    <span class="n">Offset</span> <span class="o">=</span> <span class="n">spOffset</span> <span class="o">+</span> <span class="p">(</span><span class="kt">int64_t</span><span class="p">)</span><span class="n">stackSize</span><span class="p">;</span>
  <span class="n">Offset</span>    <span class="o">+=</span> <span class="n">MI</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="n">i</span><span class="o">+</span><span class="mi">1</span><span class="p">).</span><span class="n">getImm</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0MachineFunction.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="n">Cpu0FunctionInfo</span><span class="p">(</span><span class="n">MachineFunction</span><span class="o">&amp;</span> <span class="n">MF</span><span class="p">)</span>
<span class="o">:</span>
<span class="p">...</span>
<span class="kt">bool</span> <span class="n">isOutArgFI</span><span class="p">(</span><span class="kt">int</span> <span class="n">FI</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="k">return</span> <span class="n">FI</span> <span class="o">&lt;=</span> <span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">first</span> <span class="o">&amp;&amp;</span> <span class="n">FI</span> <span class="o">&gt;=</span> <span class="n">OutArgFIRange</span><span class="p">.</span><span class="n">second</span><span class="p">;</span>
<span class="p">}</span>
<span class="p">...</span>
</pre></div>
</div>
<p>Run Chapter9_3/ with ch9_1.cpp will get the following result.
It correct arguements offset im main() from (0+40)$sp, (8+40)$sp, ..., to
(0)$sp, (8)$sp, ..., where the stack size is 40 in main().</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_1.bc -o
ch9_1.cpu0.s
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
  ...
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             // Correct offset
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ...
</pre></div>
</div>
<p>The incoming arguments is the formal arguments defined in compiler and program
language books. The outgoing arguments is the actual arguments.
Summary as Table: Callee incoming arguments and caller outgoing arguments.</p>
<table border="1" class="docutils">
<caption>Callee incoming arguments and caller outgoing arguments</caption>
<colgroup>
<col width="22%" />
<col width="39%" />
<col width="39%" />
</colgroup>
<thead valign="bottom">
<tr class="row-odd"><th class="head">Description</th>
<th class="head">Callee</th>
<th class="head">Caller</th>
</tr>
</thead>
<tbody valign="top">
<tr class="row-even"><td>Charged Function</td>
<td>LowerFormalArguments()</td>
<td>LowerCall()</td>
</tr>
<tr class="row-odd"><td>Charged Function Created</td>
<td>Create load vectors for incoming arguments</td>
<td>Create store vectors for outgoing arguments</td>
</tr>
<tr class="row-even"><td>Arguments location</td>
<td>spOffset + stackSize</td>
<td>spOffset</td>
</tr>
</tbody>
</table>
</div>
<div class="section" id="pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup">
<h3>Pseudo hook instruction ADJCALLSTACKDOWN and ADJCALLSTACKUP<a class="headerlink" href="#pseudo-hook-instruction-adjcallstackdown-and-adjcallstackup" title="Permalink to this headline">¶</a></h3>
<p>To fix the !ADJSTACKDOWN and !ADJSTACKUP, we call Cpu0GenInstrInfo(Cpu0::
ADJCALLSTACKDOWN, Cpu0::ADJCALLSTACKUP) in Cpu0InstrInfo() constructor
function and define eliminateCallFramePseudoInstr() as follows,</p>
<p class="rubric">lbdex/Chapter9_3/Cpu0InstrInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0InstrInfo</span><span class="o">::</span><span class="n">Cpu0InstrInfo</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
  <span class="o">:</span>
    <span class="n">Cpu0GenInstrInfo</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ADJCALLSTACKDOWN</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADJCALLSTACKUP</span><span class="p">),</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0FrameLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                   <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                                   <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="c1">// Cpu0</span>
<span class="c1">// This function eliminate ADJCALLSTACKDOWN,</span>
<span class="c1">// ADJCALLSTACKUP pseudo instructions</span>
<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span>
<span class="n">eliminateCallFramePseudoInstr</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">,</span>
                <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="c1">// Simply discard ADJCALLSTACKDOWN, ADJCALLSTACKUP instructions.</span>
  <span class="n">MBB</span><span class="p">.</span><span class="n">erase</span><span class="p">(</span><span class="n">I</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p>With above definition, eliminateCallFramePseudoInstr() will be called when
llvm meet pseudo instructions ADJCALLSTACKDOWN and ADJCALLSTACKUP.
We just discard these 2 pseudo instructions.
Run Chapter9_3/ with ch9_1.cpp will discard these two Pseudo hook instructions.</p>
</div>
<div class="section" id="handle-gp-register-in-pic-addressing-mode">
<h3>Handle $gp register in PIC addressing mode<a class="headerlink" href="#handle-gp-register-in-pic-addressing-mode" title="Permalink to this headline">¶</a></h3>
<p>In &#8220;section Global variable&#8221; <a class="footnote-reference" href="#id14" id="id7">[5]</a>, we mentioned two link
type, the static link and dynamic link.
The option -relocation-model=static is for static link function while option
-relocation-model=pic is for dynamic link function.
One example of dynamic link function is used in share library.
Share library include a lots of dynamic link functions usually can be loaded
at run time.
Since share library can be loaded in different memory address, the global
variable address it access cannot be decided at link time.
But, we can caculate the distance between the global variable address and
the start address of shared library function when it be loaded.</p>
<p>Let&#8217;s run Chapter9_3/ with ch9_1.cpp to get the following correct result.
We putting the comments in the result for explanation.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
_Z5sum_iiiiiii:
...
    .cpload <span class="nv">$t9</span> // assign <span class="nv">$gp</span> <span class="o">=</span> <span class="nv">$t9</span> by loader when loader load re-entry
                //  <span class="k">function</span> <span class="o">(</span>shared library<span class="o">)</span> of _Z5sum_iiiiiii
    .set    nomacro
<span class="c"># BB#0:</span>
    addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -32
<span class="nv">$tmp1</span>:
    .cfi_def_cfa_offset 32
...
    ld  <span class="nv">$3</span>, %got<span class="o">(</span>gI<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>   // %got<span class="o">(</span>gI<span class="o">)</span> is offset of <span class="o">(</span>gI - _Z5sum_iiiiiii<span class="o">)</span>
...
    ret <span class="nv">$lr</span>
    .set    macro
    .set    reorder
    .end    _Z5sum_iiiiiii
...
    .ent    main                    <span class="c"># @main</span>
main:
    .cfi_startproc
...
    .cpload <span class="nv">$t9</span>
    .set    nomacro
...
    .cprestore  24    // save <span class="nv">$gp</span> to 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
    addiu   <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
...
    ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
    jalr    <span class="nv">$t9</span>       // <span class="nv">$t9</span> register is the <span class="nb">alias </span>of <span class="nv">$6</span>
    ld  <span class="nv">$gp</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>  // restore <span class="nv">$gp</span> from 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
...
    .end    main
<span class="nv">$tmp7</span>:
    .size   main, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-main
    .cfi_endproc

    .type   gI,@object              <span class="c"># @gI</span>
    .data
    .globl  gI
    .align  2
gI:
    .4byte  100                     <span class="c"># 0x64</span>
    .size   gI, 4
</pre></div>
</div>
<p>As above code comment, <strong>“.cprestore 24”</strong> is a pseudo instruction for saving
<strong>$gp</strong> to <strong>24($sp)</strong> while Instruction <strong>“ld $gp, 24($sp)”</strong> will restore
the $gp.
In other word, $gp is a caller saved register, so main() need to save/restore
$gp before/after call the shared library _Z5sum_iiiiiii() function.
In _Z5sum_iiiiiii() function, we translate global variable gI address by
<strong>“ld $3, %got(gI)($gp)”</strong> where %got(gI) is the offset value of
(gI - _Z5sum_iiiiiii) which can be caculated at link time.</p>
<p>According the original cpu0 web site information, it only support <strong>“jsub”</strong> 24
bits address range access.
We add <strong>“jalr”</strong> to cpu0 and expand it to 32 bit address. We did this change for
two reason. One is cpu0 can be expand to 32 bit address space by only add this
instruction.
The other is cpu0 as well as this book are designed for teaching purpose.
We reserve <strong>“jalr”</strong> as PIC mode for dynamic linking function to demonstrate:</p>
<ol class="arabic simple">
<li>How caller handle the caller saved register $gp in calling the function</li>
<li>How the code in the shared libray function use $gp to access global variable
address.</li>
<li>The jalr for dynamic linking function is easier in implementation and faster.
As we have depicted in section &#8220;pic mode&#8221; of chapter &#8220;Global variables, structs
and arrays, other type&#8221;. This solution is popular in reality and deserve change
cpu0 official design as a compiler book.</li>
</ol>
<p>Now, after the following code added in Chapter9_3/, we can issue
<strong>“.cprestore”</strong> in emitPrologue() and emit &#8220;ld $gp, ($gp save slot on stack)&#8221;
after jalr by create file Cpu0EmitGPRestore.cpp which run as a function pass.</p>
<p class="rubric">lbdex/Chapter9_3/CMakeLists.txt</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">add_llvm_target</span><span class="p">(</span><span class="n">Cpu0CodeGen</span>
  <span class="p">...</span>
  <span class="n">Cpu0EmitGPRestore</span><span class="p">.</span><span class="n">cpp</span>
<span class="p">...</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0TargetMachine.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0elTargetMachine</span><span class="o">::</span>
<span class="n">Cpu0elTargetMachine</span><span class="p">(</span><span class="k">const</span> <span class="n">Target</span> <span class="o">&amp;</span><span class="n">T</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">TT</span><span class="p">,</span>
                    <span class="n">StringRef</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">StringRef</span> <span class="n">FS</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetOptions</span> <span class="o">&amp;</span><span class="n">Options</span><span class="p">,</span>
                    <span class="n">Reloc</span><span class="o">::</span><span class="n">Model</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CodeModel</span><span class="o">::</span><span class="n">Model</span> <span class="n">CM</span><span class="p">,</span>
                    <span class="n">CodeGenOpt</span><span class="o">::</span><span class="n">Level</span> <span class="n">OL</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">Cpu0TargetMachine</span><span class="p">(</span><span class="n">T</span><span class="p">,</span> <span class="n">TT</span><span class="p">,</span> <span class="n">CPU</span><span class="p">,</span> <span class="n">FS</span><span class="p">,</span> <span class="n">Options</span><span class="p">,</span> <span class="n">RM</span><span class="p">,</span> <span class="n">CM</span><span class="p">,</span> <span class="n">OL</span><span class="p">,</span> <span class="nb">true</span><span class="p">)</span> <span class="p">{}</span>
<span class="k">namespace</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">virtual</span> <span class="kt">bool</span> <span class="n">addPreRegAlloc</span><span class="p">();</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="kt">bool</span> <span class="n">Cpu0PassConfig</span><span class="o">::</span><span class="n">addPreRegAlloc</span><span class="p">()</span> <span class="p">{</span>
  <span class="c1">// Do not restore $gp if target is Cpu064.</span>
  <span class="c1">// In N32/64, $gp is a callee-saved register.</span>

  <span class="n">addPass</span><span class="p">(</span><span class="n">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">getCpu0TargetMachine</span><span class="p">()));</span>
  <span class="k">return</span> <span class="nb">true</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">FunctionPass</span> <span class="o">*</span><span class="nf">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">);</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="mi">4</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">LocalVarAreaOffset</span> <span class="o">=</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">()</span> <span class="o">?</span>
    <span class="p">(</span><span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">())</span> <span class="o">+</span> <span class="n">RegSize</span><span class="p">)</span> <span class="o">:</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getMaxCallFrameSize</span><span class="p">();</span>
  <span class="p">...</span>
  <span class="c1">// Restore GP from the saved stack location</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">());</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPRESTORE</span><span class="p">)).</span><span class="n">addImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span>
      <span class="p">.</span><span class="n">addReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0InstrInfo.td</p>
<div class="highlight-c++"><pre>let neverHasSideEffects = 1 in
def CPRESTORE : Cpu0Pseudo&lt;(outs), (ins i32imm:$loc, CPURegs:$gp),
               ".cprestore\t$loc", []&gt;;</pre>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                              <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// If this is the first call, create a stack frame object that points to</span>
  <span class="c1">// a location to which .cprestore saves $gp.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">IsPIC</span> <span class="o">&amp;&amp;</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="o">!</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">())</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MaxCallFrameSize</span> <span class="o">&lt;</span> <span class="n">NextStackOffset</span><span class="p">)</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">needGPSaveRestore</span><span class="p">())</span>
        <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">setObjectOffset</span><span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">(),</span> <span class="n">NextStackOffset</span><span class="p">);</span>
      <span class="p">}</span>
      <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0EmitGPRestore.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===-- Cpu0EmitGPRestore.cpp - Emit GP Restore Instruction ---------------===//</span>
<span class="c1">//</span>
<span class="c1">//                     The LLVM Compiler Infrastructure</span>
<span class="c1">//</span>
<span class="c1">// This file is distributed under the University of Illinois Open Source</span>
<span class="c1">// License. See LICENSE.TXT for details.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//</span>
<span class="c1">// This pass emits instructions that restore $gp right</span>
<span class="c1">// after jalr instructions.</span>
<span class="c1">//</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="cp">#define DEBUG_TYPE &quot;emit-gp-restore&quot;</span>

<span class="cp">#include &quot;Cpu0.h&quot;</span>
<span class="cp">#include &quot;Cpu0TargetMachine.h&quot;</span>
<span class="cp">#include &quot;Cpu0MachineFunction.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineFunctionPass.h&quot;</span>
<span class="cp">#include &quot;llvm/CodeGen/MachineInstrBuilder.h&quot;</span>
<span class="cp">#include &quot;llvm/Target/TargetInstrInfo.h&quot;</span>
<span class="cp">#include &quot;llvm/ADT/Statistic.h&quot;</span>

<span class="k">using</span> <span class="k">namespace</span> <span class="n">llvm</span><span class="p">;</span>

<span class="k">namespace</span> <span class="p">{</span>
  <span class="k">struct</span> <span class="n">Inserter</span> <span class="o">:</span> <span class="k">public</span> <span class="n">MachineFunctionPass</span> <span class="p">{</span>

    <span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">;</span>
    <span class="k">const</span> <span class="n">TargetInstrInfo</span> <span class="o">*</span><span class="n">TII</span><span class="p">;</span>

    <span class="k">static</span> <span class="kt">char</span> <span class="n">ID</span><span class="p">;</span>
    <span class="n">Inserter</span><span class="p">(</span><span class="n">TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span>
      <span class="o">:</span> <span class="n">MachineFunctionPass</span><span class="p">(</span><span class="n">ID</span><span class="p">),</span> <span class="n">TM</span><span class="p">(</span><span class="n">tm</span><span class="p">),</span> <span class="n">TII</span><span class="p">(</span><span class="n">tm</span><span class="p">.</span><span class="n">getInstrInfo</span><span class="p">())</span> <span class="p">{</span> <span class="p">}</span>

    <span class="k">virtual</span> <span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">getPassName</span><span class="p">()</span> <span class="k">const</span> <span class="p">{</span>
      <span class="k">return</span> <span class="s">&quot;Cpu0 Emit GP Restore&quot;</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="kt">bool</span> <span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">);</span>
  <span class="p">};</span>
  <span class="kt">char</span> <span class="n">Inserter</span><span class="o">::</span><span class="n">ID</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span> <span class="c1">// end of anonymous namespace</span>

<span class="kt">bool</span> <span class="n">Inserter</span><span class="o">::</span><span class="n">runOnMachineFunction</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">F</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">((</span><span class="n">TM</span><span class="p">.</span><span class="n">getRelocationModel</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Reloc</span><span class="o">::</span><span class="n">PIC_</span><span class="p">)</span> <span class="o">||</span>
      <span class="p">(</span><span class="o">!</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">globalBaseRegFixed</span><span class="p">()))</span>
    <span class="k">return</span> <span class="nb">false</span><span class="p">;</span>

  <span class="kt">bool</span> <span class="n">Changed</span> <span class="o">=</span> <span class="nb">false</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getGPFI</span><span class="p">();</span>

  <span class="k">for</span> <span class="p">(</span><span class="n">MachineFunction</span><span class="o">::</span><span class="n">iterator</span> <span class="n">MFI</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">begin</span><span class="p">(),</span> <span class="n">MFE</span> <span class="o">=</span> <span class="n">F</span><span class="p">.</span><span class="n">end</span><span class="p">();</span>
       <span class="n">MFI</span> <span class="o">!=</span> <span class="n">MFE</span><span class="p">;</span> <span class="o">++</span><span class="n">MFI</span><span class="p">)</span> <span class="p">{</span>
    <span class="n">MachineBasicBlock</span><span class="o">&amp;</span> <span class="n">MBB</span> <span class="o">=</span> <span class="o">*</span><span class="n">MFI</span><span class="p">;</span>
    <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">begin</span><span class="p">();</span>
    
    <span class="c1">/// IsLandingPad - Indicate that this basic block is entered via an</span>
    <span class="c1">/// exception handler.</span>
    <span class="c1">// If MBB is a landing pad, insert instruction that restores $gp after</span>
    <span class="c1">// EH_LABEL.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">MBB</span><span class="p">.</span><span class="n">isLandingPad</span><span class="p">())</span> <span class="p">{</span>
      <span class="c1">// Find EH_LABEL first.</span>
      <span class="k">for</span> <span class="p">(;</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">TargetOpcode</span><span class="o">::</span><span class="n">EH_LABEL</span><span class="p">;</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span> <span class="p">;</span>

      <span class="c1">// Insert ld.</span>
      <span class="o">++</span><span class="n">I</span><span class="p">;</span>
      <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">I</span> <span class="o">!=</span> <span class="n">MBB</span><span class="p">.</span><span class="n">end</span><span class="p">()</span> <span class="o">?</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">()</span> <span class="o">:</span> <span class="n">DebugLoc</span><span class="p">();</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">),</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">)</span>
                                                       <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">while</span> <span class="p">(</span><span class="n">I</span> <span class="o">!=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">end</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="n">I</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">()</span> <span class="o">!=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">JALR</span><span class="p">)</span> <span class="p">{</span>
        <span class="o">++</span><span class="n">I</span><span class="p">;</span>
        <span class="k">continue</span><span class="p">;</span>
      <span class="p">}</span>

      <span class="n">DebugLoc</span> <span class="n">dl</span> <span class="o">=</span> <span class="n">I</span><span class="o">-&gt;</span><span class="n">getDebugLoc</span><span class="p">();</span>
      <span class="c1">// emit lw $gp, ($gp save slot on stack) after jalr</span>
      <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="o">++</span><span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="o">-&gt;</span><span class="n">get</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">LD</span><span class="p">),</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">).</span><span class="n">addFrameIndex</span><span class="p">(</span><span class="n">FI</span><span class="p">)</span>
                                                         <span class="p">.</span><span class="n">addImm</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
      <span class="n">Changed</span> <span class="o">=</span> <span class="nb">true</span><span class="p">;</span>
    <span class="p">}</span>
  <span class="p">}</span>

  <span class="k">return</span> <span class="n">Changed</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">/// createCpu0EmitGPRestorePass - Returns a pass that emits instructions that</span>
<span class="c1">/// restores $gp clobbered by jalr instructions.</span>
<span class="n">FunctionPass</span> <span class="o">*</span><span class="n">llvm</span><span class="o">::</span><span class="n">createCpu0EmitGPRestorePass</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">tm</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">return</span> <span class="k">new</span> <span class="n">Inserter</span><span class="p">(</span><span class="n">tm</span><span class="p">);</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0AsmPrinter.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">MCInst</span> <span class="n">TmpInst</span><span class="p">;</span>

  <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">Lower</span><span class="p">(</span><span class="n">MI</span><span class="p">,</span> <span class="n">TmpInst</span><span class="p">);</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">macro&quot;</span><span class="p">));</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">at&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="n">TmpInst</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getEmitNOAT</span><span class="p">())</span>
    <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">noat&quot;</span><span class="p">));</span>
  <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitRawText</span><span class="p">(</span><span class="n">StringRef</span><span class="p">(</span><span class="s">&quot;</span><span class="se">\t</span><span class="s">.set</span><span class="se">\t</span><span class="s">nomacro&quot;</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - EmitInstrWithMacroNoAT</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="kt">void</span> <span class="n">Cpu0AsmPrinter</span><span class="o">::</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineInstr</span> <span class="o">*</span><span class="n">MI</span><span class="p">)</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">unsigned</span> <span class="n">Opc</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOpcode</span><span class="p">();</span>
  <span class="p">...</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;</span> <span class="n">MCInsts</span><span class="p">;</span>

  <span class="k">switch</span> <span class="p">(</span><span class="n">Opc</span><span class="p">)</span> <span class="p">{</span>
  <span class="k">case</span> <span class="n">Cpu0</span>:<span class="o">:</span><span class="n">CPRESTORE</span><span class="o">:</span> <span class="p">{</span>
    <span class="k">const</span> <span class="n">MachineOperand</span> <span class="o">&amp;</span><span class="n">MO</span> <span class="o">=</span> <span class="n">MI</span><span class="o">-&gt;</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">);</span>
    <span class="n">assert</span><span class="p">(</span><span class="n">MO</span><span class="p">.</span><span class="n">isImm</span><span class="p">()</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;CPRESTORE&#39;s operand must be an immediate.&quot;</span><span class="p">);</span>
    <span class="kt">int64_t</span> <span class="n">Offset</span> <span class="o">=</span> <span class="n">MO</span><span class="p">.</span><span class="n">getImm</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="n">OutStreamer</span><span class="p">.</span><span class="n">hasRawTextSupport</span><span class="p">())</span> <span class="p">{</span>
      <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">EmitInstrWithMacroNoAT</span><span class="p">(</span><span class="n">MI</span><span class="p">);</span>
        <span class="k">return</span><span class="p">;</span>
      <span class="p">}</span>
    <span class="p">}</span> <span class="k">else</span> <span class="p">{</span>
      <span class="n">MCInstLowering</span><span class="p">.</span><span class="n">LowerCPRESTORE</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="n">MCInsts</span><span class="p">);</span>

      <span class="k">for</span> <span class="p">(</span><span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MCInsts</span><span class="p">.</span><span class="n">begin</span><span class="p">();</span>
           <span class="n">I</span> <span class="o">!=</span> <span class="n">MCInsts</span><span class="p">.</span><span class="n">end</span><span class="p">();</span> <span class="o">++</span><span class="n">I</span><span class="p">)</span>
        <span class="n">OutStreamer</span><span class="p">.</span><span class="n">EmitInstruction</span><span class="p">(</span><span class="o">*</span><span class="n">I</span><span class="p">);</span>

      <span class="k">return</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="nl">default:</span>
    <span class="k">break</span><span class="p">;</span>
  <span class="p">}</span> <span class="c1">// lbd document - mark - switch (Opc)</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0MCInstLower.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// Lower &quot;.cprestore offset&quot; to &quot;st $gp, offset($sp)&quot;.</span>
<span class="kt">void</span> <span class="n">Cpu0MCInstLower</span><span class="o">::</span><span class="n">LowerCPRESTORE</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">,</span>
                                     <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">)</span> <span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">32</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="p">(</span><span class="n">Offset</span> <span class="o">&gt;=</span> <span class="mi">0</span><span class="p">)</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;Imm operand of .cprestore must be a non-negative 32-bit value.&quot;</span><span class="p">);</span>

  <span class="n">MCOperand</span> <span class="n">SPReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">),</span> <span class="n">BaseReg</span> <span class="o">=</span> <span class="n">SPReg</span><span class="p">;</span>
  <span class="n">MCOperand</span> <span class="n">GPReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">GP</span><span class="p">);</span>
  <span class="n">MCOperand</span> <span class="n">ZEROReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">);</span>

  <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">isInt</span><span class="o">&lt;</span><span class="mi">16</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Offset</span><span class="p">))</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Hi</span> <span class="o">=</span> <span class="p">((</span><span class="n">Offset</span> <span class="o">+</span> <span class="mh">0x8000</span><span class="p">)</span> <span class="o">&gt;&gt;</span> <span class="mi">16</span><span class="p">)</span> <span class="o">&amp;</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="n">Offset</span> <span class="o">&amp;=</span> <span class="mh">0xffff</span><span class="p">;</span>
    <span class="n">MCOperand</span> <span class="n">ATReg</span> <span class="o">=</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateReg</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">AT</span><span class="p">);</span>
    <span class="n">BaseReg</span> <span class="o">=</span> <span class="n">ATReg</span><span class="p">;</span>

    <span class="c1">// lui   at,hi</span>
    <span class="c1">// add   at,at,sp</span>
    <span class="n">MCInsts</span><span class="p">.</span><span class="n">resize</span><span class="p">(</span><span class="mi">2</span><span class="p">);</span>
    <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">LUi</span><span class="p">,</span> <span class="n">ATReg</span><span class="p">,</span> <span class="n">ZEROReg</span><span class="p">,</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">Hi</span><span class="p">));</span>
    <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">MCInsts</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">ATReg</span><span class="p">,</span> <span class="n">ATReg</span><span class="p">,</span> <span class="n">SPReg</span><span class="p">);</span>
  <span class="p">}</span>

  <span class="n">MCInst</span> <span class="n">St</span><span class="p">;</span>
  <span class="n">CreateMCInst</span><span class="p">(</span><span class="n">St</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ST</span><span class="p">,</span> <span class="n">GPReg</span><span class="p">,</span> <span class="n">BaseReg</span><span class="p">,</span> <span class="n">MCOperand</span><span class="o">::</span><span class="n">CreateImm</span><span class="p">(</span><span class="n">Offset</span><span class="p">));</span>
  <span class="n">MCInsts</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">St</span><span class="p">);</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - LowerCPRESTORE</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_3/Cpu0MCInstLower.h</p>
<div class="highlight-c++"><div class="highlight"><pre>  <span class="kt">void</span> <span class="nf">LowerCPRESTORE</span><span class="p">(</span><span class="kt">int64_t</span> <span class="n">Offset</span><span class="p">,</span> <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">MCInst</span><span class="p">,</span> <span class="mi">4</span><span class="o">&gt;&amp;</span> <span class="n">MCInsts</span><span class="p">);</span>
</pre></div>
</div>
<p>The added code of Cpu0AsmPrinter.cpp as above will call the LowerCPRESTORE() when
user run with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></tt>.
The added code of Cpu0MCInstLower.cpp as above take care the .cprestore machine
instructions.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>
obj ch9_1.bc -o ch9_1.cpu0.o
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>hexdump  ch9_1.cpu0.o
...
// .cprestore machine instruction “ 01 ad 00 18”
00000d0 01 ad 00 18 09 20 00 00 01 2d 00 40 09 20 00 06
...

118-165-67-25:InputFiles Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
...
  .ent  _Z5sum_iiiiiii          <span class="c"># @_Z5sum_iiiiiii</span>
_Z5sum_iiiiiii:
...
  .cpload <span class="nv">$t9</span> // assign <span class="nv">$gp</span> <span class="o">=</span> <span class="nv">$t9</span> by loader when loader load re-entry <span class="k">function</span>
              // <span class="o">(</span>shared library<span class="o">)</span> of _Z5sum_iiiiiii
  .set  nomacro
<span class="c"># BB#0:</span>
...
  .ent  main                    <span class="c"># @main</span>
...
  .cprestore  24  // save <span class="nv">$gp</span> to 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
...
</pre></div>
</div>
<p>Run <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-static</span></tt> will call jsub instruction instead of jalr as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>static -filetype<span class="o">=</span>
asm ch9_1.bc -o ch9_1.cpu0.s
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>cat ch9_1.cpu0.s
...
  jsub  _Z5sum_iiiiiii
...
</pre></div>
</div>
<p>Run with <tt class="docutils literal"><span class="pre">llc</span> <span class="pre">-filetype=obj</span></tt>, you can find the Cx of <strong>“jsub Cx”</strong> is 0 since
the Cx is calculated by linker as below.
Mips has the same 0 in it&#8217;s jal instruction.
The ch9_1_3.cpp and ch9_1_4.cpp are example code more for test.</p>
<div class="highlight-bash"><div class="highlight"><pre>// jsub _Z5sum_iiiiiii translate into 2B 00 00 00
00F0: 2B 00 00 00 01 2D 00 34 00 ED 00 3C 09 DD 00 40
</pre></div>
</div>
</div>
</div>
<div class="section" id="support-features">
<h2>Support features<a class="headerlink" href="#support-features" title="Permalink to this headline">¶</a></h2>
<p>This section support features of struct type, variable number of arguments and
dynamic stack allocation.</p>
<p>Run Chapter9_3 with ch9_2_1.cpp will get the error message as follows,</p>
<p class="rubric">lbdex/InputFiles/ch9_2_1.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">extern</span> <span class="s">&quot;C&quot;</span> <span class="kt">int</span> <span class="n">printf</span><span class="p">(</span><span class="k">const</span> <span class="kt">char</span> <span class="o">*</span><span class="n">format</span><span class="p">,</span> <span class="p">...);</span>

<span class="k">struct</span> <span class="n">Date</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">year</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">month</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">day</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">hour</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minute</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Date</span> <span class="n">gDate</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2012</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>

<span class="k">struct</span> <span class="n">Time</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">hour</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">minute</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">second</span><span class="p">;</span>
<span class="p">};</span>
<span class="n">Time</span> <span class="n">gTime</span> <span class="o">=</span> <span class="p">{</span><span class="mi">2</span><span class="p">,</span> <span class="mi">20</span><span class="p">,</span> <span class="mi">30</span><span class="p">};</span>

<span class="n">Date</span> <span class="nf">getDate</span><span class="p">()</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">gDate</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Date</span> <span class="nf">copyDate</span><span class="p">(</span><span class="n">Date</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Date</span> <span class="nf">copyDate</span><span class="p">(</span><span class="n">Date</span><span class="o">*</span> <span class="n">date</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="o">*</span><span class="n">date</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Time</span> <span class="nf">copyTime</span><span class="p">(</span><span class="n">Time</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="n">time</span><span class="p">;</span>
<span class="p">}</span>

<span class="n">Time</span> <span class="nf">copyTime</span><span class="p">(</span><span class="n">Time</span><span class="o">*</span> <span class="n">time</span><span class="p">)</span>
<span class="p">{</span> 
  <span class="k">return</span> <span class="o">*</span><span class="n">time</span><span class="p">;</span>
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_func_arg_struct</span><span class="p">()</span>
<span class="p">{</span>
  <span class="n">Time</span> <span class="n">time1</span> <span class="o">=</span> <span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">10</span><span class="p">,</span> <span class="mi">12</span><span class="p">};</span>
  <span class="n">Date</span> <span class="n">date1</span> <span class="o">=</span> <span class="n">getDate</span><span class="p">();</span>
  <span class="n">Date</span> <span class="n">date2</span> <span class="o">=</span> <span class="n">copyDate</span><span class="p">(</span><span class="n">date1</span><span class="p">);</span>
  <span class="n">Date</span> <span class="n">date3</span> <span class="o">=</span> <span class="n">copyDate</span><span class="p">(</span><span class="o">&amp;</span><span class="n">date1</span><span class="p">);</span>
  <span class="n">Time</span> <span class="n">time2</span> <span class="o">=</span> <span class="n">copyTime</span><span class="p">(</span><span class="n">time1</span><span class="p">);</span>
  <span class="n">Time</span> <span class="n">time3</span> <span class="o">=</span> <span class="n">copyTime</span><span class="p">(</span><span class="o">&amp;</span><span class="n">time1</span><span class="p">);</span>
<span class="cp">#ifdef PRINT_TEST</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;date1 = %d %d %d %d %d %d&quot;</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">year</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">day</span><span class="p">,</span>
    <span class="n">date1</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">date1</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="c1">// date1 = 2012 10 12 1 2 3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">date1</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">2012</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">hour</span> 
      <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">date1</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;date2 = %d %d %d %d %d %d&quot;</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">year</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">month</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">day</span><span class="p">,</span>
    <span class="n">date2</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">date2</span><span class="p">.</span><span class="n">second</span><span class="p">);</span> <span class="c1">// date2 = 2012 10 12 1 2 3</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">date2</span><span class="p">.</span><span class="n">year</span> <span class="o">==</span> <span class="mi">2012</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">month</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">day</span> <span class="o">==</span> <span class="mi">12</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">hour</span> 
      <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">2</span> <span class="o">&amp;&amp;</span> <span class="n">date2</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">3</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="c1">// time2 = 1 10 12</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;time2 = %d %d %d&quot;</span><span class="p">,</span> <span class="n">time2</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time2</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time2</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">time2</span><span class="p">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time2</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">time2</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="c1">// time3 = 1 10 12</span>
  <span class="n">printf</span><span class="p">(</span><span class="s">&quot;time3 = %d %d %d&quot;</span><span class="p">,</span> <span class="n">time3</span><span class="p">.</span><span class="n">hour</span><span class="p">,</span> <span class="n">time3</span><span class="p">.</span><span class="n">minute</span><span class="p">,</span> <span class="n">time3</span><span class="p">.</span><span class="n">second</span><span class="p">);</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">time3</span><span class="p">.</span><span class="n">hour</span> <span class="o">==</span> <span class="mi">1</span> <span class="o">&amp;&amp;</span> <span class="n">time3</span><span class="p">.</span><span class="n">minute</span> <span class="o">==</span> <span class="mi">10</span> <span class="o">&amp;&amp;</span> <span class="n">time3</span><span class="p">.</span><span class="n">second</span> <span class="o">==</span> <span class="mi">12</span><span class="p">)</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, PASS</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
  <span class="k">else</span>
    <span class="n">printf</span><span class="p">(</span><span class="s">&quot;, FAIL</span><span class="se">\n</span><span class="s">&quot;</span><span class="p">);</span>
<span class="cp">#endif</span>

  <span class="k">return</span> <span class="mi">0</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_2_1.cpp -emit-llvm -o ch9_2_1.bc
JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_2_1.bc -o ch9_2_1.cpu0.s
...
sret virtual register not created in the entry block
...
</pre></div>
</div>
<p>Run Chapter9_3/ with ch9_3.cpp to get the following error,</p>
<p class="rubric">lbdex/InputFiles/ch9_3.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="kt">int</span> <span class="nf">sum_i</span><span class="p">(</span><span class="kt">int</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="kt">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="kt">int</span><span class="p">);</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_vararg</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum_i</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3.cpp -emit-llvm -o ch9_3.bc
118-165-78-230:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_3.bc -o
ch9_3.cpu0.s
LLVM ERROR: Cannot <span class="k">select</span>: 0x7f8b6902fd10: <span class="nv">ch</span> <span class="o">=</span> vastart 0x7f8b6902fa10,
0x7f8b6902fb10, 0x7f8b6902fc10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>9<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>22<span class="o">]</span>
  0x7f8b6902fb10: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;5&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>7<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>9<span class="o">]</span>
In <span class="k">function</span>: _Z5sum_iiz
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch9_4.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//#include &lt;alloca.h&gt;</span>
<span class="cp">#include &lt;stdlib.h&gt;</span>

<span class="kt">int</span> <span class="nf">sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">sum</span> <span class="o">=</span> <span class="n">x1</span> <span class="o">+</span> <span class="n">x2</span> <span class="o">+</span> <span class="n">x3</span> <span class="o">+</span> <span class="n">x4</span> <span class="o">+</span> <span class="n">x5</span> <span class="o">+</span> <span class="n">x6</span><span class="p">;</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">weight_sum</span><span class="p">(</span><span class="kt">int</span> <span class="n">x1</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x2</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x3</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x4</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x5</span><span class="p">,</span> <span class="kt">int</span> <span class="n">x6</span><span class="p">)</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span><span class="o">*</span><span class="p">)</span><span class="n">alloca</span><span class="p">(</span><span class="k">sizeof</span><span class="p">(</span><span class="kt">int</span><span class="p">)</span> <span class="o">*</span> <span class="n">x1</span><span class="p">);</span>
  <span class="o">*</span><span class="n">b</span> <span class="o">=</span> <span class="mi">1111</span><span class="p">;</span>
  <span class="kt">int</span> <span class="n">weight</span> <span class="o">=</span> <span class="n">sum</span><span class="p">(</span><span class="mi">6</span><span class="o">*</span><span class="n">x1</span><span class="p">,</span> <span class="n">x2</span><span class="p">,</span> <span class="n">x3</span><span class="p">,</span> <span class="n">x4</span><span class="p">,</span> <span class="mi">2</span><span class="o">*</span><span class="n">x5</span><span class="p">,</span> <span class="n">x6</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">weight</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="nf">test_alloc</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">weight_sum</span><span class="p">(</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">,</span> <span class="mi">6</span><span class="p">);</span> <span class="c1">// 31</span>
  
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_3 with ch9_4.cpp will get the following error.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -I/
Applications/Xcode.app/Contents/Developer/Platforms/MacOSX.platform/Developer/
SDKs/MacOSX10.8.sdk/usr/include/ -c ch9_4.cpp -emit-llvm -o ch9_4.bc
118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_4.bc -o
ch9_4.cpu0.s
LLVM ERROR: Cannot <span class="k">select</span>: 0x7ffd8b02ff10: i32,ch <span class="o">=</span> dynamic_stackalloc
0x7ffd8b02f910:1, 0x7ffd8b02fe10, 0x7ffd8b02c010 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>48<span class="o">]</span>
  0x7ffd8b02fe10: <span class="nv">i32</span> <span class="o">=</span> and 0x7ffd8b02fc10, 0x7ffd8b02fd10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>47<span class="o">]</span>
    0x7ffd8b02fc10: <span class="nv">i32</span> <span class="o">=</span> add 0x7ffd8b02fa10, 0x7ffd8b02fb10 <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>46<span class="o">]</span>
      0x7ffd8b02fa10: <span class="nv">i32</span> <span class="o">=</span> shl 0x7ffd8b02f910, 0x7ffd8b02f510 <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>45<span class="o">]</span>
        0x7ffd8b02f910: i32,ch <span class="o">=</span> load 0x7ffd8b02ee10, 0x7ffd8b02e310,
        0x7ffd8b02b310&lt;LD4<span class="o">[</span>%1<span class="o">]</span>&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>44<span class="o">]</span>
          0x7ffd8b02e310: <span class="nv">i32</span> <span class="o">=</span> FrameIndex&lt;1&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>3<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>10<span class="o">]</span>
          0x7ffd8b02b310: <span class="nv">i32</span> <span class="o">=</span> undef <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>1<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>2<span class="o">]</span>
        0x7ffd8b02f510: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;2&gt; <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>25<span class="o">]</span>
      0x7ffd8b02fb10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;7&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>16<span class="o">]</span>
    0x7ffd8b02fd10: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;-8&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>17<span class="o">]</span>
  0x7ffd8b02c010: <span class="nv">i32</span> <span class="o">=</span> Constant&lt;0&gt; <span class="o">[</span><span class="nv">ORD</span><span class="o">=</span>12<span class="o">]</span> <span class="o">[</span><span class="nv">ID</span><span class="o">=</span>8<span class="o">]</span>
In <span class="k">function</span>: _Z5sum_iiiiiii
</pre></div>
</div>
<div class="section" id="structure-type-support">
<h3>Structure type support<a class="headerlink" href="#structure-type-support" title="Permalink to this headline">¶</a></h3>
<p>Chapter9_4/ with the following code added to support the structure type in
function call.</p>
<p class="rubric">lbdex/Chapter9_4/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="c1">// AddLiveIn - This helper function adds the specified physical register to the</span>
<span class="c1">// MachineFunction as a live in value.  It also creates a corresponding</span>
<span class="c1">// virtual register for it.</span>
<span class="k">static</span> <span class="kt">unsigned</span>
<span class="nf">AddLiveIn</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">PReg</span><span class="p">,</span> <span class="k">const</span> <span class="n">TargetRegisterClass</span> <span class="o">*</span><span class="n">RC</span><span class="p">)</span>
<span class="p">{</span>
  <span class="n">assert</span><span class="p">(</span><span class="n">RC</span><span class="o">-&gt;</span><span class="n">contains</span><span class="p">(</span><span class="n">PReg</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="s">&quot;Not the correct regclass!&quot;</span><span class="p">);</span>
  <span class="kt">unsigned</span> <span class="n">VReg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">RC</span><span class="p">);</span>
  <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">addLiveIn</span><span class="p">(</span><span class="n">PReg</span><span class="p">,</span> <span class="n">VReg</span><span class="p">);</span>
  <span class="k">return</span> <span class="n">VReg</span><span class="p">;</span>
<span class="p">}</span>

<span class="c1">//===----------------------------------------------------------------------===//</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="c1">//                  Call Calling Convention Implementation</span>
<span class="c1">//===----------------------------------------------------------------------===//</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">unsigned</span> <span class="n">IntRegsSize</span> <span class="o">=</span> <span class="mi">2</span><span class="p">;</span>

<span class="k">static</span> <span class="k">const</span> <span class="kt">uint16_t</span> <span class="n">IntRegs</span><span class="p">[]</span> <span class="o">=</span> <span class="p">{</span>
  <span class="n">Cpu0</span><span class="o">::</span><span class="n">A0</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">A1</span>
<span class="p">};</span>

<span class="c1">// Write ByVal Arg to arg registers and stack.</span>
<span class="k">static</span> <span class="kt">void</span>
<span class="nf">WriteByValArg</span><span class="p">(</span><span class="n">SDValue</span><span class="o">&amp;</span> <span class="n">ByValChain</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
              <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">pair</span><span class="o">&lt;</span><span class="kt">unsigned</span><span class="p">,</span> <span class="n">SDValue</span><span class="o">&gt;</span><span class="p">,</span> <span class="mi">16</span><span class="o">&gt;&amp;</span> <span class="n">RegsToPass</span><span class="p">,</span>
              <span class="n">SmallVector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="p">,</span> <span class="mi">8</span><span class="o">&gt;&amp;</span> <span class="n">MemOpChains</span><span class="p">,</span> <span class="kt">int</span><span class="o">&amp;</span> <span class="n">LastFI</span><span class="p">,</span>
              <span class="n">MachineFrameInfo</span> <span class="o">*</span><span class="n">MFI</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Arg</span><span class="p">,</span>
              <span class="k">const</span> <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span><span class="p">,</span> <span class="k">const</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span><span class="o">&amp;</span> <span class="n">Flags</span><span class="p">,</span>
              <span class="n">MVT</span> <span class="n">PtrType</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isLittle</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">LocMemOffset</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">Offset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="kt">uint32_t</span> <span class="n">RemainingSize</span> <span class="o">=</span> <span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">ByValAlign</span> <span class="o">=</span> <span class="n">Flags</span><span class="p">.</span><span class="n">getByValAlign</span><span class="p">();</span>

  <span class="k">if</span> <span class="p">(</span><span class="n">RemainingSize</span> <span class="o">==</span> <span class="mi">0</span><span class="p">)</span>
    <span class="k">return</span><span class="p">;</span>

  <span class="c1">// Create a fixed object on stack at offset LocMemOffset and copy</span>
  <span class="c1">// remaining part of byval arg to it using memcpy.</span>
  <span class="n">SDValue</span> <span class="n">Src</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span>
                            <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">Offset</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
  <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RemainingSize</span><span class="p">,</span> <span class="n">LocMemOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">Dst</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">,</span> <span class="n">PtrType</span><span class="p">);</span>
  <span class="n">ByValChain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMemcpy</span><span class="p">(</span><span class="n">ByValChain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Dst</span><span class="p">,</span> <span class="n">Src</span><span class="p">,</span>
                             <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">RemainingSize</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">),</span>
                             <span class="n">std</span><span class="o">::</span><span class="n">min</span><span class="p">(</span><span class="n">ByValAlign</span><span class="p">,</span> <span class="p">(</span><span class="kt">unsigned</span><span class="p">)</span><span class="mi">4</span><span class="p">),</span>
                             <span class="cm">/*isVolatile=*/</span><span class="nb">false</span><span class="p">,</span> <span class="cm">/*AlwaysInline=*/</span><span class="nb">false</span><span class="p">,</span>
                             <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="mi">0</span><span class="p">));</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - WriteByValArg</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerCall</span><span class="p">(</span><span class="n">TargetLowering</span><span class="o">::</span><span class="n">CallLoweringInfo</span> <span class="o">&amp;</span><span class="n">CLI</span><span class="p">,</span>
                <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Walk the register/memloc assignments, inserting copies/loads.</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="c1">// ByVal Arg.</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="p">...</span>
      <span class="n">WriteByValArg</span><span class="p">(</span><span class="n">ByValChain</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">RegsToPass</span><span class="p">,</span> <span class="n">MemOpChains</span><span class="p">,</span> <span class="n">LastFI</span><span class="p">,</span>
            <span class="n">MFI</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">Arg</span><span class="p">,</span> <span class="n">VA</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">(),</span>
            <span class="n">Subtarget</span><span class="o">-&gt;</span><span class="n">isLittle</span><span class="p">());</span>
      <span class="p">...</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">//===----------------------------------------------------------------------===//</span>
<span class="k">static</span> <span class="kt">void</span> <span class="nf">ReadByValArg</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span>
                         <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;&amp;</span> <span class="n">OutChains</span><span class="p">,</span>
                         <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span> <span class="kt">unsigned</span> <span class="n">NumWords</span><span class="p">,</span> <span class="n">SDValue</span> <span class="n">FIN</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">CCValAssign</span> <span class="o">&amp;</span><span class="n">VA</span><span class="p">,</span> <span class="k">const</span> <span class="n">ISD</span><span class="o">::</span><span class="n">ArgFlagsTy</span><span class="o">&amp;</span> <span class="n">Flags</span><span class="p">,</span>
                         <span class="k">const</span> <span class="n">Argument</span> <span class="o">*</span><span class="n">FuncArg</span><span class="p">)</span> <span class="p">{</span>
  <span class="kt">unsigned</span> <span class="n">LocMem</span> <span class="o">=</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">();</span>
  <span class="kt">unsigned</span> <span class="n">FirstWord</span> <span class="o">=</span> <span class="n">LocMem</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>

  <span class="c1">// copy register A0 - A1 to frame object</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">NumWords</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">CurWord</span> <span class="o">=</span> <span class="n">FirstWord</span> <span class="o">+</span> <span class="n">i</span><span class="p">;</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">CurWord</span> <span class="o">&gt;=</span> <span class="n">IntRegsSize</span><span class="p">)</span>
      <span class="k">break</span><span class="p">;</span>

    <span class="kt">unsigned</span> <span class="n">SrcReg</span> <span class="o">=</span> <span class="n">IntRegs</span><span class="p">[</span><span class="n">CurWord</span><span class="p">];</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">AddLiveIn</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">SrcReg</span><span class="p">,</span> <span class="o">&amp;</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">StorePtr</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">ADD</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span>
                                   <span class="n">DAG</span><span class="p">.</span><span class="n">getConstant</span><span class="p">(</span><span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
    <span class="n">SDValue</span> <span class="n">Store</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">Reg</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">),</span>
                                 <span class="n">StorePtr</span><span class="p">,</span> <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">FuncArg</span><span class="p">,</span> <span class="n">i</span> <span class="o">*</span> <span class="mi">4</span><span class="p">),</span>
                                 <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
    <span class="n">OutChains</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">Store</span><span class="p">);</span>
  <span class="p">}</span>
<span class="p">}</span> <span class="c1">// lbd document - mark - ReadByValArg</span>
</pre></div>
</div>
<div class="highlight-c++"><div class="highlight"><pre><span class="p">...</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                     <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                     <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                     <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                      <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">,</span> <span class="n">e</span> <span class="o">=</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">();</span> <span class="n">i</span> <span class="o">!=</span> <span class="n">e</span><span class="p">;</span> <span class="o">++</span><span class="n">i</span><span class="p">,</span> <span class="o">++</span><span class="n">FuncArg</span><span class="p">)</span> <span class="p">{</span>
    <span class="p">...</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">isByVal</span><span class="p">())</span> <span class="p">{</span>
      <span class="n">assert</span><span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">&amp;&amp;</span>
         <span class="s">&quot;ByVal args of size 0 should have been ignored by front-end.&quot;</span><span class="p">);</span>
      <span class="kt">unsigned</span> <span class="n">NumWords</span> <span class="o">=</span> <span class="p">(</span><span class="n">Flags</span><span class="p">.</span><span class="n">getByValSize</span><span class="p">()</span> <span class="o">+</span> <span class="mi">3</span><span class="p">)</span> <span class="o">/</span> <span class="mi">4</span><span class="p">;</span>
      <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">NumWords</span> <span class="o">*</span> <span class="mi">4</span><span class="p">,</span> <span class="n">VA</span><span class="p">.</span><span class="n">getLocMemOffset</span><span class="p">(),</span>
                      <span class="nb">true</span><span class="p">);</span>
      <span class="n">SDValue</span> <span class="n">FIN</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>
      <span class="n">InVals</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">FIN</span><span class="p">);</span>
      <span class="n">ReadByValArg</span><span class="p">(</span><span class="n">MF</span><span class="p">,</span> <span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">OutChains</span><span class="p">,</span> <span class="n">DAG</span><span class="p">,</span> <span class="n">NumWords</span><span class="p">,</span> <span class="n">FIN</span><span class="p">,</span> <span class="n">VA</span><span class="p">,</span> <span class="n">Flags</span><span class="p">,</span>
             <span class="o">&amp;*</span><span class="n">FuncArg</span><span class="p">);</span>
      <span class="k">continue</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="p">...</span>
  <span class="p">}</span>
  <span class="c1">// The cpu0 ABIs for returning structs by value requires that we copy</span>
  <span class="c1">// the sret argument into $v0 for the return. Save the argument into</span>
  <span class="c1">// a virtual register so that we can access it from the return points.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasStructRetAttr</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">getRegClassFor</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setSRetReturnReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">SDValue</span> <span class="n">Copy</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">InVals</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>In addition to above code, we have defined the calling convention at early of
this chapter as follows,</p>
<p class="rubric">lbdex/Chapter9_4/Cpu0CallingConv.td</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">def</span> <span class="n">RetCC_Cpu0EABI</span> <span class="o">:</span> <span class="n">CallingConv</span><span class="o">&lt;</span><span class="p">[</span>
  <span class="c1">// i32 are returned in registers V0, V1, A0, A1</span>
  <span class="n">CCIfType</span><span class="o">&lt;</span><span class="p">[</span><span class="n">i32</span><span class="p">],</span> <span class="n">CCAssignToReg</span><span class="o">&lt;</span><span class="p">[</span><span class="n">V0</span><span class="p">,</span> <span class="n">V1</span><span class="p">,</span> <span class="n">A0</span><span class="p">,</span> <span class="n">A1</span><span class="p">]</span><span class="o">&gt;&gt;</span>
<span class="p">]</span><span class="o">&gt;</span><span class="p">;</span>
</pre></div>
</div>
<p>It meaning for the return value, we keep it in registers V0, V1, A0, A1 if the return
value didn&#8217;t over 4 registers size; If it over 4 registers size, cpu0 will save
them with pointer.
For explanation, let&#8217;s run Chapter9_4/ with ch9_2_1.cpp and explain with this
example.</p>
<div class="highlight-bash"><div class="highlight"><pre>JonathantekiiMac:InputFiles Jonathan<span class="nv">$ </span>cat ch9_2_1.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_2_1.bc&quot;</span>
  .text
  .globl  _Z7getDatev
  .align  2
  .type _Z7getDatev,@function
  .ent  _Z7getDatev             <span class="c"># @_Z7getDatev</span>
_Z7getDatev:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>        // <span class="nv">$2</span> is 192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, %got<span class="o">(</span>gDate<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>  // <span class="nv">$3</span> is &amp;gDate
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>        // save gDate contents to 212..192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z7getDatev
<span class="nv">$tmp0</span>:
  .size _Z7getDatev, <span class="o">(</span><span class="nv">$tmp0</span><span class="o">)</span>-_Z7getDatev
  .cfi_endproc

  .globl  _Z8copyDate4Date
  .align  2
  .type _Z8copyDate4Date,@function
  .ent  _Z8copyDate4Date        <span class="c"># @_Z8copyDate4Date</span>
_Z8copyDate4Date:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  st  <span class="nv">$5</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>        // <span class="nv">$2</span> <span class="o">=</span> 168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>        // copy date1, 24..4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>, to date2,
  ld  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       //  188..168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8copyDate4Date
<span class="nv">$tmp1</span>:
  .size _Z8copyDate4Date, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z8copyDate4Date
  .cfi_endproc

  .globl  _Z8copyDateP4Date
  .align  2
  .type _Z8copyDateP4Date,@function
  .ent  _Z8copyDateP4Date       <span class="c"># @_Z8copyDateP4Date</span>
_Z8copyDateP4Date:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp3</span>:
  .cfi_def_cfa_offset 8
  ld  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>        // <span class="nv">$2</span> <span class="o">=</span> 120<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span> date2
  ld  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // <span class="nv">$3</span> <span class="o">=</span> 192<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span> date1
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>        // copy date1, 212..192<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span>,
  st  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>        //  to date2, 140..120<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8copyDateP4Date
<span class="nv">$tmp4</span>:
  .size _Z8copyDateP4Date, <span class="o">(</span><span class="nv">$tmp4</span><span class="o">)</span>-_Z8copyDateP4Date
  .cfi_endproc

  .globl  _Z8copyTime4Time
  .align  2
  .type _Z8copyTime4Time,@function
  .ent  _Z8copyTime4Time        <span class="c"># @_Z8copyTime4Time</span>
_Z8copyTime4Time:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,64,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -64
<span class="nv">$tmp6</span>:
  .cfi_def_cfa_offset 64
  ld  <span class="nv">$2</span>, 68<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // save 8..0 <span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span> to 24..16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 72<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // save 8<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span> to 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // time1.minute, save time1.minute and
  st  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       //  time1.second to 36..32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // time1.second
  st  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // <span class="nv">$2</span> <span class="o">=</span> 8<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span> <span class="o">=</span> time1.hour
  st  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // copy time1 to 56..48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // copy time1 to 8..0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 52<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>        // put time1 to <span class="nv">$2</span>, <span class="nv">$3</span> and <span class="nv">$4</span> <span class="o">(</span><span class="nv">$v0</span>, <span class="nv">$v1</span> and <span class="nv">$a0</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 64
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8copyTime4Time
<span class="nv">$tmp7</span>:
  .size _Z8copyTime4Time, <span class="o">(</span><span class="nv">$tmp7</span><span class="o">)</span>-_Z8copyTime4Time
  .cfi_endproc

  .globl  _Z8copyTimeP4Time
  .align  2
  .type _Z8copyTimeP4Time,@function
  .ent  _Z8copyTimeP4Time       <span class="c"># @_Z8copyTimeP4Time</span>
_Z8copyTimeP4Time:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,40,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -40
<span class="nv">$tmp9</span>:
  .cfi_def_cfa_offset 40
  ld  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       // 216<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>       // copy time1, 224..216<span class="o">(</span><span class="nv">$sp</span> of main<span class="o">)</span> to
  st  <span class="nv">$3</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       //  32..24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>, 8..0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> and <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$4</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 28<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 40
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8copyTimeP4Time
<span class="nv">$tmp10</span>:
  .size _Z8copyTimeP4Time, <span class="o">(</span><span class="nv">$tmp10</span><span class="o">)</span>-_Z8copyTimeP4Time
  .cfi_endproc

  .globl  _Z20test_func_arg_structv
  .align  2
  .type _Z20test_func_arg_structv,@function
  .ent  _Z20test_func_arg_structv                    <span class="c"># @main</span>
_Z20test_func_arg_structv:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,248,<span class="nv">$lr</span>
  .mask   0x00004180,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -248
<span class="nv">$tmp13</span>:
  .cfi_def_cfa_offset 248
  st  <span class="nv">$lr</span>, 244<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>           <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$8</span>, 240<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  st  <span class="nv">$7</span>, 236<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp14</span>:
  .cfi_offset 14, -4
<span class="nv">$tmp15</span>:
  .cfi_offset 8, -8
<span class="nv">$tmp16</span>:
  .cfi_offset 7, -12
  .cprestore  16
  addiu <span class="nv">$7</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$7</span>, 232<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, %got<span class="o">(</span><span class="nv">$_ZZ4mainE5time1</span><span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, %lo<span class="o">(</span><span class="nv">$_ZZ4mainE5time1</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>     // save initial value to time1, 224..216<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 224<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 220<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 216<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$8</span>, <span class="nv">$sp</span>, 192
  st  <span class="nv">$8</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // *<span class="o">(</span>0<span class="o">(</span><span class="nv">$sp</span><span class="o">))</span> <span class="o">=</span> 192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z7getDatev<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span> // copy gDate contents to date1, 212..192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ld  <span class="nv">$gp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 212<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>    // copy 212..192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> to 164..144<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 164<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 208<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 160<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 204<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 156<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 200<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 152<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 196<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 148<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 144<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 164<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>    // copy 164..144<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> to 24..4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 160<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 156<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 152<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 148<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 144<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 168
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // *0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> 168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z8copyDate4Date<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ld  <span class="nv">$gp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$8</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> 192<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> date1
  addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 120
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // *0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> 120<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> date2
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z8copyDateP4Date<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ld  <span class="nv">$gp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 224<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>    // save time1 to arguments passing location,
  st  <span class="nv">$2</span>, 96<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     //  8..0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 220<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 92<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 216<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 88<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 88<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 92<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 96<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z8copyTime4Time<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ld  <span class="nv">$gp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 76<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     // save <span class="k">return </span>value time2 from <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$4</span> to
  st  <span class="nv">$2</span>, 72<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     //   80..72<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> and 112..104<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 80<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 72<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 76<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 80<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 112<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 108<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 104<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 216
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // *<span class="o">(</span>0<span class="o">(</span><span class="nv">$sp</span><span class="o">))</span> <span class="o">=</span> 216<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z8copyTimeP4Time<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ld  <span class="nv">$gp</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     // save <span class="k">return </span>value time3 from <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$4</span> to
  st  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     //  48..44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> 64..56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 44<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 48<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 64<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 60<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  add <span class="nv">$2</span>, <span class="nv">$zero</span>, <span class="nv">$7</span>   // <span class="k">return </span>0 by <span class="nv">$2</span>, <span class="o">(</span><span class="nv">$7</span> is 0<span class="o">)</span>

  ld  <span class="nv">$7</span>, 236<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload // restore callee saved</span>
  ld  <span class="nv">$8</span>, 240<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload //  registers $s0, $s1</span>
  ld  <span class="nv">$lr</span>, 244<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>           <span class="c"># 4-byte Folded Reload //  ($7, $8)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 248
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z20test_func_arg_structv
<span class="nv">$tmp17</span>:
  .size _Z20test_func_arg_structv, <span class="o">(</span><span class="nv">$tmp17</span><span class="o">)</span>-_Z20test_func_arg_structv
  .cfi_endproc

  .type gDate,@object           <span class="c"># @gDate</span>
  .data
  .globl  gDate
  .align  2
gDate:
  .4byte  2012                    <span class="c"># 0x7dc</span>
  .4byte  10                      <span class="c"># 0xa</span>
  .4byte  12                      <span class="c"># 0xc</span>
  .4byte  1                       <span class="c"># 0x1</span>
  .4byte  2                       <span class="c"># 0x2</span>
  .4byte  3                       <span class="c"># 0x3</span>
  .size gDate, 24

  .type gTime,@object           <span class="c"># @gTime</span>
  .globl  gTime
  .align  2
gTime:
  .4byte  2                       <span class="c"># 0x2</span>
  .4byte  20                      <span class="c"># 0x14</span>
  .4byte  30                      <span class="c"># 0x1e</span>
  .size gTime, 12

  .type <span class="nv">$_Z20test_func_arg_structvE5time1</span>,@object <span class="c"># @_Z20test_func_arg_structvE5time1</span>
  .section  .rodata,<span class="s2">&quot;a&quot;</span>,@progbits
  .align  2
<span class="nv">$_Z20test_func_arg_structvE5time1</span>:
  .4byte  1                       <span class="c"># 0x1</span>
  .4byte  10                      <span class="c"># 0xa</span>
  .4byte  12                      <span class="c"># 0xc</span>
  .size <span class="nv">$_Z20test_func_arg_structvE5time1</span>, 12
</pre></div>
</div>
<p>In LowerCall(), Flags.isByVal() will be true if the outgoing arguments over 4
registers size, then it will call WriteByValArg(..., getPointerTy(), ...) to
save those arguments to stack as offset.
For example code of ch9_2_1.cpp, Flags.isByVal() is true for copyDate(date1)
outgoing arguments, since the date1 is type of Date which contains 6 integers
(year, month, day, hour, minute, second).
But Flags.isByVal() is false for copyTime(time1) since type Time is a struct
contains 3 integers (hour, minute, second).
So, if you mark WriteByValArg(..., getPointerTy(), ...), the result will
missing the following code in caller, main(),</p>
<div class="highlight-bash"><div class="highlight"><pre>ld  <span class="nv">$2</span>, 164<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>    // copy 164..144<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> to 24..4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
st  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$2</span>, 160<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$2</span>, 156<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$2</span>, 152<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$2</span>, 148<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$2</span>, 144<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>              // will missing the above code

addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 168
st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // *0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> 168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z8copyDate4Date<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
</pre></div>
</div>
<p>In LowerFormalArguments(), the &#8220;if (Flags.isByVal())&#8221; getting the incoming
arguments which corresponding the outgoing arguments of LowerCall().</p>
<p>LowerFormalArguments() is called when a function is entered while LowerReturn()
is called when a function is left, reference <a class="footnote-reference" href="#id16" id="id8">[7]</a>.
The former save the return register to virtual register while the later load the
virtual register back to return register.
Since the return value is &#8220;struct type&#8221; and over 4 registers size, it save
pointer (struct address) to return register.
List the code and their effect as follows,</p>
<p class="rubric">lbdex/Chapter9_4/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                     <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                     <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                     <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                      <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="cp">#if 1 </span><span class="c1">// Incomming. Without this, it will use $3 instead of $2 as return</span>
  <span class="c1">// register. The cpu0 ABIs for returning structs by value requires that we</span>
  <span class="c1">// copy the sret argument into $v0 for the return. Save the argument into</span>
  <span class="c1">// a virtual register so that we can access it from the return points.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasStructRetAttr</span><span class="p">())</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>
    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span> <span class="p">{</span>
      <span class="n">Reg</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getRegInfo</span><span class="p">().</span><span class="n">createVirtualRegister</span><span class="p">(</span><span class="n">getRegClassFor</span><span class="p">(</span><span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">));</span>
      <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setSRetReturnReg</span><span class="p">(</span><span class="n">Reg</span><span class="p">);</span>
    <span class="p">}</span>
    <span class="n">SDValue</span> <span class="n">Copy</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getEntryNode</span><span class="p">(),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">InVals</span><span class="p">[</span><span class="mi">0</span><span class="p">]);</span>
    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getNode</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">TokenFactor</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Copy</span><span class="p">,</span> <span class="n">Chain</span><span class="p">);</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// lbd document - mark - endif - hasStructRetAttr()</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>addiu <span class="nv">$2</span>, <span class="nv">$sp</span>, 168
st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // *0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span> <span class="o">=</span> 168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>; LowerFormalArguments<span class="o">()</span>:
                    //  <span class="k">return </span>register is <span class="nv">$2</span>, virtual register is
                    //  0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z8copyDate4Date<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter3_6/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerReturn</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span> <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">OutputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Outs</span><span class="p">,</span>
                <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">OutVals</span><span class="p">,</span>
                <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
<span class="cp">#if 1 </span><span class="c1">// structure return begin. Without this, it will use $3 instead of $2</span>
  <span class="c1">// as return register. The cpu0 ABIs for returning structs by value requires</span>
  <span class="c1">// that we copy the sret argument into $v0 for the return. We saved the</span>
  <span class="c1">// argument into a virtual register in the entry block, so now we copy the</span>
  <span class="c1">// value out and into $v0.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">().</span><span class="n">getFunction</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasStructRetAttr</span><span class="p">())</span> <span class="p">{</span>
    <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span>      <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
    <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">Cpu0FI</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>
    <span class="kt">unsigned</span> <span class="n">Reg</span> <span class="o">=</span> <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">getSRetReturnReg</span><span class="p">();</span>

    <span class="k">if</span> <span class="p">(</span><span class="o">!</span><span class="n">Reg</span><span class="p">)</span>
      <span class="n">llvm_unreachable</span><span class="p">(</span><span class="s">&quot;sret virtual register not created in the entry block&quot;</span><span class="p">);</span>
    <span class="n">SDValue</span> <span class="n">Val</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyFromReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Reg</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">());</span>

    <span class="n">Chain</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getCopyToReg</span><span class="p">(</span><span class="n">Chain</span><span class="p">,</span> <span class="n">DL</span><span class="p">,</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">,</span> <span class="n">Val</span><span class="p">,</span> <span class="n">Flag</span><span class="p">);</span>
    <span class="n">Flag</span> <span class="o">=</span> <span class="n">Chain</span><span class="p">.</span><span class="n">getValue</span><span class="p">(</span><span class="mi">1</span><span class="p">);</span>
    <span class="n">RetOps</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">DAG</span><span class="p">.</span><span class="n">getRegister</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">V0</span><span class="p">,</span> <span class="n">getPointerTy</span><span class="p">()));</span>
  <span class="p">}</span>
<span class="cp">#endif </span><span class="c1">// structure return end</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<div class="highlight-bash"><div class="highlight"><pre>  ...
  .file       <span class="s2">&quot;ch9_2_1.bc&quot;</span>
  ...
  .globl  _Z8copyDateP4Date
  .align  2
  .type _Z8copyDateP4Date,@function
  .ent  _Z8copyDate4Date        <span class="c"># @_Z8copyDate4Date</span>
_Z8copyDate4Date:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,0,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  st  <span class="nv">$5</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>        // <span class="nv">$2</span> <span class="o">=</span> 168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>; LowerReturn<span class="o">()</span>: virtual
                        //  register is 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>, <span class="k">return </span>register is <span class="nv">$2</span>
  ld  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>        // copy date1, 24..4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>, to date2,
  ld  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>       //  188..168<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8copyDate4Date
</pre></div>
</div>
<p>The ch9_2_2.cpp include C++ class &#8220;Date&#8221; implementation.
It can be translated into cpu0 backend too since the front end (clang in this
example) translate them into C language form.
You can also mark the &#8220;hasStructRetAttr() if&#8221; part from both of above functions,
the output cpu0 code for ch9_2_1.cpp will use $3 instead of $2 as return
register as follows,</p>
<div class="highlight-bash"><div class="highlight"><pre>  ...
  .file       <span class="s2">&quot;ch9_2_1.bc&quot;</span>
  ...
  .globl  _Z8copyDateP4Date
  .align  2
  .type _Z8copyDateP4Date,@function
  .ent  _Z8copyDateP4Date       <span class="c"># @_Z8copyDateP4Date</span>
_Z8copyDateP4Date:
  .cfi_startproc
  .frame  <span class="nv">$sp</span>,8,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -8
<span class="nv">$tmp3</span>:
  .cfi_def_cfa_offset 8
  ld  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 20<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 16<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 12<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  ld  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$4</span>, 4<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$3</span><span class="o">)</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 8
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z8copyDateP4Date
</pre></div>
</div>
</div>
<div class="section" id="variable-number-of-arguments">
<h3>Variable number of arguments<a class="headerlink" href="#variable-number-of-arguments" title="Permalink to this headline">¶</a></h3>
<p>Until now, we support fixed number of arguments in formal function definition
(Incoming Arguments).
This section support variable number of arguments since C language support
this feature.</p>
<p>Run Chapter9_4/ with ch9_3.cpp as well as clang option,
<strong>clang -target mips-unknown-linux-gnu</strong>, to get the following result,</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>clang -target mips-unknown-linux-gnu -c
ch9_3.cpp -emit-llvm -o ch9_3.bc
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/
cmake_debug_build/bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm
ch9_3.bc -o ch9_3.cpu0.s
118-165-76-131:InputFiles Jonathan<span class="nv">$ </span>cat ch9_3.cpu0.s
  .section .mdebug.abi32
  .previous
  .file <span class="s2">&quot;ch9_3.bc&quot;</span>
  .text
  .globl  _Z5sum_iiz
  .align  2
  .type _Z5sum_iiz,@function
  .ent  _Z5sum_iiz              <span class="c"># @_Z5sum_iiz</span>
_Z5sum_iiz:
  .frame  <span class="nv">$sp</span>,24,<span class="nv">$lr</span>
  .mask   0x00000000,0
  .set  noreorder
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -24
  ld  <span class="nv">$2</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     // amount
  st  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     // amount
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     // i
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>     // val
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // sum
  addiu <span class="nv">$3</span>, <span class="nv">$sp</span>, 28
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // <span class="nv">arg_ptr</span> <span class="o">=</span> 2nd <span class="nv">argument</span> <span class="o">=</span> &amp;arg<span class="o">[</span>1<span class="o">]</span>,
              // since &amp;arg<span class="o">[</span>0<span class="o">]</span> <span class="o">=</span> 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
<span class="nv">$BB0_1</span>:                                 <span class="c"># =&gt;This Inner Loop Header: Depth=1</span>
  ld  <span class="nv">$2</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  cmp <span class="nv">$3</span>, <span class="nv">$2</span>        // compare<span class="o">(</span>i, amount<span class="o">)</span>
  jge <span class="nv">$BB0_4</span>
  jmp <span class="nv">$BB0_2</span>
<span class="nv">$BB0_2</span>:                                 <span class="c">#   in Loop: Header=BB0_1 Depth=1</span>
              // i &lt; amount
  ld  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$2</span>, 4   // arg_ptr  + 4
  st  <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>     // *arg_ptr
  st  <span class="nv">$2</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>      // sum
  add <span class="nv">$2</span>, <span class="nv">$3</span>, <span class="nv">$2</span>      // sum +<span class="o">=</span> *arg_ptr
  st  <span class="nv">$2</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
<span class="c"># BB#3:                                 #   in Loop: Header=BB0_1 Depth=1</span>
              // i &gt;<span class="o">=</span> amount
  ld  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$2</span>, 1   // i++
  st  <span class="nv">$2</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  jmp <span class="nv">$BB0_1</span>
<span class="nv">$BB0_4</span>:
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 24
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z5sum_iiz
<span class="nv">$tmp1</span>:
  .size _Z5sum_iiz, <span class="o">(</span><span class="nv">$tmp1</span><span class="o">)</span>-_Z5sum_iiz

  .globl  _Z11test_varargv
  .align  2
  .type _Z11test_varargv,@function
  .ent  _Z11test_varargv                    <span class="c"># @_Z11test_varargv</span>
_Z11test_varargv:
  .frame  <span class="nv">$sp</span>,88,<span class="nv">$lr</span>
  .mask   0x00004000,-4
  .set  noreorder
  .cpload <span class="nv">$t9</span>
  .set  nomacro
<span class="c"># BB#0:</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, -88
  st  <span class="nv">$lr</span>, 84<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
  .cprestore  32
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 0
  st  <span class="nv">$2</span>, 80<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 5
  st  <span class="nv">$3</span>, 24<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 4
  st  <span class="nv">$3</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 3
  st  <span class="nv">$3</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 2
  st  <span class="nv">$3</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$3</span>, <span class="nv">$zero</span>, 1
  st  <span class="nv">$3</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  addiu <span class="nv">$2</span>, <span class="nv">$zero</span>, 6
  st  <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z5sum_iiz<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
  jalr  <span class="nv">$t9</span>
  ld  <span class="nv">$gp</span>, 32<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  st  <span class="nv">$2</span>, 76<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
  ld  <span class="nv">$lr</span>, 84<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
  addiu <span class="nv">$sp</span>, <span class="nv">$sp</span>, 88
  ret <span class="nv">$lr</span>
  .set  macro
  .set  reorder
  .end  _Z11test_varargv
<span class="nv">$tmp4</span>:
  .size _Z11test_varargv, <span class="o">(</span><span class="nv">$tmp4</span><span class="o">)</span>-_Z11test_varargv
</pre></div>
</div>
<p>The analysis of output ch9_3.cpu0.s as above in comment.
As above code, in # BB#0, we get the first argument <strong>“amount”</strong> from
<strong>“ld $2, 24($sp)”</strong> since the stack size of the callee function
<strong>“_Z5sum_iiz()”</strong> is 24. And set argument pointer, arg_ptr, to 28($sp),
&amp;arg[1].
Next, check i &lt; amount in block $BB0_1. If  i &lt; amount, than enter into $BB0_2.
In $BB0_2, it do sum += *arg_ptr as well as arg_ptr+=4.
In # BB#3, do i+=1.</p>
<p>To support variable number of arguments, the following code needed to
add in Chapter9_4/.
The ch9_3_2.cpp is C++ template example code, it can be translated into cpu0
backend code too.</p>
<p class="rubric">lbdex/Chapter9_4/Cpu0ISelLowering.h</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="k">class</span> <span class="nc">Cpu0TargetLowering</span> <span class="o">:</span> <span class="k">public</span> <span class="n">TargetLowering</span>  <span class="p">{</span>
<span class="p">...</span>
<span class="nl">private:</span>
  <span class="p">...</span>
  <span class="n">SDValue</span> <span class="n">LowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span><span class="p">;</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_4/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
  <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VASTART</span><span class="p">,</span>            <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Custom</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="c1">// Support va_arg(): variable numbers (not fixed numbers) of arguments</span>
  <span class="c1">//  (parameters) for function all</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VAARG</span><span class="p">,</span>             <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VACOPY</span><span class="p">,</span>            <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">VAEND</span><span class="p">,</span>             <span class="n">MVT</span><span class="o">::</span><span class="n">Other</span><span class="p">,</span> <span class="n">Expand</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
<span class="p">...</span>

<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">LowerOperation</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span>
<span class="p">{</span>
  <span class="k">switch</span> <span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOpcode</span><span class="p">())</span>
  <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">case</span> <span class="n">ISD</span>:<span class="o">:</span><span class="n">VASTART</span><span class="o">:</span>            <span class="k">return</span> <span class="n">LowerVASTART</span><span class="p">(</span><span class="n">Op</span><span class="p">,</span> <span class="n">DAG</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="k">return</span> <span class="n">SDValue</span><span class="p">();</span>
<span class="p">}</span>

<span class="p">...</span>
<span class="n">SDValue</span> <span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerVASTART</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Op</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getMachineFunction</span><span class="p">();</span>
  <span class="n">Cpu0FunctionInfo</span> <span class="o">*</span><span class="n">FuncInfo</span> <span class="o">=</span> <span class="n">MF</span><span class="p">.</span><span class="n">getInfo</span><span class="o">&lt;</span><span class="n">Cpu0FunctionInfo</span><span class="o">&gt;</span><span class="p">();</span>

  <span class="n">SDLoc</span> <span class="n">DL</span> <span class="o">=</span> <span class="n">SDLoc</span><span class="p">(</span><span class="n">Op</span><span class="p">);</span>
  <span class="n">SDValue</span> <span class="n">FI</span> <span class="o">=</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getFrameIndex</span><span class="p">(</span><span class="n">FuncInfo</span><span class="o">-&gt;</span><span class="n">getVarArgsFrameIndex</span><span class="p">(),</span>
                 <span class="n">getPointerTy</span><span class="p">());</span>

  <span class="c1">// vastart just stores the address of the VarArgsFrameIndex slot into the</span>
  <span class="c1">// memory location argument.</span>
  <span class="k">const</span> <span class="n">Value</span> <span class="o">*</span><span class="n">SV</span> <span class="o">=</span> <span class="n">cast</span><span class="o">&lt;</span><span class="n">SrcValueSDNode</span><span class="o">&gt;</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">2</span><span class="p">))</span><span class="o">-&gt;</span><span class="n">getValue</span><span class="p">();</span>
  <span class="k">return</span> <span class="n">DAG</span><span class="p">.</span><span class="n">getStore</span><span class="p">(</span><span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">0</span><span class="p">),</span> <span class="n">DL</span><span class="p">,</span> <span class="n">FI</span><span class="p">,</span> <span class="n">Op</span><span class="p">.</span><span class="n">getOperand</span><span class="p">(</span><span class="mi">1</span><span class="p">),</span>
            <span class="n">MachinePointerInfo</span><span class="p">(</span><span class="n">SV</span><span class="p">),</span> <span class="nb">false</span><span class="p">,</span> <span class="nb">false</span><span class="p">,</span> <span class="mi">0</span><span class="p">);</span>
<span class="p">}</span>
<span class="p">...</span>
<span class="n">SDValue</span>
<span class="n">Cpu0TargetLowering</span><span class="o">::</span><span class="n">LowerFormalArguments</span><span class="p">(</span><span class="n">SDValue</span> <span class="n">Chain</span><span class="p">,</span>
                     <span class="n">CallingConv</span><span class="o">::</span><span class="n">ID</span> <span class="n">CallConv</span><span class="p">,</span>
                     <span class="kt">bool</span> <span class="n">isVarArg</span><span class="p">,</span>
                    <span class="k">const</span> <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">ISD</span><span class="o">::</span><span class="n">InputArg</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">Ins</span><span class="p">,</span>
                     <span class="n">SDLoc</span> <span class="n">DL</span><span class="p">,</span> <span class="n">SelectionDAG</span> <span class="o">&amp;</span><span class="n">DAG</span><span class="p">,</span>
                     <span class="n">SmallVectorImpl</span><span class="o">&lt;</span><span class="n">SDValue</span><span class="o">&gt;</span> <span class="o">&amp;</span><span class="n">InVals</span><span class="p">)</span>
                      <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">isVarArg</span><span class="p">)</span> <span class="p">{</span>
    <span class="kt">unsigned</span> <span class="n">NumOfRegs</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
    <span class="kt">int</span> <span class="n">FirstRegSlotOffset</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="c1">// offset of $a0&#39;s slot.</span>
    <span class="kt">unsigned</span> <span class="n">RegSize</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">CPURegsRegClass</span><span class="p">.</span><span class="n">getSize</span><span class="p">();</span>
    <span class="kt">int</span> <span class="n">RegSlotOffset</span> <span class="o">=</span> <span class="n">FirstRegSlotOffset</span> <span class="o">+</span> <span class="n">ArgLocs</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">*</span> <span class="n">RegSize</span><span class="p">;</span>

    <span class="c1">// Offset of the first variable argument from stack pointer.</span>
    <span class="kt">int</span> <span class="n">FirstVaArgOffset</span><span class="p">;</span>

    <span class="n">FirstVaArgOffset</span> <span class="o">=</span> <span class="n">RegSlotOffset</span><span class="p">;</span>

    <span class="c1">// Record the frame index of the first variable argument</span>
    <span class="c1">// which is a value necessary to VASTART.</span>
    <span class="n">LastFI</span> <span class="o">=</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">CreateFixedObject</span><span class="p">(</span><span class="n">RegSize</span><span class="p">,</span> <span class="n">FirstVaArgOffset</span><span class="p">,</span> <span class="nb">true</span><span class="p">);</span>
    <span class="n">Cpu0FI</span><span class="o">-&gt;</span><span class="n">setVarArgsFrameIndex</span><span class="p">(</span><span class="n">LastFI</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/InputFiles/ch9_3_2.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="cp">#include &lt;stdarg.h&gt;</span>

<span class="k">template</span><span class="o">&lt;</span><span class="k">class</span> <span class="nc">T</span><span class="o">&gt;</span>
<span class="n">T</span> <span class="n">sum</span><span class="p">(</span><span class="n">T</span> <span class="n">amount</span><span class="p">,</span> <span class="p">...)</span>
<span class="p">{</span>
  <span class="n">T</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">val</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
  <span class="n">T</span> <span class="n">sum</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span>
	
  <span class="kt">va_list</span> <span class="n">vl</span><span class="p">;</span>
  <span class="n">va_start</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">amount</span><span class="p">);</span>
  <span class="k">for</span> <span class="p">(</span><span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">amount</span><span class="p">;</span> <span class="n">i</span><span class="o">++</span><span class="p">)</span>
  <span class="p">{</span>
    <span class="n">val</span> <span class="o">=</span> <span class="n">va_arg</span><span class="p">(</span><span class="n">vl</span><span class="p">,</span> <span class="n">T</span><span class="p">);</span>
    <span class="n">sum</span> <span class="o">+=</span> <span class="n">val</span><span class="p">;</span>
  <span class="p">}</span>
  <span class="n">va_end</span><span class="p">(</span><span class="n">vl</span><span class="p">);</span>
  
  <span class="k">return</span> <span class="n">sum</span><span class="p">;</span> 
<span class="p">}</span>

<span class="kt">int</span> <span class="n">test_template</span><span class="p">()</span>
<span class="p">{</span>
  <span class="kt">int</span> <span class="n">a</span> <span class="o">=</span> <span class="n">sum</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">(</span><span class="mi">6</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">,</span> <span class="mi">4</span><span class="p">,</span> <span class="mi">5</span><span class="p">);</span>
	
  <span class="k">return</span> <span class="n">a</span><span class="p">;</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Mips qemu reference <a class="footnote-reference" href="#id17" id="id9">[8]</a>, you can download and run it with gcc to verify the
result with printf() function. We will verify the code correction in chapter
&#8220;Run backend&#8221; through the CPU0 Verilog language machine.</p>
</div>
<div class="section" id="dynamic-stack-allocation-support">
<h3>Dynamic stack allocation support<a class="headerlink" href="#dynamic-stack-allocation-support" title="Permalink to this headline">¶</a></h3>
<p>Even though C language very rare to use dynamic stack allocation, there are
languages use it frequently. The following C example code use it.</p>
<p>Chapter9_4 support dynamic stack allocation with the following code added.</p>
<p class="rubric">lbdex/Chapter9_4/Cpu0FrameLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitPrologue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>
  <span class="p">...</span>
  <span class="c1">// if framepointer enabled, set it to point to the stack pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Insert instruction &quot;move $fp, $sp&quot; at this location.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">FP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>

    <span class="c1">// emit &quot;.cfi_def_cfa_register $fp&quot;</span>
    <span class="n">MCSymbol</span> <span class="o">*</span><span class="n">SetFPLabel</span> <span class="o">=</span> <span class="n">MMI</span><span class="p">.</span><span class="n">getContext</span><span class="p">().</span><span class="n">CreateTempSymbol</span><span class="p">();</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">MBBI</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span>
            <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">TargetOpcode</span><span class="o">::</span><span class="n">PROLOG_LABEL</span><span class="p">)).</span><span class="n">addSym</span><span class="p">(</span><span class="n">SetFPLabel</span><span class="p">);</span>
    <span class="n">DstML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">FP</span><span class="p">);</span>
    <span class="n">SrcML</span> <span class="o">=</span> <span class="n">MachineLocation</span><span class="p">(</span><span class="n">MachineLocation</span><span class="o">::</span><span class="n">VirtualFP</span><span class="p">);</span>
    <span class="n">Moves</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="n">MachineMove</span><span class="p">(</span><span class="n">SetFPLabel</span><span class="p">,</span> <span class="n">DstML</span><span class="p">,</span> <span class="n">SrcML</span><span class="p">));</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>

<span class="kt">void</span> <span class="n">Cpu0FrameLowering</span><span class="o">::</span><span class="n">emitEpilogue</span><span class="p">(</span><span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">,</span>
                                 <span class="n">MachineBasicBlock</span> <span class="o">&amp;</span><span class="n">MBB</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="kt">unsigned</span> <span class="n">FP</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ZERO</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ZERO</span><span class="p">;</span>
  <span class="kt">unsigned</span> <span class="n">ADDu</span> <span class="o">=</span> <span class="n">Cpu0</span><span class="o">::</span><span class="n">ADDu</span><span class="p">;</span>
  <span class="p">...</span>

  <span class="c1">// if framepointer enabled, restore the stack pointer.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="c1">// Find the first instruction that restores a callee-saved register.</span>
    <span class="n">MachineBasicBlock</span><span class="o">::</span><span class="n">iterator</span> <span class="n">I</span> <span class="o">=</span> <span class="n">MBBI</span><span class="p">;</span>

    <span class="k">for</span> <span class="p">(</span><span class="kt">unsigned</span> <span class="n">i</span> <span class="o">=</span> <span class="mi">0</span><span class="p">;</span> <span class="n">i</span> <span class="o">&lt;</span> <span class="n">MFI</span><span class="o">-&gt;</span><span class="n">getCalleeSavedInfo</span><span class="p">().</span><span class="n">size</span><span class="p">();</span> <span class="o">++</span><span class="n">i</span><span class="p">)</span>
      <span class="o">--</span><span class="n">I</span><span class="p">;</span>

    <span class="c1">// Insert instruction &quot;move $sp, $fp&quot; at this location.</span>
    <span class="n">BuildMI</span><span class="p">(</span><span class="n">MBB</span><span class="p">,</span> <span class="n">I</span><span class="p">,</span> <span class="n">dl</span><span class="p">,</span> <span class="n">TII</span><span class="p">.</span><span class="n">get</span><span class="p">(</span><span class="n">ADDu</span><span class="p">),</span> <span class="n">SP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">FP</span><span class="p">).</span><span class="n">addReg</span><span class="p">(</span><span class="n">ZERO</span><span class="p">);</span>
  <span class="p">}</span> <span class="c1">// lbd document - mark - emitEpilogue() if (hasFP(MF))</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_4/Cpu0ISelLowering.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="n">Cpu0TargetLowering</span><span class="o">::</span>
<span class="n">Cpu0TargetLowering</span><span class="p">(</span><span class="n">Cpu0TargetMachine</span> <span class="o">&amp;</span><span class="n">TM</span><span class="p">)</span>
  <span class="o">:</span> <span class="n">TargetLowering</span><span class="p">(</span><span class="n">TM</span><span class="p">,</span> <span class="k">new</span> <span class="n">Cpu0TargetObjectFile</span><span class="p">()),</span>
    <span class="n">Subtarget</span><span class="p">(</span><span class="o">&amp;</span><span class="n">TM</span><span class="p">.</span><span class="n">getSubtarget</span><span class="o">&lt;</span><span class="n">Cpu0Subtarget</span><span class="o">&gt;</span><span class="p">())</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="n">setOperationAction</span><span class="p">(</span><span class="n">ISD</span><span class="o">::</span><span class="n">DYNAMIC_STACKALLOC</span><span class="p">,</span> <span class="n">MVT</span><span class="o">::</span><span class="n">i32</span><span class="p">,</span>  <span class="n">Expand</span><span class="p">);</span>
  <span class="p">...</span>
  <span class="n">setStackPointerRegisterToSaveRestore</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">SP</span><span class="p">);</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p class="rubric">lbdex/Chapter9_4/Cpu0RegisterInfo.cpp</p>
<div class="highlight-c++"><div class="highlight"><pre><span class="c1">// pure virtual method</span>
<span class="n">BitVector</span> <span class="n">Cpu0RegisterInfo</span><span class="o">::</span>
<span class="n">getReservedRegs</span><span class="p">(</span><span class="k">const</span> <span class="n">MachineFunction</span> <span class="o">&amp;</span><span class="n">MF</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
  <span class="p">...</span>
  <span class="c1">// Reserve FP if this function should have a dedicated frame pointer register.</span>
  <span class="k">if</span> <span class="p">(</span><span class="n">MF</span><span class="p">.</span><span class="n">getTarget</span><span class="p">().</span><span class="n">getFrameLowering</span><span class="p">()</span><span class="o">-&gt;</span><span class="n">hasFP</span><span class="p">(</span><span class="n">MF</span><span class="p">))</span> <span class="p">{</span>
    <span class="n">Reserved</span><span class="p">.</span><span class="n">set</span><span class="p">(</span><span class="n">Cpu0</span><span class="o">::</span><span class="n">FP</span><span class="p">);</span>
  <span class="p">}</span>
  <span class="p">...</span>
<span class="p">}</span>
</pre></div>
</div>
<p>Run Chapter9_4 with ch9_4.cpp will get the following correct result.</p>
<div class="highlight-bash"><div class="highlight"><pre>118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>clang -I/Applications/Xcode.app/Contents/
Developer/Platforms/MacOSX.platform/Developer/SDKs/MacOSX10.9.sdk/usr/include/
-c ch9_4.cpp -emit-llvm -o ch9_4.bc
118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>llvm-dis ch9_4.bc -o ch9_4.ll
118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>cat ch9_4.ll
; <span class="nv">ModuleID</span> <span class="o">=</span> <span class="s1">&#39;ch9_4.bc&#39;</span>
target <span class="nv">datalayout</span> <span class="o">=</span> <span class="s2">&quot;e-p:64:64:64-i1:8:8-i8:8:8-i16:16:16-i32:32:32-i64:64:64-</span>
<span class="s2">f32:32:32-f64:64:64-v64:64:64-v128:128:128-a0:0:64-s0:64:64-f80:128:128-n8:16:</span>
<span class="s2">32:64-S128&quot;</span>
target <span class="nv">triple</span> <span class="o">=</span> <span class="s2">&quot;x86_64-apple-macosx10.8.0&quot;</span>

define i32 @_Z5sum_iiiiiii<span class="o">(</span>i32 %x1, i32 %x2, i32 %x3, i32 %x4, i32 %x5, i32 %x6<span class="o">)</span>
 nounwind uwtable ssp <span class="o">{</span>
  ...
  %10 <span class="o">=</span> alloca i8, i64 %9     // int *b <span class="o">=</span> <span class="o">(</span>int*<span class="o">)</span>alloca<span class="o">(</span>sizeof<span class="o">(</span>int<span class="o">)</span> * x1<span class="o">)</span>;
  %11 <span class="o">=</span> bitcast i8* %10 to i32*
  store i32* %11, i32** %b, align 8
  %12 <span class="o">=</span> load i32** %b, align 8
  store i32 1111, i32* %12, align 4   // *b <span class="o">=</span> 1111;
  ...
<span class="o">}</span>
...

118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>/Users/Jonathan/llvm/test/cmake_debug_build/
bin/Debug/llc -march<span class="o">=</span>cpu0 -relocation-model<span class="o">=</span>pic -filetype<span class="o">=</span>asm ch9_4.bc -o
ch9_4.cpu0.s
118-165-72-242:InputFiles Jonathan<span class="nv">$ </span>cat ch9_4.cpu0.s
...
_Z10weight_sumiiiiii:
      .cfi_startproc
      .frame  <span class="nv">$fp</span>,80,<span class="nv">$lr</span>
      .mask   0x00004080,-4
      .set    noreorder
      .cpload <span class="nv">$t9</span>
      .set    nomacro
<span class="c"># BB#0:</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, -80
<span class="nv">$tmp6</span>:
      .cfi_def_cfa_offset 80
      st      <span class="nv">$lr</span>, 76<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Spill</span>
      st      <span class="nv">$7</span>, 72<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Spill</span>
<span class="nv">$tmp7</span>:
      .cfi_offset 14, -4
<span class="nv">$tmp8</span>:
      .cfi_offset 7, -8
      add     <span class="nv">$fp</span>, <span class="nv">$sp</span>, <span class="nv">$zero</span>
<span class="nv">$tmp9</span>:
      .cfi_def_cfa_register 11
      .cprestore      24
      ld      <span class="nv">$7</span>, %got<span class="o">(</span>__stack_chk_guard<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$7</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 68<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 80<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 84<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 60<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 88<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 56<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 92<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 52<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 96<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 48<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 100<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 44<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>     // int *b <span class="o">=</span> <span class="o">(</span>int*<span class="o">)</span>alloca<span class="o">(</span>sizeof<span class="o">(</span>int<span class="o">)</span> * x1<span class="o">)</span>;
      shl     <span class="nv">$2</span>, <span class="nv">$2</span>, 2
      addiu   <span class="nv">$2</span>, <span class="nv">$2</span>, 7
      addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, -8
      and     <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
      subu    <span class="nv">$2</span>, <span class="nv">$sp</span>, <span class="nv">$2</span>
      add     <span class="nv">$sp</span>, <span class="nv">$zero</span>, <span class="nv">$2</span>  // <span class="nb">set </span>sp to the bottom of alloca area
      st      <span class="nv">$2</span>, 40<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 1111
      st      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$2</span><span class="o">)</span>
      ld      <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, 60<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$4</span>, 56<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$5</span>, 52<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$t9</span>, 48<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$t0</span>, 44<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$t0</span>, 20<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      shl     <span class="nv">$t9</span>, <span class="nv">$t9</span>, 1
      st      <span class="nv">$t9</span>, 16<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$5</span>, 12<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$4</span>, 8<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      st      <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      addiu   <span class="nv">$3</span>, <span class="nv">$zero</span>, 6
      mul     <span class="nv">$2</span>, <span class="nv">$2</span>, <span class="nv">$3</span>
      st      <span class="nv">$2</span>, 0<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
      ld      <span class="nv">$t9</span>, %call16<span class="o">(</span>_Z3sumiiiiii<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      jalr    <span class="nv">$t9</span>
      ld      <span class="nv">$gp</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      st      <span class="nv">$2</span>, 36<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      ld      <span class="nv">$3</span>, 0<span class="o">(</span><span class="nv">$7</span><span class="o">)</span>
      ld      <span class="nv">$4</span>, 68<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      bne     <span class="nv">$3</span>, <span class="nv">$4</span>, <span class="nv">$BB1_2</span>
<span class="c"># BB#1:                                 # %SP_return</span>
      add     <span class="nv">$sp</span>, <span class="nv">$fp</span>, <span class="nv">$zero</span>
      ld      <span class="nv">$7</span>, 72<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>             <span class="c"># 4-byte Folded Reload</span>
      ld      <span class="nv">$lr</span>, 76<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>            <span class="c"># 4-byte Folded Reload</span>
      addiu   <span class="nv">$sp</span>, <span class="nv">$sp</span>, 80
      ret     <span class="nv">$2</span>
<span class="nv">$BB1_2</span>:                                 <span class="c"># %CallStackCheckFailBlk</span>
      ld      <span class="nv">$t9</span>, %call16<span class="o">(</span>__stack_chk_fail<span class="o">)(</span><span class="nv">$gp</span><span class="o">)</span>
      jalr    <span class="nv">$t9</span>
      ld      <span class="nv">$gp</span>, 24<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
      .set    macro
      .set    reorder
      .end    _Z10weight_sumiiiiii
<span class="nv">$tmp10</span>:
      .size   _Z10weight_sumiiiiii, <span class="o">(</span><span class="nv">$tmp10</span><span class="o">)</span>-_Z10weight_sumiiiiii
      .cfi_endproc
...
</pre></div>
</div>
<p>As you can see, the dynamic stack allocation need frame pointer register <strong>fp</strong>
support. As <a class="pageref" href="#funccall-f4">Figure  3</a>, the sp is adjusted to sp - 56 when it
entered the function as usual by instruction <strong>addiu $sp, $sp, -56</strong>.
Next, the fp is set to sp where is the position just above alloca() spaces area
when meet instruction <strong>addu $fp, $sp, $zero</strong>.
After that, the sp is changed to the just below of alloca() area.
Remind, the alloca() area which the b point to,
<strong>&#8220;*b = (int*)alloca(sizeof(int) * x1)&#8221;</strong> is
allocated at run time since the spaces is variable size which depend on x1
variable and cannot be calculated at link time.</p>
<p><a class="pageref" href="#funccall-f5">Figure  4</a> depicted how the stack pointer changes back to the
caller stack bottom. As above, the <strong>fp</strong> is set to the just above of alloca().
The first step is changing the sp to fp by instruction <strong>addu $sp, $fp, $zero</strong>.
Next, sp is changed back to caller stack bottom by instruction
<strong>addiu $sp, $sp, 56</strong>.</p>
<div class="figure align-center" id="funccall-f4">
<a class="reference internal image-reference" href="_images/41.png"><img alt="_images/41.png" src="_images/41.png" style="width: 535.0px; height: 279.0px;" /></a>
<p class="caption">Figure 3: Frame pointer changes when enter function</p>
</div>
<div class="figure align-center" id="funccall-f5">
<a class="reference internal image-reference" href="_images/51.png"><img alt="_images/51.png" src="_images/51.png" style="width: 476.0px; height: 265.0px;" /></a>
<p class="caption">Figure 4: Stack pointer changes when exit function</p>
</div>
<div class="figure align-center" id="funccall-f6">
<a class="reference internal image-reference" href="_images/61.png"><img alt="_images/61.png" src="_images/61.png" style="width: 539.0px; height: 394.0px;" /></a>
<p class="caption">Figure 5: fp and sp access areas</p>
</div>
<p>Use fp to keep the old stack pointer value is not necessary. Actually, the sp
can back to the the old sp by add the alloca() spaces size. Most ABI like Mips
and ARM access the above area of alloca() by fp and the below area of alloca()
by sp, as <a class="pageref" href="#funccall-f6">Figure  5</a> depicted. The reason for this definition
is the speed for local variable access. Since the RISC CPU use immediate offset
for load and store as below, using fp and sp for access both areas of
local variables have better performance compare to use the sp only.</p>
<div class="highlight-bash"><div class="highlight"><pre>ld      <span class="nv">$2</span>, 64<span class="o">(</span><span class="nv">$fp</span><span class="o">)</span>
st      <span class="nv">$3</span>, 4<span class="o">(</span><span class="nv">$sp</span><span class="o">)</span>
</pre></div>
</div>
<p>Cpu0 use fp and sp to access the above and below areas of alloca() too.
As ch9_4.cpu0.s, it access local variable (above of alloca()) by fp offset
and outgoing arguments (below of alloca()) by sp offset.</p>
</div>
</div>
<div class="section" id="summary-of-this-chapter">
<h2>Summary of this chapter<a class="headerlink" href="#summary-of-this-chapter" title="Permalink to this headline">¶</a></h2>
<p>Until now, we have 6,000 lines of source code around in the end of this chapter.
The cpu0 backend code now can take care the integer function call and control
statement just like the llvm front end tutorial example code.
Look back the chapter of “Back end structure”, there are 3,100 lines of source
code with taking three instructions only.
With this 95% more of code, it can translate tens of instructions, global
variable, control flow statement and function call.
Now the cpu0 backend is not just a toy.
It can translate the C++ OOP language into Cpu0 instructions without much
effort.
Because the most complex things in language, such as C++ syntex, is handled by
front end.
LLVM is an real structure following the compiler theory, any backend of LLVM can
benefit from this structure.
A couple of thousands lines of code make OOP language translated into your backend.
And your backend will grow up automatically through the front end support languages
more and more.</p>
<table class="docutils footnote" frame="void" id="id10" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id1">[1]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/ctrlflow.html#risc-cpu-knowledge">http://jonathan2251.github.io/lbd/ctrlflow.html#risc-cpu-knowledge</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id11" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id2">[2]</a></td><td><a class="reference external" href="https://www.dropbox.com/sh/2pkh1fewlq2zag9/OHnrYn2nOs/doc/MIPSproAssemblyLanguageProgrammerGuide">https://www.dropbox.com/sh/2pkh1fewlq2zag9/OHnrYn2nOs/doc/MIPSproAssemblyLanguageProgrammerGuide</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id12" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id3">[3]</a></td><td><a class="reference external" href="http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf">http://www.linux-mips.org/pub/linux/mips/doc/ABI/mipsabi.pdf</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id13" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id4">[4]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration">http://jonathan2251.github.io/lbd/llvmstructure.html#target-registration</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id14" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id5">[5]</a></td><td><a class="reference external" href="http://jonathan2251.github.io/lbd/globalvar.html#global-variable">http://jonathan2251.github.io/lbd/globalvar.html#global-variable</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id15" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id6">[6]</a></td><td><a class="reference external" href="http://en.wikipedia.org/wiki/Tail_call">http://en.wikipedia.org/wiki/Tail_call</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id16" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id8">[7]</a></td><td><a class="reference external" href="http://developer.mips.com/clang-llvm/">http://developer.mips.com/clang-llvm/</a></td></tr>
</tbody>
</table>
<table class="docutils footnote" frame="void" id="id17" rules="none">
<colgroup><col class="label" /><col /></colgroup>
<tbody valign="top">
<tr><td class="label"><a class="fn-backref" href="#id9">[8]</a></td><td>section &#8220;4.5.1 Calling Conventions&#8221; of tricore_llvm.pdf</td></tr>
</tbody>
</table>
</div>
</div>


      </div>
      <div class="bottomnav">
      
        <p>
        «&#160;&#160;<a href="ctrlflow.html">Control flow statements</a>
        &#160;&#160;::&#160;&#160;
        <a class="uplink" href="index.html">Contents</a>
        &#160;&#160;::&#160;&#160;
        <a href="elf.html">ELF Support</a>&#160;&#160;»
        </p>

      </div>

    <div class="footer">
        &copy; Copyright 2013, LLVM.
      Created using <a href="http://sphinx-doc.org/">Sphinx</a> 1.2.
    </div>
  </body>
</html>